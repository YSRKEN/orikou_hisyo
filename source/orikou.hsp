/* おりこうさんな秘書 Ver.2.1.0 */

	#packopt name "orikou"
	#define kSoftName       "おりこうさんな秘書"
	#define kSoftVer        "Ver.2.1.0"
	#define kSoftVer2       "210"
	#define kSoftLastUpdate "2015/08/05"

	sdim error_log, 1024 * 1024
	exist dir_cur + "\\soft.log"
	if(strsize != -1){
		notesel error_log
		noteload dir_cur + "\\soft.log"
	}
	onerror *error_msg

/* プリプロセッサ */
	#include "hspcv.as"
	#include "hspext.as"
	#include "const.hsp"
	#include "module.hsp"
	#include "window.hsp"
	#include "system.hsp"

/* メインルーチン */
	#include "gui.hsp"
	onexit gosub *exit

// メインループ
	//変化監視用変数初期化
	screen_shot_type_ = screen_shot_type
	;経験値計算機
	now_level_       = now_level
	goal_level_      = goal_level
	area_index_      = area_index
	reader_ship_flg_ = reader_ship_flg
	mvp_flg_         = mvp_flg
	result_index_    = result_index
	exp_ss_flg_ = exp_ss_flg
	;BGM
	bgm_type_ = -1
	now_bgm = -1
	;ソート一覧
	sort_index_ = sort_index
	;資源グラフ
	mouse_button_flg = FALSE
	scale_mode_ = scale_mode
	zero_interpolation_flg_ = zero_interpolation_flg
	;最終更新日時
	show_date_flg_ = show_date_flg
	;○号カウンター支援
	ac_sortie   = FALSE :ac_sortie_   = ac_sortie
	ac_win_s    = FALSE :ac_win_s_    = ac_win_s
	ac_kill_sup = FALSE :ac_kill_sup_ = ac_kill_sup
	ac_kill_air = FALSE :ac_kill_air_ = ac_kill_air
	ac_boss_battle = FALSE :ac_boss_battle_ = ac_boss_battle
	ac_boss_win = FALSE :ac_boss_win_ = ac_boss_win
	;ショートカットキー
	snap_key_flg = FALSE
	//ループしつつ監視
	repeat
		if(exit_flg) :end
		SetTitle
		// Flash画面を自動取得
		if(get_pos_flg == FALSE){
			;ディスプレイ全体からBitBltするタイプ
			GetFlashWindow kFlashBufferID, flash_px, flash_py
		}else{
			;ブラウザからBitBltするタイプ
			GetFlashWindow2 handle, kFlashBufferID, flash_px, flash_py
		}
		// 結果を判定し、自動で格納する
		screen_shot_type = JudgeSituation(kFlashBufferID, 1)
		sst_str = SstToStr(screen_shot_type)
		if(screen_shot_type != kTypeUnknown){
			if(screen_shot_type != kTypeDrop){
				gsel kCaptureBufferID + screen_shot_type - 1
				gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
				if(screen_shot_type <= kSceneListSize){
					;戦闘画面(昼戦画面と夜戦画面と夜戦マス)ならば再度コピーする
					if((sst_str == "昼戦画面") || (sst_str == "夜戦画面") || (sst_str == "夜戦マス")){
						gsel kBattleBufferID
						gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
					}
				}
			}else{
				gsel kDropBufferID
				gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
			}
		}
		//艦隊における艦娘数を認識し、減少した場合はバッファを初期化する
		if(screen_shot_type >= kSceneListSize + 1){
			GetUnits kFlashBufferID, screen_shot_type, unit_count
			for i, 0, kFleetNum
				if(unit_count_(i) != unit_count(i)){
					error_log += NowTime() + ",change_units," + unit_count_(i) + "→" + unit_count(i) + "\n"
					if(unit_count_(i) > unit_count(i)){
						for j, unit_count(i), unit_count_(i)
							gsel kUnitIdOffset + i * kUnitNum + j
							color 255, 255, 255 :boxf
						next
					}
					unit_count_(i) = unit_count(i)
				}
			next
		}
		// アプリの状態に合わせ表示を変更する
		//サブ画面のサイズを変更する
		if((zooming_index_ != zooming_index) || (show_date_flg_ != show_date_flg)){
			screen kPutWindowID, zooming_num(zooming_index) * kFlashWX / 100, zooming_num(zooming_index) * kFlashWY / 100 + kStatusBarY * show_date_flg, 4
			gsel kPutWindowID, 2
			zooming_index_ = zooming_index
			show_date_flg_ = show_date_flg
		}
		//サブ画面用バッファに画像を転送する
		gsel kPutTempWindowID
		if(mode_index == kTypeNow){
			//現在状況
			gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
		}else{
			//それ以外
			if(mode_index == kSceneListSize + 1){
				;編成画面
				gcopy kFleetIdOffset + fleets_index, 0, 0, kFlashWX, kFlashWY
			}else{if(mode_index == kSceneListSize + 2){
				;改装画面
				gcopy kUnitIdOffset + units_index, 0, 0, kFlashWX, kFlashWY
			}else{if(mode_index == kSceneListSize + 3){
				;戦闘画面(特殊)
				gcopy kBattleBufferID, 0, 0, kFlashWX, kFlashWY
			}else{if(mode_index == kSceneListSize + 4){
				;ドロップ画面
				gcopy kDropBufferID, 0, 0, kFlashWX, kFlashWY
			}else{
				;その他
				gcopy kCaptureBufferID + mode_index - 1, 0, 0, kFlashWX, kFlashWY
			}}}}
		}
		//サブ画面のバッファに名前隠し処理を行う
		if(name_disable_flg){
			if(CheckHomeFlg(kPutTempWindowID)){	;要するに左上の歯車のすぐ右
				color 38,38,38
				boxf 111, 0, 273, 25
			}
			screen_shot_type2 = JudgeSituation(kPutTempWindowID, 0)
			sst_str2 = SstToStr(screen_shot_type2)
			if(screen_shot_type2 < kSceneListSize){
				if(sst_str2 == "戦績表示"){
					color 241,234,221
					boxf 201, 123, 496, 153
				}
				if(sst_str2 == "ランキング"){
					color 54,54,54
					boxf 225, 153, 375, 451
				}
				if(sst_str2 == "交戦結果"){
					color 37,44,47
					boxf  92,  82, 264, 106
				}
				if(sst_str2 == "戦果報告"){
					color 37,44,47
					boxf  56,  82, 228, 106
				}
				if(sst_str2 == "演習一覧"){
					color 225,209,181
					boxf 338, 178, 503, 192
					color 237,223,207
					boxf 338, 233, 503, 247
					color 225,209,181
					boxf 338, 288, 503, 302
					color 237,223,207
					boxf 338, 343, 503, 357
					color 225,209,181
					boxf 338, 398, 503, 412
				}
				if(sst_str2 == "演習個別"){	//
					color 246,239,228
					boxf 130,  87, 425, 117
				}
			}
			;遠征結果
			if(NearColor(776,444,22,148,150)){
				if(NearColor(395,79,255,246,242)){
					if(NearColor(411,352,29,159,164)){
						color 37,44,47
						boxf  65,  78, 237, 102
					}
				}
			}
		}
		// デノイズを行う
		if(denoise_flg) :Denoise
		// サブ画面にサブ画面用バッファの画像を変倍して転送する
		PutWindowSet kPutWindowID, kPutTempWindowID
		//大破チェッカー機能
		gosub *check_deadzone
		//経験値計算機
		if(now_level_       != now_level)       :gosub *exp_calc :now_level_       = now_level
		if(goal_level_      != goal_level)      :gosub *exp_calc :goal_level_      = goal_level
		if(area_index_      != area_index)      :gosub *exp_calc :area_index_      = area_index
		if(reader_ship_flg_ != reader_ship_flg) :gosub *exp_calc :reader_ship_flg_ = reader_ship_flg
		if(mvp_flg_         != mvp_flg)         :gosub *exp_calc :mvp_flg_         = mvp_flg
		if(result_index_    != result_index)    :gosub *exp_calc :result_index_    = result_index
		if(exp_ss_flg_      != exp_ss_flg)      :gosub *exp_calc :exp_ss_flg_      = exp_ss_flg
		if(exp_unit_index_  != exp_unit_index)  :gosub *exp_calc :exp_unit_index_  = exp_unit_index
		//入渠タイマー
		if(dock_time != gettime(6)){
			gsel kDockWindowID
			gosub *increment_dock
			gosub *redraw_dock
			dock_time = gettime(6)
		}
		//BGM機能
		;現在の状況を診断
		bgm_type = -1
		if(CheckHomeFlg(kFlashBufferID)) :bgm_type = 0
		if(screen_shot_type <= kSceneListSize){
			if(sst_str == "マップ画面") :bgm_type = 1
			if(sst_str == "昼戦画面")   :bgm_type = 2
			if(sst_str == "夜戦画面")   :bgm_type = 2
			if(sst_str == "夜戦マス")   :bgm_type = 2
			if(sst_str == "交戦結果")   :bgm_type = kBgmListSize
			if(sst_str == "戦果報告")   :bgm_type = kBgmListSize
			if((bgm_type == 2) && (ac_boss_battle)) :bgm_type = 3
		}
		;現在の状況が変化した際、BGMを再生/停止する
		if((bgm_type_ != bgm_type) && (bgm_type != -1)){
			if(bgm_type >= kBgmListSize){
				mmstop
			}else{
				if(bgm_list_flg(bgm_type)){
					mmplay bgm_type
					now_bgm = bgm_type
				}else{
					mmstop
				}
			}
			bgm_type_ = bgm_type
		}
		//自動ズレ補正
		get_pos_flg2 = FALSE	//補正が入った場合はTRUEになる
		if(get_pos_flg){						;一回以上座標補正を利用した場合のみ発動
			if(auto_set_time != gettime(6)){	;1秒毎にズレ判定を行う
				if(auto_set_flg){				;ズレ補正にチェックが入っていた場合のみ発動
					if(CheckAutoSet()){			;ズレが存在する場合のみ発動
						get_handle_flg = FALSE
						gosub *get_pos
						get_handle_flg = TRUE
						get_pos_flg2 = TRUE
					}else{
						;大破チェック用に、ズレ検出機構を新たに設ける
						dim rect_, 4
						GetClientSize handle, rect_
						if((rect_(0) != rect(0)) || (rect_(1) != rect(1))){
							flash_px += rect_(0) - rect(0)
							flash_py += rect_(1) - rect(1)
							for k, 0, 4
								rect(k) = rect_(k)
							next
							get_pos_flg2 = TRUE
						}
					}
				}
				auto_set_time = gettime(6)
			}
		}
		//ソート一覧
		if(sort_index_ != sort_index){
			gosub *redraw_sort_preview
			error_log += NowTime() + ",sort_preview," + sort_index_ + "→" + sort_index + "\n"
			sort_index_ = sort_index
		}
		//ステータスバーに最終更新日時を表示する
		gosub *draw_last_update
		// 資源ログ機能
		gosub *put_supply_log
		// 資源グラフをチェックに応じて書き換える
		if(zero_interpolation_flg_ != zero_interpolation_flg){
			gosub *make_graph
			gosub *plot_graph
			zero_interpolation_flg_ = zero_interpolation_flg
		}
		// 資源グラフをスクロールする
		if(ginfo_act == kSupplyGraphID){
			// キー操作を検知する
			;Ctrlキーが押されている場合は、ゆっくりスクロールするようにする
			;A・Dキーで小スクロール、W・Sキーで大スクロール
			getkey trigger_flg, 17 :if(trigger_flg) :wait 50
			getkey key_flg_a, 'A' :getkey key_flg_d, 'D' :getkey key_flg_w, 'W' :getkey key_flg_s, 'S'
			plot_graph_px += kGraphStepX * (key_flg_d - key_flg_a) + kGraphWX * (key_flg_s - key_flg_w)
			gosub *plot_graph
		}
		// ○号カウンターの自動化
		//(演習中は無効にしたいが、判定が面倒なのよね……)
		gsel kFlashBufferID
		if(NearColor(53,37,2,7,6)){
			if(NearColor(540,388,67,141,135)){
				exercises_flg = TRUE
			}
		}
		if(sst_str == "母港画面") :exercises_flg = FALSE
		gsel kMainWindowID
		gosub *auto_count_routine
		// 各種タイマーの自動更新
		gosub *auto_timer_routine
		// 自動セーブ
		if(auto_save_flg2){
			if((save_last_time == -1) || (timeGetTime() - save_last_time > 1000 * 60 * 5)){
				save_last_time = timeGetTime()
				WriteSaveData 0
				error_log += NowTime() + ",auto_save,\n"
				notesel error_log
				notesave pic_save_path(0) + "\\soft.log"
				gsel kMainWindowID
			}
		}
		// 消耗チェック
		gosub *check_exhausted
		// ショートカットキー
		stick ky,kStickSpace + kStickCtrl,0
		if(ky & kStickSpace){
			if(ky & kStickCtrl){
				if(snap_key_flg == FALSE){
					gosub *save_picture
					snap_key_flg = TRUE
				}
			}else{
				snap_key_flg = FALSE
			}
		}else{
			snap_key_flg = FALSE
		}
		// 連写
		if(auto_save_picture_flg){
			gosub *save_picture
		}
		// ウェイト
		await 1000 / fps_num(fps_index)
		if(screen_shot_type_ != screen_shot_type){
			error_log += NowTime() + ",scene_change," + screen_shot_type_ + "→" + screen_shot_type + "\n"
		}
		screen_shot_type_ = screen_shot_type
	loop

//終了確認
*exit
	dialog "終了しますか？", 2, kSoftName
	if(stat == 6){
		if(auto_save_flg) :WriteSaveData 1
		error_log += NowTime() + ",exit_soft,\n"
		notesel error_log
		notesave pic_save_path(0) + "\\soft.log"
		exit_flg = TRUE
	}
return

//エラー処理
*error_msg
	dialog "エラーが発生しました。\nエラー番号：" + wparam, 1, kSoftName
	error_log += NowTime() + ",error_soft," + wparam + "-" + lparam + "\n"
	notesel error_log
	notesave pic_save_path(0) + "\\soft.log"
	exit_flg = TRUE
	end
