/* おりこうさんな秘書 Ver.2.0.4 */

	#packopt name "orikou"
	#define kSoftName       "おりこうさんな秘書"
	#define kSoftVer        "Ver.2.0.4"
	#define kSoftVer2       "204"
	#define kSoftLastUpdate "2015/07/18"

/* プリプロセッサ */
	#include "hspcv.as"
	#include "hspext.as"
	#include "const.hsp"
	#include "module.hsp"
	#include "window.hsp"

/* メインルーチン */
// ウィンドウ周りを初期設定
	//オプション画面
	screen kOptionWindowID, kObjSpace + kObjSpaceX * 3, kObjSpace + kObjSpaceY * 6, 4
	gsel kOptionWindowID, -1
	title "オプション"
	font msgothic, kSmallFontSize
		pos kObjSpace                 , kObjSpace + kObjSpaceY * 3 + kObjOffset
			mes pic_save_path(1)
	objsize kObjX, kObjY
		pos kObjSpace                 , kObjSpace
			chkbox "名前隠し",     name_disable_flg
		pos kObjSpace + kObjSpaceX    , kObjSpace
			chkbox "カーソル",     cursor_flg
		pos kObjSpace + kObjSpaceX * 2, kObjSpace
			chkbox "大破チェック", dead_zone_flg
		pos kObjSpace                 , kObjSpace + kObjSpaceY
			chkbox "画面クロップ", cap_crop_flg
		pos kObjSpace + kObjSpaceX    , kObjSpace + kObjSpaceY
			chkbox "ズレ補正",     auto_set_flg
		pos kObjSpace + kObjSpaceX * 2, kObjSpace + kObjSpaceY
			chkbox "終了セーブ",   auto_save_flg
		pos kObjSpace                 , kObjSpace + kObjSpaceY * 2
			chkbox "フォルダ指定", my_folder_flg
		pos kObjSpace + kObjSpaceX    , kObjSpace + kObjSpaceY * 2
			button gosub "参照...", *browse_folder
		pos kObjSpace                 , kObjSpace + kObjSpaceY * 4
			chkbox "資源ログ(分)",     auto_supply_flg
		pos kObjSpace + kObjSpaceX    , kObjSpace + kObjSpaceY * 4
			combox logging_index,,"1\n2\n3\n4\n5\n6\n7\n8\n9\n10"
		pos kObjSpace + kObjSpaceX * 2, kObjSpace + kObjSpaceY * 4
			chkbox "更新日時",     show_date_flg
		pos kObjSpace                 , kObjSpace + kObjSpaceY * 5
			combox fps_index,,fps_list
		pos kObjSpace + kObjSpaceX    , kObjSpace + kObjSpaceY * 5
			combox zooming_index,,zooming_list
		pos kObjSpace + kObjSpaceX * 2, kObjSpace + kObjSpaceY * 5
			button gosub "閉じる", *close_option

	//経験値計算機
	screen kExpCalcWindowID ,kObjSpace * 4 + kSmallFontSize * 8 + 0.6 * kObjX * 2, kObjSpace + kObjSpaceY * 6, 4
	gsel kExpCalcWindowID, -1
	title "経験値計算機"
	font msgothic, kSmallFontSize
		pos kObjSpace, kObjSpace + kObjOffset
			mes "現在→目標レベル"
		pos kObjSpace, kObjSpace + kObjSpaceY + kObjOffset
			mes "周回海域"
		pos kObjSpace, kObjSpace + kObjSpaceY * 2 + kObjOffset
			mes "オプション"
		pos kObjSpace, kObjSpace + kObjSpaceY * 3 + kObjOffset
			mes "必要経験値"
		pos kObjSpace, kObjSpace + kObjSpaceY * 4 + kObjOffset
			mes "戦闘経験値"
		pos kObjSpace, kObjSpace + kObjSpaceY * 5 + kObjOffset
			mes "必要周回数"
	objsize 0.6 * kObjX, kObjY
		pos kObjSpace * 2 + kSmallFontSize * 8, kObjSpace
			combox now_level,,level_list
		pos kObjSpace * 3 + kSmallFontSize * 8 + 0.6 * kObjX, kObjSpace
			combox goal_level,,level_list
		pos kObjSpace * 2 + kSmallFontSize * 4, kObjSpace + kObjSpaceY
			combox area_index,,area_list
		pos kObjSpace * 2 + kSmallFontSize * 5, kObjSpace + kObjSpaceY * 2
			chkbox "旗艦", reader_ship_flg
		pos kObjSpace * 3 + kSmallFontSize * 5 + 0.6 * kObjX, kObjSpace + kObjSpaceY * 2
			chkbox "MVP", mvp_flg
		pos kObjSpace * 3 + kSmallFontSize * 5 + kObjX, kObjSpace + kObjSpaceY * 5
			button gosub "閉じる", *close_exp
	objsize kObjX, kObjY
		pos kObjSpace * 2 + kSmallFontSize * 5, kObjSpace + kObjSpaceY * 3
			input need_exp
			objenable 6, 0
		pos kObjSpace * 2 + kSmallFontSize * 5, kObjSpace + kObjSpaceY * 4
			input battle_exp
			objenable 7, 0
		pos kObjSpace * 2 + kSmallFontSize * 5, kObjSpace + kObjSpaceY * 5
			input need_battles
			objenable 8, 0
	objsize 1.2 * kObjX, kObjY
		pos kObjSpace * 3 + kSmallFontSize * 4 + 0.6 * kObjX, kObjSpace + kObjSpaceY
			combox result_index,,"完全勝利S\n勝利S\n勝利A\n戦術的勝利B\n戦術的敗北C\n敗北D\n敗北E"
	gosub *exp_calc

	//○号カウンター
	screen kCountWindowID, kObjSpace * 6 + kSmallFontSize * 2 + 0.8 * kObjX * 4, kObjSpace * 2 + kObjSpaceY * 2 + kCounterY, 4
	gsel kCountWindowID, -1
	title "○号カウンター"
	pos kObjSpace * 2 + kSmallFontSize * 2 + kObjSpaceX, kObjSpace + kObjSpaceY
		mesbox count_result, ginfo_sx - (kObjSpace * 3 + kSmallFontSize * 2 + kObjSpaceX), kCounterY, 0
	font msgothic, kSmallFontSize
		pos kObjSpace, kObjSpace +                  kObjOffset
			mes "あ号"
		pos kObjSpace, kObjSpace + kObjSpaceY     + kObjOffset
			mes "ろ号"
		pos kObjSpace, kObjSpace + kObjSpaceY * 2 + kObjOffset
			mes "い号"
	objsize 0.8 * kObjX, kObjY
		pos kObjSpace * 2 + kSmallFontSize * 2, kObjSpace
			button gosub "出撃",       *count_a_sortie
		pos kObjSpace * 3 + kSmallFontSize * 2 + 0.8 * kObjX,     kObjSpace
			button gosub "ボス到達",   *count_a_to_boss
		pos kObjSpace * 4 + kSmallFontSize * 2 + 0.8 * kObjX * 2, kObjSpace
			button gosub "ボス勝利",   *count_a_win_boss
		pos kObjSpace * 5 + kSmallFontSize * 2 + 0.8 * kObjX * 3, kObjSpace
			button gosub "S勝利",      *count_a_s_win
		pos kObjSpace                      , ginfo_sy - kObjSpaceY
			button gosub "リセット(あ)", *reset_counter_a
		pos kObjSpace * 2 + 0.8 * kObjX    , ginfo_sy - kObjSpaceY
			button gosub "リセット(ろ)", *reset_counter_r
		pos kObjSpace * 3 + 0.8 * kObjX * 2, ginfo_sy - kObjSpaceY
			button gosub "リセット(い)", *reset_counter_i
	objsize kObjX, kObjY
		pos kObjSpace * 2 + kSmallFontSize * 2, kObjSpace + kObjSpaceY
			button gosub "補給艦撃沈", *count_r
		pos kObjSpace * 2 + kSmallFontSize * 2, kObjSpace + kObjSpaceY * 2
			button gosub "空母系撃沈", *count_i
		pos ginfo_sx - kObjSpaceX, ginfo_sy - kObjSpaceY
			button gosub "閉じる", *close_counter
	gosub *redraw_counter

	//各種タイマー
	screen kDockWindowID, kObjSpace + kObjSpaceX * 4, kObjSpace * 2 + kObjSpaceY * 5 + kSmallFontSize, 4
	gsel kDockWindowID, -1
	title "各種時間"
	font msgothic, kSmallFontSize
		pos kObjSpace, kObjSpace
			mes "【入渠時間】"
		pos kObjSpace + kObjSpaceX * 2, kObjSpace
			mes "【建造時間】"
	objsize kObjX, kObjY
		;入渠時間
		pos kObjSpace, kObjSpace + kSmallFontSize
			input dock1_time1
		pos kObjSpace + kObjSpaceX, kObjSpace + kSmallFontSize
			input dock1_time2
		pos kObjSpace, kObjSpace + kObjSpaceY + kSmallFontSize
			input dock2_time1
		pos kObjSpace + kObjSpaceX, kObjSpace + kObjSpaceY + kSmallFontSize
			input dock2_time2
		pos kObjSpace, kObjSpace + kObjSpaceY * 2 + kSmallFontSize
			input dock3_time1
		pos kObjSpace + kObjSpaceX, kObjSpace + kObjSpaceY * 2 + kSmallFontSize
			input dock3_time2
		pos kObjSpace, kObjSpace + kObjSpaceY * 3 + kSmallFontSize
			input dock4_time1
		pos kObjSpace + kObjSpaceX, kObjSpace + kObjSpaceY * 3 + kSmallFontSize
			input dock4_time2
		;建造時間
		pos kObjSpace + kObjSpaceX * 2, kObjSpace + kSmallFontSize
			input bdock1_time1
		pos kObjSpace + kObjSpaceX * 3, kObjSpace + kSmallFontSize
			input bdock1_time2
		pos kObjSpace + kObjSpaceX * 2, kObjSpace + kObjSpaceY + kSmallFontSize
			input bdock2_time1
		pos kObjSpace + kObjSpaceX * 3, kObjSpace + kObjSpaceY + kSmallFontSize
			input bdock2_time2
		pos kObjSpace + kObjSpaceX * 2, kObjSpace + kObjSpaceY * 2 + kSmallFontSize
			input bdock3_time1
		pos kObjSpace + kObjSpaceX * 3, kObjSpace + kObjSpaceY * 2 + kSmallFontSize
			input bdock3_time2
		pos kObjSpace + kObjSpaceX * 2, kObjSpace + kObjSpaceY * 3 + kSmallFontSize
			input bdock4_time1
		pos kObjSpace + kObjSpaceX * 3, kObjSpace + kObjSpaceY * 3 + kSmallFontSize
			input bdock4_time2
		;
		pos kObjSpace, kObjSpace + kObjSpaceY * 4 + kSmallFontSize
			button gosub "更新", *get_dock
		pos kObjSpace + kObjSpaceX, kObjSpace + kObjSpaceY * 4 + kSmallFontSize
			button gosub "閉じる", *close_dock
	repeat 16
		objenable cnt, 0
	loop

	//ソート一覧
	screen kSortListWindowID, kObjSpace * 3 + (kObjX * 2) * 2, kObjSpace * 4 + (kObjY * 10) + kObjY * 2, 4
	gsel kSortListWindowID, -1
	title "ソート一覧"
	objsize 0.6 * kObjX, kObjY
		pos kObjSpace                 , kObjSpace * 2 + (kObjY * 10)
			button gosub "追加",   *add_sort_list
		pos kObjSpace * 2 + 0.6 * kObjX    , kObjSpace * 2 + (kObjY * 10)
			button gosub "↑",     *upper_sort_list
		pos kObjSpace * 3 + 0.6 * kObjX * 2, kObjSpace * 2 + (kObjY * 10)
			button gosub "↓",     *lower_sort_list
		pos kObjSpace * 4 + 0.6 * kObjX * 3, kObjSpace * 2 + (kObjY * 10)
			button gosub "削除",   *del_sort_list
		pos kObjSpace * 5 + 0.6 * kObjX * 4, kObjSpace * 2 + (kObjY * 10)
			button gosub "全削除", *alldel_sort_list
	objsize kObjX, kObjY
		pos kObjSpace                 , kObjSpace * 3 + (kObjY * 10) + kObjY
			combox sort_width_index,,"出力：1列\n出力：2列\n出力：3列\n出力：4列\n出力：5列"
		pos kObjSpace + kObjSpaceX    , kObjSpace * 3 + (kObjY * 10) + kObjY
			button gosub "作成",   *make_sort_list
		pos kObjSpace + kObjSpaceX * 2, kObjSpace * 3 + (kObjY * 10) + kObjY
			button gosub "閉じる", *close_sort_list
	objsize kObjX * 2, kObjY * 10
		pos kObjSpace, kObjSpace
			listbox sort_index, 0, sort_list
				sort_index_id = stat
	sort_index = -1

	//資源グラフ
	screen kSupplyGraphID, kGraphWX, kGraphWY, 4
	gsel kSupplyGraphID, -1
	title "資源グラフ"
	objsize kObjX, kObjY
		pos kGraphWX - kObjSpaceX, kGraphWY - kObjSpaceY - kGraphFontSize * 2
		button gosub "閉じる", *close_graph
		pos kGraphWX - kObjSpaceX * 2, kGraphWY - kObjSpaceY - kGraphFontSize * 2
		button gosub "画像保存", *save_graph
	if(supply_log_size != 0){
		gosub *make_graph
		gosub *plot_graph
	}

	//メイン画面・サブ画面
	//(ウィンドウを隣接して配置したいので表示位置を計算している)
	screen kMainWindowID, kMainWX, kMainWY,,10, 10
	title kSoftName
	kMainWX2 = ginfo(10)	;メイン画面の表示サイズ
	kPutWindowOffset = 10 + kMainWX2 + (kMainWX2 - kMainWX) * 2
	screen kPutWindowID, kFlashWX, kFlashWY + kStatusBarY, 4, kPutWindowOffset, 10
	gsel kPutWindowID, 2
	SetTitle
	gsel kMainWindowID, 2
	;分けるための線
	color
		line 0, kObjSpace     + kObjSpaceY    , kMainWX, kObjSpace     + kObjSpaceY
		line 0, kObjSpace * 2 + kObjSpaceY * 4, kMainWX, kObjSpace * 2 + kObjSpaceY * 4
		line 0, kObjSpace * 3 + kObjSpaceY * 7, kMainWX, kObjSpace * 3 + kObjSpaceY * 7
	;各種オブジェクト
	objsize kObjX, kObjY
		;1段目
		pos kObjSpace             , kObjSpace
			combox manual_getpos_flg,,"自動設定\n手動設定\n自動設定II"
		pos kObjSpace + kObjSpaceX, kObjSpace
			button gosub "座標取得", *get_pos
		;2段目
		pos kObjSpace             , kObjSpace * 2 + kObjSpaceY
			combox mode_index,,mode_list
		pos kObjSpace + kObjSpaceX, kObjSpace * 2 + kObjSpaceY
			button gosub "【画像保存】", *save_picture
		pos kObjSpace             , kObjSpace * 2 + kObjSpaceY * 2
			combox fleets_index,,fleets_list
		pos kObjSpace + kObjSpaceX, kObjSpace * 2 + kObjSpaceY * 2
			combox units_index,,units_list
		pos kObjSpace             , kObjSpace * 2 + kObjSpaceY * 3
			combox commands_index,,commands_list
		pos kObjSpace + kObjSpaceX, kObjSpace * 2 + kObjSpaceY * 3
			button gosub "【○○艦隊】", *save_fleets
		;3段目
		pos kObjSpace             , kObjSpace * 3 + kObjSpaceY * 5
			button gosub "参照...", *browse_bgm
		pos kObjSpace + kObjSpaceX, kObjSpace * 3 + kObjSpaceY * 5
			button gosub "切り替え", *switch_bgm
		pos kObjSpace              , kObjSpace * 3 + kObjSpaceY * 6
			button gosub "強制再生", *start_bgm
		pos kObjSpace + kObjSpaceX, kObjSpace * 3 + kObjSpaceY * 6
			button gosub "強制停止", *stop_bgm
		;4段目
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 7
			button gosub "経験値計算", *calc_exp
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 7
			button gosub "各種タイマー", *dock_timer
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 8
			button gosub "○号カウンター", *count_task
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 8
			button gosub "ソート一覧", *show_sort_list
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 9
			button gosub "資源グラフ", *show_graph
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 9
			button gosub "【資源画像】", *save_stock
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 10
			button gosub "手動セーブ", *save_soft_data
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 11
			button gosub "オプション...", *show_option
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 11
			button gosub "情報...", *about
/*		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 9
			button gosub "【資源画像】", *save_stock
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 9
			button gosub "手動セーブ", *save_soft_data
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 10
			button gosub "オプション...", *show_option
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 10
			button gosub "情報...", *about*/

	objsize kObjSpace + kObjX * 2, kObjY
		pos kObjSpace             , kObjSpace * 3 + kObjSpaceY * 4
			combox bgm_index,,bgm_list
			bgm_index_id = stat

	onexit gosub *exit

// メインループ
	//変化監視用変数初期化
	;経験値計算機
	now_level_       = now_level
	goal_level_      = goal_level
	area_index_      = area_index
	reader_ship_flg_ = reader_ship_flg
	mvp_flg_         = mvp_flg
	result_index_    = result_index
	;BGM
	bgm_type_ = -1
	now_bgm = -1
	;ソート一覧
	sort_index_ = sort_index
	;資源グラフ
	mouse_button_flg = FALSE
	;最終更新日時
	show_date_flg_ = show_date_flg
	//ループしつつ監視
	repeat
		if(exit_flg) :end
		SetTitle
		// Flash画面を自動取得
		if(other_get_pos_flg == FALSE){
			;ディスプレイ全体からBitBltするタイプ
			GetFlashWindow kFlashBufferID, flash_px, flash_py
		}else{
			;ブラウザからBitBltするタイプ
			GetFlashWindow2 handle, kFlashBufferID, flash_px, flash_py
		}
		// 結果を判定し、自動で格納する
		screen_shot_type = JudgeSituation(kFlashBufferID)
		if(screen_shot_type != kTypeUnknown){
			gsel kCaptureBufferID + screen_shot_type - 1
			gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
			if(screen_shot_type <= kSceneListSize){
				;戦闘画面(昼戦画面と夜戦画面と夜戦マス)ならば再度コピーする
				if((mode_list3(screen_shot_type) == "昼戦画面") || (mode_list3(screen_shot_type) == "夜戦画面") || (mode_list3(screen_shot_type) == "夜戦マス")){
					gsel kBattleBufferID
					gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
				}
			}
		}
		//艦隊における艦娘数を認識し、減少した場合はバッファを初期化する
		if(screen_shot_type >= kSceneListSize + 1){
			GetUnits kFlashBufferID, screen_shot_type, unit_count
			for i, 0, kFleetNum
				if(unit_count_(i) != unit_count(i)){
					if(unit_count_(i) > unit_count(i)){
						for j, unit_count(i), unit_count_(i)
							gsel kUnitIdOffset + i * kUnitNum + j
							color 255, 255, 255 :boxf
						next
					}
					unit_count_(i) = unit_count(i)
				}
			next
		}
		// アプリの状態に合わせ表示を変更する
		//サブ画面のサイズを変更する
		if((zooming_index_ != zooming_index) || (show_date_flg_ != show_date_flg)){
			screen kPutWindowID, zooming_num(zooming_index) * kFlashWX / 100, zooming_num(zooming_index) * kFlashWY / 100 + kStatusBarY * show_date_flg, 4
			gsel kPutWindowID, 2
			zooming_index_ = zooming_index
			show_date_flg_ = show_date_flg
		}
		//サブ画面用バッファに画像を転送する
		gsel kPutTempWindowID
		if(mode_index == kTypeNow){
			//現在状況
			gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
		}else{
			//それ以外
			if(mode_index == kSceneListSize + 1){
				;編成画面
				gcopy kFleetIdOffset + fleets_index, 0, 0, kFlashWX, kFlashWY
			}else{if(mode_index == kSceneListSize + 2){
				;改装画面
				gcopy kUnitIdOffset + units_index, 0, 0, kFlashWX, kFlashWY
			}else{if(mode_index == kSceneListSize + 3){
				;戦闘画面(特殊)
				gcopy kBattleBufferID, 0, 0, kFlashWX, kFlashWY
			}else{
				;その他
				gcopy kCaptureBufferID + mode_index - 1, 0, 0, kFlashWX, kFlashWY
			}}}
		}
		//サブ画面のバッファに名前隠し処理を行う
		if(name_disable_flg){
			if(CheckHomeFlg(kPutTempWindowID)){	;要するに左上の歯車のすぐ右
				color :boxf 111, 0, 273, 25
			}
			screen_shot_type2 = JudgeSituation(kPutTempWindowID)
			if(screen_shot_type2 < kSceneListSize){
				if(mode_list3(screen_shot_type2) == "戦績表示")   :color :boxf 201, 123, 496, 153
				if(mode_list3(screen_shot_type2) == "ランキング") :color :boxf 225, 153, 375, 451
				if(mode_list3(screen_shot_type2) == "交戦結果")   :color :boxf  92,  82, 264, 106
				if(mode_list3(screen_shot_type2) == "戦果報告")   :color :boxf  56,  82, 228, 106
				if(mode_list3(screen_shot_type2) == "演習一覧"){
					color
					boxf 338, 178, 503, 192
					boxf 338, 233, 503, 247
					boxf 338, 288, 503, 302
					boxf 338, 343, 503, 357
					boxf 338, 398, 503, 412
				}
				if(mode_list3(screen_shot_type2) == "演習個別") :color :boxf 130,  87, 425, 117
			}
		}
		// サブ画面にサブ画面用バッファの画像を変倍して転送する
		PutWindowSet kPutWindowID, kPutTempWindowID
		//大破チェッカー機能
		;dead_zone_flg_に関する処理
		if(screen_shot_type <= kSceneListSize){
			if(CheckDeadZone(kFlashBufferID, screen_shot_type)){
				if((mode_list3(screen_shot_type) == "出撃画面") || (mode_list3(screen_shot_type) == "戦果報告")){
					dead_zone_flg_ = TRUE
				}
			}
			if(screen_shot_type != kTypeUnknown){
				if((mode_list3(screen_shot_type) != "出撃画面") && (mode_list3(screen_shot_type) != "戦果報告")){
					dead_zone_flg_ = FALSE
				}
			}
		}
		;dead_zone_flg__に関する処理
		if(dead_zone_flg__ == FALSE){
			if(dead_zone_flg){
				if(dead_zone_flg_){
					if(CheckSelect(kFlashBufferID)){
						//大破進撃阻止用画面
						bgscr kDeadZoneWindowID, 180, 130, , flash_px + 200, flash_py + 180
						gsel kDeadZoneWindowID, 2
						color 255, 0, 0
						font msgothic, 36
						pos 10, 10
						mes "大破した\n 艦娘が\nいます！"
						dead_zone_flg__ = TRUE
					}
					if(CheckSelect2(kFlashBufferID)){
						//大破出撃阻止用画面
						bgscr kDeadZoneWindowID, 180, 50, , flash_px + 540, flash_py + 420
						gsel kDeadZoneWindowID, 2
						color 255, 0, 0
						font msgothic, 32
						pos 10, 10
						mes "大破艦あり"
						dead_zone_flg__ = TRUE
					}
				}
			}
		}else{
			;座標がズレた場合に再表示する処理
			if(get_pos_flg2){
				if(dead_zone_flg){
					if(dead_zone_flg_){
						if(CheckSelect(kFlashBufferID)){
							//大破進撃阻止用画面
							bgscr kDeadZoneWindowID, 180, 130, , flash_px + 200, flash_py + 180
							gsel kDeadZoneWindowID, 2
							color 255, 0, 0
							font msgothic, 36
							pos 10, 10
							mes "大破した\n 艦娘が\nいます！"
							dead_zone_flg__ = TRUE
						}
						if(CheckSelect2(kFlashBufferID)){
							//大破出撃阻止用画面
							bgscr kDeadZoneWindowID, 180, 50, , flash_px + 540, flash_py + 420
							gsel kDeadZoneWindowID, 2
							color 255, 0, 0
							font msgothic, 32
							pos 10, 10
							mes "大破艦あり"
							dead_zone_flg__ = TRUE
						}
					}
				}
			}
			;白い枠を非表示にする処理
			if(dead_zone_flg == FALSE)  :gsel kDeadZoneWindowID, -1 :dead_zone_flg__ = FALSE
			if(dead_zone_flg_ == FALSE) :gsel kDeadZoneWindowID, -1 :dead_zone_flg__ = FALSE
		}
		//経験値計算機
		if(now_level_       != now_level)       :gosub *exp_calc :now_level_       = now_level
		if(goal_level_      != goal_level)      :gosub *exp_calc :goal_level_      = goal_level
		if(area_index_      != area_index)      :gosub *exp_calc :area_index_      = area_index
		if(reader_ship_flg_ != reader_ship_flg) :gosub *exp_calc :reader_ship_flg_ = reader_ship_flg
		if(mvp_flg_         != mvp_flg)         :gosub *exp_calc :mvp_flg_         = mvp_flg
		if(result_index_    != result_index)    :gosub *exp_calc :result_index_    = result_index
		//入渠タイマー
		if(dock_time != gettime(6)){
			gsel kDockWindowID
			gosub *increment_dock
			gosub *redraw_dock
			dock_time = gettime(6)
		}
		//BGM機能
		;現在の状況を診断
		bgm_type = -1
		if(CheckHomeFlg(kFlashBufferID)) :bgm_type = 0
		if(screen_shot_type <= kSceneListSize){
			if(mode_list3(screen_shot_type) == "マップ画面") :bgm_type = 1
			if(mode_list3(screen_shot_type) == "昼戦画面")   :bgm_type = 2
			if(mode_list3(screen_shot_type) == "夜戦画面")   :bgm_type = 2
			if(mode_list3(screen_shot_type) == "夜戦マス")   :bgm_type = 2
			if(mode_list3(screen_shot_type) == "交戦結果")   :bgm_type = 3
			if(mode_list3(screen_shot_type) == "戦果報告")   :bgm_type = 3
		}
		;現在の状況が変化した際、BGMを再生/停止する
		if((bgm_type_ != bgm_type) && (bgm_type != -1)){
			if(bgm_type >= kBgmListSize){
				mmstop
			}else{
				if(bgm_list_flg(bgm_type)){
					mmplay bgm_type
					now_bgm = bgm_type
				}else{
					mmstop
				}
			}
			bgm_type_ = bgm_type
		}
		//自動ズレ補正
		get_pos_flg2 = FALSE
		switch manual_getpos_flg
			case 0
				;自動設定
				if(get_pos_flg){						;一回以上座標補正を利用した場合のみ発動
					if(auto_set_time != gettime(6)){	;1秒毎にズレ判定を行う
						if(auto_set_flg){				;ズレ補正にチェックが入っていた場合のみ発動
							if(CheckAutoSet()){			;ズレが存在する場合のみ発動
								gosub *get_pos
							}
						}
						auto_set_time = gettime(6)
					}
				}
				swbreak
			case 1
				;手動設定
				if(get_pos_flg){						;一回以上座標補正を利用した場合のみ発動
					diff = gettime(6) - auto_set_time
					if(diff < 0) :diff += 60
					if(diff >= 5){	;5秒毎にズレ判定を行う
						if(auto_set_flg){				;ズレ補正にチェックが入っていた場合のみ発動
							if(CheckAutoSet()){			;ズレが存在する場合のみ発動
								gosub *get_pos
							}
						}
						auto_set_time = gettime(6)
					}
				}
				swbreak
			case 2
				if(other_get_pos_flg == FALSE) :swbreak
				if(get_pos_flg){						;一回以上座標補正を利用した場合のみ発動
					if(auto_set_time != gettime(6)){	;1秒毎にズレ判定を行う
						if(auto_set_flg){				;ズレ補正にチェックが入っていた場合のみ発動
							if(CheckAutoSet()){			;ズレが存在する場合のみ発動
								get_handle_flg = FALSE
								gosub *get_pos
								get_handle_flg = TRUE
							}else{
								;大破チェック用に、ズレ検出機構を新たに設ける
								dim rect_, 4
								GetClientSize handle, rect_
								if((rect_(0) != rect(0)) || (rect_(1) != rect(1))){
									flash_px += rect_(0) - rect(0)
									flash_py += rect_(1) - rect(1)
									for k, 0, 4
										rect(k) = rect_(k)
									next
									get_pos_flg2 = TRUE
								}
							}
						}
						auto_set_time = gettime(6)
					}
				}
				swbreak
		swend
		//ソート一覧
		if(sort_index_ != sort_index) :gosub *redraw_sort_preview :sort_index_ = sort_index
		//ステータスバーに最終更新日時を表示する
		;記録処理
		if(screen_shot_type == kTypeUnknown){
		}else{
			SetLastUpdate screen_shot_type - 1
			if(screen_shot_type <= kSceneListSize){
				if((mode_list3(screen_shot_type) == "昼戦画面") || (mode_list3(screen_shot_type) == "夜戦画面") || (mode_list3(screen_shot_type) == "夜戦マス")){
					for k, 0, 7
						last_up_date(kSceneListSize@ + kFleetNum + kFleetNum * kUnitNum, k) = last_up_date(screen_shot_type - 1, k)
					next
				}
			}
		}
		;表示処理
		gsel kPutWindowID
		redraw 0
			color 255, 255, 255 :boxf 0, zooming_num(zooming_index) * kFlashWY / 100, zooming_num(zooming_index) * kFlashWX / 100, zooming_num(zooming_index) * kFlashWY / 100 + kStatusBarY
			color
			pos kStatusBarOffset, zooming_num(zooming_index) * kFlashWY / 100 + kStatusBarOffset
			font msgothic, kStatusBarFontSize
			if(mode_index == kTypeNow){
				;現在画面
				mes "" + strf("%04d-%02d-%02d %02d-%02d-%02d.%03d", gettime(0), gettime(1), gettime(3), gettime(4), gettime(5), gettime(6), gettime(7))
			}else{if(mode_index == kSceneListSize + 1){
				;編成画面
				mes GetLastUpdate(kSceneListSize + fleets_index)
			}else{if(mode_index == kSceneListSize + 2){
				;改装画面
				mes GetLastUpdate(kSceneListSize + kFleetNum + units_index)
			}else{if(mode_index == kSceneListSize + 3){
				;戦闘画面
				mes GetLastUpdate(kSceneListSize + kFleetNum + kFleetNum * kUnitNum)
			}else{
				;その他
				mes GetLastUpdate(mode_index - 1)
			}}}}
			;大破チェック機能でのチェック結果も表示
			if(dead_zone_flg_){
				pos kStatusBarOffset + kStatusBarFontSize * 12, zooming_num(zooming_index) * kFlashWY / 100 + kStatusBarOffset
				color 255, 0, 0
				mes "※大破艦あり※"
			}else{
				;大破艦がいない場合は艦隊毎の艦娘数を表示
				pos kStatusBarOffset + kStatusBarFontSize * 12, zooming_num(zooming_index) * kFlashWY / 100 + kStatusBarOffset
				color 0, 0, 0
				mes "[" + unit_count(0) + "," + unit_count(1) + "," + unit_count(2) + "," + unit_count(3) + "]"
			}
		redraw 1
		// 資源ログ機能
		if(auto_supply_flg){
			if(CheckHomeFlg(kFlashBufferID)){
				if((supply_last_time == -1) || (timeGetTime() - supply_last_time > 1000 * 60 * (logging_index + 1))){
					supply_last_time = timeGetTime()
					GetSupply kFlashBufferID, supply_list
					supply_log += NowTime() + "," + supply_list(0) + "," + supply_list(1) + "," + supply_list(2) + "," + supply_list(3) + "\n"
					notesel supply_log :notesave "supply.csv"
					supply_log_size = LoadLog(supply_log, supply_log_int)
					gosub *make_graph
					gosub *plot_graph
					gsel kMainWindowID
				}
			}
		}
		// 資源グラフをスクロールする
		if(ginfo_act == kSupplyGraphID){
			// キー操作を検知する
			stick ky, 1 + 2 + 4 + 8, 1
			;左右キーで2時間毎のスクロール
			if(ky & 1) :plot_graph_px -= kGraphStepX :gosub *plot_graph
			if(ky & 4) :plot_graph_px += kGraphStepX :gosub *plot_graph
			;上下キーで1日毎のスクロール
			if(ky & 2) :plot_graph_px -= kGraphWX :gosub *plot_graph
			if(ky & 8) :plot_graph_px += kGraphWX :gosub *plot_graph
		}
		// ウェイト
		await 1000 / fps_num(fps_index)
	loop

//終了確認
*exit
	dialog "終了しますか？", 2, kSoftName
	if(stat == 6){
		if(auto_save_flg) :WriteSaveData
		exit_flg = TRUE
	}
return
