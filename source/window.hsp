/* サブルーチン(画面周り) */
goto *main2

// 座標取得
*get_pos
	switch manual_getpos_flg
		case 0
			// 座標を自動で取得する
			//デスクトップを撮影する
			GetDesktopWindow kDeskBufferID
			//撮影した画像から座標を検索する
			GetPosFlashSquare kDeskBufferID, kFlashBufferID, flash_px, flash_py
			SetTitle
			get_pos_flg = TRUE
			other_get_pos_flg = FALSE
			get_pos_flg2 = TRUE
			swbreak
		case 1
			// 座標を手動で取得する
			//デスクトップを撮影する
			GetDesktopWindow kDeskBufferID
			//手動で枠を選択させる
			;初期設定
			bgscr kSelectWindowID, kDispX, kDispY, , kOffsetX, kOffsetY
			gsel kSelectWindowID, 2
			font msgothic, kLargeFontSize
			;画面表示
			gcopy kDeskBufferID, 0, 0, kDispX, kDispY
			color :mes "枠を選択して下さい。(Escで終了)"
			;選択操作
			is_mouse_button = FALSE
			is_mouse_select = FALSE
			mouse_pos_x1 = 0 :mouse_pos_y1 = 0
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey) :break
				if(key & kStickMouse){
					if(is_mouse_button){
						// 選択中
						redraw 0
							pos 0, 0
							gcopy kDeskBufferID, 0, 0, kDispX, kDispY
							color :mes "枠を選択して下さい。(Escで終了)"
							DrawMouseSquare mousex, mousey, mouse_pos_x1, mouse_pos_y1
						redraw 1
					}else{
						// 選択開始
						mouse_pos_x1 = mousex
						mouse_pos_y1 = mousey
						is_mouse_button = TRUE
					}
				}else{
					if(is_mouse_button){
						// 選択終了
						mouse_pos_x2 = mousex
						mouse_pos_y2 = mousey
						if(mouse_pos_x1 < mouse_pos_x2){
							square_x = mouse_pos_x1
							square_xsize = mouse_pos_x2 - mouse_pos_x1 + 1
						}else{
							square_x = mouse_pos_x2
							square_xsize = mouse_pos_x1 - mouse_pos_x2 + 1
						}
						if(mouse_pos_y1 < mouse_pos_y2){
							square_y = mouse_pos_y1
							square_ysize = mouse_pos_y2 - mouse_pos_y1 + 1
						}else{
							square_y = mouse_pos_y2
							square_ysize = mouse_pos_y1 - mouse_pos_y2 + 1
						}
						is_mouse_button = FALSE
						is_mouse_select = TRUE
						break
					}else{
						// 何もしていない
					}
				}
				wait 5
			loop
			;選択結果から検索を行う
			gsel kSelectWindowID, -1
			if(is_mouse_select){
				buffer kTempBufferID, square_xsize, square_ysize
				gcopy kDeskBufferID, square_x, square_y, square_xsize, square_ysize
				if((square_xsize < kFlashWX) || (square_ysize < kFlashWY)){
				}else{
					GetPosFlashSquare kTempBufferID, kFlashBufferID, flash_px, flash_py
					flash_px += square_x :flash_py += square_y
					SetTitle
					get_pos_flg = TRUE
					other_get_pos_flg = FALSE
					get_pos_flg2 = TRUE
				}
			}
			swbreak
		case 2
			// 座標を自動で取得する(ウィンドウ相手にBitBltするVer)
			//艦これを開いているブラウザを撮影する
			if(get_handle_flg){
				handle = GetKanColleHandle()
				if(handle == 0) :dialog "ハンドルを取得できませんでした", 0, kSoftName :swbreak
			}
			dim rect, 4
			GetClientSize handle, rect
			wx = rect(2) - rect(0) :wy = rect(3) - rect(1)
			if((wx < kFlashWX) || (wy < kFlashWY)) :dialog "画面サイズを取得できませんでした", 0, kSoftName :swbreak
			GetKanColleWindow handle, kDeskBufferID, wx, wy
			//撮影した画像から座標を検索する
			GetPosFlashSquare kDeskBufferID, kFlashBufferID, flash_px, flash_py
			flash_px += rect(0) :flash_py += rect(1)
			SetTitle
			get_pos_flg = TRUE
			other_get_pos_flg = TRUE
			get_pos_flg2 = TRUE
			swbreak
	swend
return

//画像保存
*save_picture
	//画面クロップにチェックが入っているかで対応が変わる
	screen_shot_type2 = JudgeSituation(kPutTempWindowID, 0)
	if((cap_crop_flg) && (screen_shot_type2 >= kSceneListSize)){
		//クロップして保存
		if(screen_shot_type2 >= kSceneListSize + kFleetNum){
			//改装画面
			buffer kTempBufferID, kUnitWX, kUnitWY
			gcopy kPutTempWindowID, kUnitPX, kUnitPY, kUnitWX, kUnitWY
		}else{
			//編成画面
			buffer kTempBufferID, kFleetWX, kFleetWY
			gcopy kPutTempWindowID, kFleetPX, kFleetPY, kFleetWX, kFleetWY
		}
	}else{
		//通常保存
		gsel kPutTempWindowID
	}
	if(denoise_flg) :Denoise
	cvbuffer kCaptureBufferID, ginfo_sx, ginfo_sy
	cvputimg kCaptureBufferID
	if(mode_index == kTypeNow){
		;現在画面
		cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCaptureBufferID
	}else{if(mode_index == kSceneListSize + 1){
		;編成画面
		cvsave pic_save_path(my_folder_flg) + "\\" + GetLastUpdate(kSceneListSize + fleets_index) + ".png", kCaptureBufferID
	}else{if(mode_index == kSceneListSize + 2){
		;改装画面
		cvsave pic_save_path(my_folder_flg) + "\\" + GetLastUpdate(kSceneListSize + kFleetNum + units_index) + ".png", kCaptureBufferID
	}else{if(mode_index == kSceneListSize + 3){
		;戦闘画面
		cvsave pic_save_path(my_folder_flg) + "\\" + GetLastUpdate(kSceneListSize + kFleetNum + kFleetNum * kUnitNum) + ".png", kCaptureBufferID
	}else{
		;その他
		cvsave pic_save_path(my_folder_flg) + "\\" + GetLastUpdate(mode_index - 1) + ".png", kCaptureBufferID
	}}}}
	gsel kMainWindowID
return

//艦隊画像保存
*save_fleets
	if(commands_index < kFleetNum){
		// 第1〜第4艦隊
		buffer kTempBufferID, kUnitWX * 3, kUnitWY * 2
		for y, 0, 2
			for x, 0, 3
				pos x * kUnitWX, y * kUnitWY
				gcopy kUnitIdOffset + commands_index * kUnitNum + (y * 3 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
			next
		next
		cvbuffer kCaptureBufferID, kUnitWX * 3, kUnitWY * 2
		cvputimg kCaptureBufferID
		cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCaptureBufferID
	}else{
		// 連合・支援艦隊
		buffer kTempBufferID, kUnitWX * 4, kUnitWY * 3
		for z, 0, 2
			for y, 0, 3
				for x, 0, 2
					pos (z * 2 + x) * kUnitWX, y * kUnitWY
					gcopy kUnitIdOffset + (commands_index - kFleetNum) * (kUnitNum * 2) + (z * 6 + y * 2 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
				next
			next
		next
		cvbuffer kCVTempBufferID, kUnitWX * 4, kUnitWY * 3
		cvputimg kCVTempBufferID
		cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCVTempBufferID
		gsel kMainWindowID
	}
	gsel kMainWindowID
return

//BGM参照
*browse_bgm
	dialog "wav;*.mp3;*.wma", 16, "音楽ファイル"
	if(stat){
		bgm_list_filename(bgm_index) = refstr
		mmload refstr, bgm_index, 1
		bgm_list_flg(bgm_index) = TRUE
		if(bgm_index == bgm_type) :mmplay bgm_index :now_bgm = bgm_index
		gosub *init_bgm_list
		gsel kMainWindowID
		objprm bgm_index_id, bgm_list
		objprm bgm_index_id, bgm_index
	}
return
//BGM切り替え
*switch_bgm
	if(bgm_list_flg(bgm_index)){
		bgm_list_flg(bgm_index) = FALSE
		if(bgm_index == bgm_type) :mmstop
	}else{
		exist bgm_list_filename(bgm_index)
		if(strsize != -1){
			bgm_list_flg(bgm_index) = TRUE
			if(bgm_index == bgm_type) :mmplay bgm_index :now_bgm = bgm_index
		}
	}
	gosub *init_bgm_list
	gsel kMainWindowID
	objprm bgm_index_id, bgm_list
	objprm bgm_index_id, bgm_index
return
//BGM再生
*start_bgm
	if((bgm_type >= 0) && (bgm_type < kBgmListSize)){
		if(bgm_list_flg(bgm_type)){
			mmplay bgm_type
			now_bgm = bgm_type
			bgm_type_ = bgm_type
		}
	}
return
//BGM停止
*stop_bgm
	mmstop
return

//経験値計算機を閉じる
*close_exp
	gsel kExpCalcWindowID, -1
return
//経験値の計算
*exp_calc
	now_id = ginfo_sel
	gsel kExpCalcWindowID
	;レベルの矛盾を修正
	if(now_level > goal_level){
		if(now_level != now_level_){
			goal_level = now_level
			objprm 1, goal_level
		}
		if(goal_level != goal_level_){
			now_level = goal_level
			objprm 0, now_level
		}
	}
	;必要経験値を計算
	now_exp = need_exp_table(now_level)
	goal_exp = need_exp_table(goal_level)
	diff_exp = goal_exp - now_exp
	objprm 6, diff_exp
	;戦闘経験値を計算
	battle_exp = 1.0 * exp_data(area_index)
	if(reader_ship_flg) :battle_exp *= 1.5
	if(mvp_flg) :battle_exp *= 2.0
	switch result_index
		case 0	;完全勝利S
			battle_exp *= 1.2
			swbreak
		case 1	;勝利S
			battle_exp *= 1.2
			swbreak
		case 2	;勝利A
			battle_exp *= 1.0
			swbreak
		case 3	;戦術的勝利B
			battle_exp *= 1.0
			swbreak
		case 4	;戦術的敗北C
			battle_exp *= 0.8
			swbreak
		case 5	;敗北D
			battle_exp *= 0.7
			swbreak
		case 6	;敗北E
			battle_exp *= 0.5
			if(mvp_flg) :battle_exp *= 0.5	;MVP無効
	swend
	battle_exp = int(battle_exp)
	objprm 7, battle_exp
	;必要周回数を計算
	if(need_exp \ battle_exp == 0){
		need_battles = need_exp / battle_exp
	}else{
		need_battles = need_exp / battle_exp + 1
	}
	objprm 8, need_battles
	gsel now_id
return
//経験値計算機を出す
*calc_exp
	gsel kExpCalcWindowID, 2
return

//カウンターリセット
*reset_counter_a
	a_sortie_count = 0			;あ号出撃
	a_to_boss_count = 0			;あ号ボス到達
	a_win_boss_count = 0		;あ号ボス勝利
	a_s_win_count = 0			;あ号S勝利
	gosub *redraw_counter
return
*reset_counter_r
	r_count = 0					;ろ号
	gosub *redraw_counter
return
*reset_counter_i
	i_count = 0					;い号
	gosub *redraw_counter
return
//カウンターを閉じる
*close_counter
	gsel kCountWindowID, -1
return
//カウンターを出す
*count_task
	gsel kCountWindowID, 2
return
//カウントする
*count_a_sortie :a_sortie_count++ :gosub *redraw_counter :return
*count_a_to_boss :a_to_boss_count++ :gosub *redraw_counter :return
*count_a_win_boss :a_win_boss_count++ :gosub *redraw_counter :return
*count_a_s_win :a_s_win_count++ :gosub *redraw_counter :return
*count_r :r_count++ :gosub *redraw_counter :return
*count_i :i_count++ :gosub *redraw_counter :return
//カウンター再描画
*redraw_counter
	count_result = ""
	;あ号
	count_result += "あ号：" + a_sortie_count + "回/" + a_to_boss_count + "回/" + a_win_boss_count + "回/" + a_s_win_count + "回("
	if((a_sortie_count >= 36) && (a_to_boss_count >= 24) && (a_win_boss_count >= 12) && (a_s_win_count >= 6)){
		count_result += "達成)\n"
	}else{
		count_result += "未達成)\n"
	}
	;ろ号
	count_result += "ろ号：" + r_count + "回("
	if(r_count >= 50) :count_result += "達成)\n" :else :count_result += "未達成)\n"
	;い号
	count_result += "い号：" + i_count + "回("
	if(i_count >= 20) :count_result += "達成)\n" :else :count_result += "未達成)\n"
	id = ginfo_sel
	gsel kCountWindowID
	objprm 0, count_result
	gsel id
return

//タイマーを出す
*dock_timer
	gsel kDockWindowID, 2
return
//タイマーを閉じる
*close_dock
	gsel kDockWindowID, -1
return
//時間を取得
*get_dock
	if(mode_list3(screen_shot_type) == "入渠画面"){
		buffer kTempBufferID, 11, 16
		dim number, 6
		for i, 0, kDocks
			gsel kFlashBufferID
			dock_hour(i) = 0
			dock_minute(i) = 0
			dock_second(i) = 0
			if(NearColor(480, ypos(i), 33, 174, 178)){	//ドックに艦娘がいるかを判定
				for j, 0, 6
					gsel kTempBufferID
					gcopy kFlashBufferID, xpos(j), ypos(i) + 25, 11, 16
					number(j) = limit(MatchNumber(170, FALSE), 0, 9)
					if(j == 0) :number(j) = limit(number(j), 0, 5)
					if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
				next
				dock_hour(i)   = number(0) * 10 + number(1)
				dock_minute(i) = number(2) * 10 + number(3)
				dock_second(i) = number(4) * 10 + number(5)
			}
			gsel kDockWindowID
			gosub *redraw_dock
		next
	}
	if(mode_list3(screen_shot_type) == "工廠画面"){
		buffer kTempBufferID, 11, 16
		dim number, 6
		for i, 0, kDocks
			gsel kFlashBufferID
			bdock_hour(i) = 0
			bdock_minute(i) = 0
			bdock_second(i) = 0
			if(NearColor(730, bypos(i), 204, 128, 73)){	//ドックに艦娘がいるかを判定
				for j, 0, 6
					gsel kTempBufferID
					gcopy kFlashBufferID, bxpos(j), bypos(i), 11, 16
					number(j) = limit(MatchNumber(170, FALSE), 0, 9)
					if(j == 0) :number(j) = limit(number(j), 0, 5)
					if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
				next
				bdock_hour(i)   = number(0) * 10 + number(1)
				bdock_minute(i) = number(2) * 10 + number(3)
				bdock_second(i) = number(4) * 10 + number(5)
			}
			gsel kDockWindowID
			gosub *redraw_dock
		next
	}
return
*get_dock_e2
	//遠征時間の計測は地味に面倒臭い……
	;まず遠征の画面かを判定
	if(NearColor(509,113,252,180,88) && NearColor(286,139,54,70,44)){
		;次に、時間が表示されているかを判定
		if(NearColor(667,445,188,188,188) || NearColor(667,445,255,241,231)){
			;そして、第何艦隊が対象かを判定
			;「旗左下から1つ上」基準で、上から
			;x=517, y=180, 210, 240, ..., 390(約R76 G168 B168)
			for k, 0, 8
				if(NearColor(517,180 + k * 30,76,168,168)){
					;(517,180+k*30)を基準とした場合、、
					;(+8,0)が第2→R224 G230 B227、第3→R47  G164 B165、第4→R237 G229 B217
					;(+6,0)が第2→R84  G176 B174、第3→R236 G228 B215、第4→R239 G231 B219
					;として判別可能
					if(NearColor(525,180 + k * 30,224,230,227) && NearColor(523,180 + k * 30, 84,176,174)){
						buffer kTempBufferID, 9, 13
						dim number, 6
						gsel kFlashBufferID
						i = 0
						edock_hour(i) = 0
						edock_minute(i) = 0
						edock_second(i) = 0
						for j, 0, 6
							gsel kTempBufferID
							gcopy kFlashBufferID, expos(j), 387, 9, 13
							number(j) = limit(MatchNumber(190, FALSE), 0, 9)
							if(j == 0) :number(j) = limit(number(j), 0, 5)
							if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
						next
						edock_hour(i)   = number(0) * 10 + number(1)
						edock_minute(i) = number(2) * 10 + number(3)
						edock_second(i) = number(4) * 10 + number(5)
						gsel kDockWindowID
						gosub *redraw_dock
						_break
					}
				}
			next
		}
	}
return
*get_dock_e3
	;まず遠征の画面かを判定
	if(NearColor(509,113,252,180,88) && NearColor(286,139,54,70,44)){
		;次に、時間が表示されているかを判定
		if(NearColor(667,445,188,188,188) || NearColor(667,445,255,241,231)){
			;そして、第何艦隊が対象かを判定
			;「旗左下から1つ上」基準で、上から
			;x=517, y=180, 210, 240, ..., 390(約R76 G168 B168)
			for k, 0, 8
				if(NearColor(517,180 + k * 30,76,168,168)){
					if(NearColor(525,180 + k * 30, 47,164,165) && NearColor(523,180 + k * 30,236,228,215)){
						buffer kTempBufferID, 9, 13
						dim number, 6
						gsel kFlashBufferID
						i = 1
						edock_hour(i) = 0
						edock_minute(i) = 0
						edock_second(i) = 0
						for j, 0, 6
							gsel kTempBufferID
							gcopy kFlashBufferID, expos(j), 387, 9, 13
							number(j) = limit(MatchNumber(190, FALSE), 0, 9)
							if(j == 0) :number(j) = limit(number(j), 0, 5)
							if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
						next
						edock_hour(i)   = number(0) * 10 + number(1)
						edock_minute(i) = number(2) * 10 + number(3)
						edock_second(i) = number(4) * 10 + number(5)
						gsel kDockWindowID
						gosub *redraw_dock
					}
				}
			next
		}
	}
return
*get_dock_e4
	;まず遠征の画面かを判定
	if(NearColor(509,113,252,180,88) && NearColor(286,139,54,70,44)){
		;次に、時間が表示されているかを判定
		if(NearColor(667,445,188,188,188) || NearColor(667,445,255,241,231)){
			;そして、第何艦隊が対象かを判定
			for k, 0, 8
				if(NearColor(517,180 + k * 30,76,168,168)){
					if(NearColor(525,180 + k * 30,237,229,217) && NearColor(523,180 + k * 30,239,231,219)){
						buffer kTempBufferID, 9, 13
						dim number, 6
						gsel kFlashBufferID
						i = 2
						edock_hour(i) = 0
						edock_minute(i) = 0
						edock_second(i) = 0
						for j, 0, 6
							gsel kTempBufferID
							gcopy kFlashBufferID, expos(j), 387, 9, 13
							number(j) = limit(MatchNumber(190, FALSE), 0, 9)
							if(j == 0) :number(j) = limit(number(j), 0, 5)
							if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
						next
						edock_hour(i)   = number(0) * 10 + number(1)
						edock_minute(i) = number(2) * 10 + number(3)
						edock_second(i) = number(4) * 10 + number(5)
						gsel kDockWindowID
						gosub *redraw_dock
					}
				}
			next
		}
	}
return
//インクリメント
*increment_dock
	for k, 0, kDocks
		if((dock_hour(k) != 0) || (dock_minute(k) != 0) || (dock_second(k) != 0)){
			dock_second(k)--
			if(dock_second(k) < 0){
				dock_second(k) += 60
				dock_minute(k)--
				if(dock_minute(k) < 0){
					dock_minute(k) += 60
					dock_hour(k) --
				}
			}
		}
		if((bdock_hour(k) != 0) || (bdock_minute(k) != 0) || (bdock_second(k) != 0)){
			bdock_second(k)--
			if(bdock_second(k) < 0){
				bdock_second(k) += 60
				bdock_minute(k)--
				if(bdock_minute(k) < 0){
					bdock_minute(k) += 60
					bdock_hour(k) --
				}
			}
		}
	next
	for k, 0, kDocks - 1
		if((edock_hour(k) != 0) || (edock_minute(k) != 0) || (edock_second(k) != 0)){
			edock_second(k)--
			if(edock_second(k) < 0){
				edock_second(k) += 60
				edock_minute(k)--
				if(edock_minute(k) < 0){
					edock_minute(k) += 60
					edock_hour(k) --
				}
			}
		}
	next
return
//再描画
*redraw_dock
	for k, 0, kDocks
		objprm k * 2, strf("%02d:%02d:%02d", dock_hour(k), dock_minute(k), dock_second(k))
		if((dock_hour(k) != 0) || (dock_minute(k) != 0) || (dock_second(k) != 0)){
			now_hour   = gettime(4) + dock_hour(k)
			now_minute = gettime(5) + dock_minute(k)
			now_second = gettime(6) + dock_second(k)
			if(now_second >= 60) :now_minute += now_second / 60 :now_second \= 60
			if(now_minute >= 60) :now_hour += now_minute / 60 :now_minute \= 60
			objprm k * 2 + 1, strf("%02d:%02d:%02d", now_hour, now_minute, now_second)
		}else{
			objprm k * 2 + 1, ""
		}
		objprm k * 2 + 8, strf("%02d:%02d:%02d", bdock_hour(k), bdock_minute(k), bdock_second(k))
		if((bdock_hour(k) != 0) || (bdock_minute(k) != 0) || (bdock_second(k) != 0)){
			now_hour   = gettime(4) + bdock_hour(k)
			now_minute = gettime(5) + bdock_minute(k)
			now_second = gettime(6) + bdock_second(k)
			if(now_second >= 60) :now_minute += now_second / 60 :now_second \= 60
			if(now_minute >= 60) :now_hour += now_minute / 60 :now_minute \= 60
			objprm k * 2 + 9, strf("%02d:%02d:%02d", now_hour, now_minute, now_second)
		}else{
			objprm k * 2 + 9, ""
		}
	next
	for k, 0, kDocks - 1
		objprm k * 2 + 16, strf("%02d:%02d:%02d", edock_hour(k), edock_minute(k), edock_second(k))
		if((edock_hour(k) != 0) || (edock_minute(k) != 0) || (edock_second(k) != 0)){
			now_hour   = gettime(4) + edock_hour(k)
			now_minute = gettime(5) + edock_minute(k)
			now_second = gettime(6) + edock_second(k)
			if(now_second >= 60) :now_minute += now_second / 60 :now_second \= 60
			if(now_minute >= 60) :now_hour += now_minute / 60 :now_minute \= 60
			objprm k * 2 + 17, strf("%02d:%02d:%02d", now_hour, now_minute, now_second)
		}else{
			objprm k * 2 + 17, ""
		}
	next
return

//ソート一覧画面を出す
*show_sort_list
	gsel kSortListWindowID, 2
return
//ソート一覧画面を閉じる
*close_sort_list
	gsel kSortListWindowID, -1
return
//追加
*add_sort_list
	if(mode_list3(JudgeSituation(kPutTempWindowID, 0)) == "ソート画面"){
		;バッファの追加
		buffer kSortIdOffset + sort_list_size, kSortWX, kSortWY
		gcopy kPutTempWindowID, kSortPX, kSortPY, kSortWX, kSortWY
		;リストの追加
		sort_list += NowTime() + "\n"
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
		sort_list_size++
	}
return
//↑
*upper_sort_list
	if((sort_index >= 1) && (sort_index < sort_list_size)){
		;バッファの入れ替え
		buffer kTempBufferID, kSortWX, kSortWY
		gcopy kSortIdOffset + sort_index - 1, 0, 0, kSortWX, kSortWY
		gsel kSortIdOffset + sort_index - 1
		gcopy kSortIdOffset + sort_index, 0, 0, kSortWX, kSortWY
		gsel kSortIdOffset + sort_index
		gcopy kTempBufferID, 0, 0, kSortWX, kSortWY
		;リストの入れ替え
		notesel sort_list
		noteget text_buffer,  sort_index - 1
		noteget text_buffer2, sort_index
		noteadd text_buffer2, sort_index - 1, 1
		noteadd text_buffer,  sort_index,     1
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
	}
return
//↓
*lower_sort_list
	if((sort_index >= 0) && (sort_index < sort_list_size - 1)){
		;バッファの入れ替え
		buffer kTempBufferID, kSortWX, kSortWY
		gcopy kSortIdOffset + sort_index + 1, 0, 0, kSortWX, kSortWY
		gsel kSortIdOffset + sort_index + 1
		gcopy kSortIdOffset + sort_index, 0, 0, kSortWX, kSortWY
		gsel kSortIdOffset + sort_index
		gcopy kTempBufferID, 0, 0, kSortWX, kSortWY
		;リストの入れ替え
		notesel sort_list
		noteget text_buffer,  sort_index + 1
		noteget text_buffer2, sort_index
		noteadd text_buffer2, sort_index + 1, 1
		noteadd text_buffer,  sort_index,     1
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
	}
return
//削除
*del_sort_list
	if((sort_index >= 0) && (sort_index < sort_list_size)){
		;バッファの削除
		for k, sort_index, sort_list_size - 1
			gsel kSortIdOffset + k
			gcopy kSortIdOffset + k + 1, 0, 0, kSortWX, kSortWY
		next
		;リストの削除
		notesel sort_list
		notedel sort_index
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
		sort_list_size--
	}
return
//全削除
*alldel_sort_list
	sort_list = ""
	gsel kSortListWindowID
	objprm sort_index_id, sort_list
	sort_list_size = 0
return
//画像を出力
*make_sort_list
	;出力用バッファを準備
	ListSizeX = (sort_width_index + 1) * kSortWX
	ListSizeY = sort_list_size / (sort_width_index + 1) * kSortWY
	if(sort_list_size \ (sort_width_index + 1) != 0) :ListSizeY + kSortWY
	buffer kTempBufferID, ListSizeX, ListSizeY
	;バッファに書き込んでいく
	for k, 0, sort_list_size
		x = k \ (sort_width_index + 1)
		y = (k - x) / (sort_width_index + 1)
		pos x * kSortWX, y * kSortWY
		gcopy kSortIdOffset + k, 0, 0, kSortWX, kSortWY
	next
	cvbuffer kCaptureBufferID, ginfo_sx, ginfo_sy
	cvputimg kCaptureBufferID
	cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCaptureBufferID
return
//リストクリックに応じて画像変更
*redraw_sort_preview
	if((sort_index >= 0) && (sort_index < sort_list_size)){
		gsel kSortListWindowID
		pos kObjSpace * 2 + kObjX * 2, kObjSpace
		gzoom2 kObjX * 2, kObjY * 10, kSortIdOffset + sort_index, 0, 0, kSortWX, kSortWY
	}
return

//資材グラフを出す
*show_graph
	gsel kSupplyGraphID, 2
return
//資材グラフを閉じる
*close_graph
	gsel kSupplyGraphID, -1
return
//資材グラフを作成する
*make_graph
	// 日付の最小値・最大値を取り出す
	day_first = ConvertDay(supply_log_int(0, 0))
	day_last  = ConvertDay(supply_log_int(supply_log_size - 1, 0))
	// 資源の最小値・最大値を取り出す
	max_param = supply_log_int(0, 2)
	min_param = supply_log_int(0, 2)
	for n, 0, supply_log_size
		for k, 2, 6
			if(max_param < supply_log_int(n, k)) :max_param = supply_log_int(n, k)
			if(min_param > supply_log_int(n, k)) :min_param = supply_log_int(n, k)
		next
	next
	max_param = ((max_param / 1000) + 1) * 1000
	min_param = ((min_param / 1000) - 1) * 1000 :if(min_param < 0) :min_param = 0
	diff_param = max_param - min_param
	// グラフを作成する
	day_diff = day_last - day_first + 1
	block_num = day_diff / scale_blocking(scale_mode)
	if(day_diff \ scale_blocking(scale_mode) != 0) :block_num++
	//グラフ線
	buffer kGraphBufferID, block_num * kGraphWX, kGraphWY
	for n, 0, supply_log_size - 1
		for k, 2, 6
			switch k
				case 2	;燃料
					color $00,$80,$00
					swbreak
				case 3	;弾薬
					color $66,$33,$00
					swbreak
				case 4	;鋼材
					color $A0,$A0,$A0
					swbreak
				case 5	;ボーキ
					color $CC,$33,$00
					swbreak
			swend
			p1 = ((ConvertDay(supply_log_int(n, 0)) - day_first) * kGraphWX + ConvertTime(supply_log_int(n, 1)) * kGraphWX) / scale_blocking(scale_mode)
			p2 = kGraphWY - 1.0 * (supply_log_int(n, k) - min_param) / diff_param * kGraphWY
			p3 = ((ConvertDay(supply_log_int(n + 1, 0)) - day_first) * kGraphWX + ConvertTime(supply_log_int(n + 1, 1)) * kGraphWX) / scale_blocking(scale_mode)
			p4 = kGraphWY - 1.0 * (supply_log_int(n + 1, k) - min_param) / diff_param * kGraphWY
			line p1, p2, p3, p4
		next
	next
	//縦線
	font msgothic, kGraphFontSize
	for k, 0, block_num * scale_zooming(scale_mode)
		color $C0,$C0,$C0
		line k * kGraphStepX, 0, k * kGraphStepX, kGraphWY
		color 0, 0, 255
		pos k * kGraphStepX, kGraphWY - kGraphFontSize * 2
		switch scale_mode
			case 0	;1日
				mes strf("%02dh", (k \ 12) * 2)
				swbreak
			case 1	;1週間
				mes strf("%01dd", k \ 7)
				swbreak
			case 2	;2週間
				mes strf("%02dd", (k \ 7) * 2)
				swbreak
			case 3	;1ヶ月
				mes strf("%02dd", (k \ 10) * 3)
				swbreak
			case 4	;2ヶ月
				mes strf("%02dd", (k \ 10) * 6)
				swbreak
			case 5	;3ヶ月
				mes strf("%02dd", (k \ 12) * 7)
				swbreak
			case 6	;半年
				mes strf("%02dm", k \ 6)
				swbreak
			case 7	;1年
				mes strf("%02dm", k \ 12)
				swbreak
		swend
	next
	//横線
	interval_y = 1
	if(diff_param > 10) :interval_y = 10
	if(diff_param > 100) :interval_y = 100
	if(diff_param > 1000) :interval_y = 1000
	if(diff_param > 10000) :interval_y = 10000
	if(diff_param > 100000) :interval_y = 100000
	color $C0,$C0,$C0
	for yy, 0, 500000, interval_y
		if(limit(yy, min_param, max_param) != yy) :_continue
		yy2 = kGraphWY - 1.0 * (yy - min_param) / diff_param * kGraphWY
		line 0, yy2, block_num * kGraphWX, yy2
	next
	//日付
	color 0, 0, 255
	for k, 0, block_num
		pos k * kGraphStepX * scale_zooming(scale_mode), kGraphFontSize
		mes ConvertDay2(day_first + k * scale_blocking(scale_mode))
	next
	// 表示座標を初期化
	plot_graph_px = (block_num - 1) * scale_zooming(scale_mode) * kGraphStepX
return
//資材グラフを表示する
*plot_graph
	gsel kSupplyGraphID
	redraw 0
		;画像
		color $FF, $FF, $FF
		boxf
		pos 0, 0
		gcopy kGraphBufferID, plot_graph_px, 0, kGraphWX, kGraphWY
		;文字
		font msgothic, kGraphFontSize
		color
		pos 0, 0
		mes max_param
		pos 0, kGraphWY - kGraphFontSize
		mes min_param
	redraw 1
return
//資材グラフのスクショを保存
*save_graph
	gsel kSupplyGraphID
	cvbuffer kCaptureBufferID, ginfo_sx, ginfo_sy
	cvputimg kCaptureBufferID
	cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCaptureBufferID
return

//資源画像を保存
*save_stock
	if(CheckHomeFlg(kPutTempWindowID)){
		buffer kTempBufferID, kStockAllWX, kStockAllWY
		pos 0, 0
		gcopy kPutTempWindowID, kStockTimePX, kStockTimePY, kStockTimeWX, kStockTimeWY
		pos kStockTimeWX, 0
		gcopy kPutTempWindowID, kStockOtherPX, kStockOtherPY, kStockOtherWX, kStockOtherWY
		cvbuffer kCaptureBufferID, ginfo_sx, ginfo_sy
		cvputimg kCaptureBufferID
		cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCaptureBufferID
		gsel kMainWindowID
	}
return

//オプション画面を閉じる
*close_option
	gsel kOptionWindowID, -1
return
//保存フォルダを参照する
*browse_folder
	selfolder pic_save_path(1), "保存フォルダ..."
	if(strlen(pic_save_path(1)) == 3) :pic_save_path(1) = strmid(pic_save_path(1), 0, 2)	;ドライブ直下対策
	gsel kOptionWindowID
	redraw 0
		color 255, 255, 255 :boxf
		color
		font msgothic, kSmallFontSize
			pos kObjSpace                 , kObjSpace + kObjSpaceY * 3 + kObjOffset
				mes pic_save_path(1)
	redraw 1
	gsel kMainWindowID
return
//オプション画面を開く
*show_option
	gsel kOptionWindowID, 2
return

//データセーブ(手動)
*save_soft_data
	WriteSaveData
return

//このソフトについて
*about
	dialog "ソフト名：" + kSoftName + " " + kSoftVer + "\n作成者：YSR\n最終更新日：" + kSoftLastUpdate,,kSoftName
return

*main2
