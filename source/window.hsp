/* サブルーチン(画面周り) */
goto *main2

// 座標取得
*get_pos
	error_log += NowTime() + ",get_pos," + manual_getpos_flg + "\n"
	switch manual_getpos_flg
		case 0
			// 座標を自動で取得する
			if(get_handle_flg){
				//デスクトップを撮影する
				GetDesktopWindow kDeskBufferID
				//撮影した画像から座標を検索する
				GetPosFlashSquare kDeskBufferID, kFlashBufferID, flash_px, flash_py
				//座標補正
				flash_px += kOffsetX :flash_py += kOffsetY
				;handleを取得
				handle = 0
				handle = GetPointHandle(flash_px + kFlashWX / 2, flash_py + kFlashWY / 2)
				if(handle == 0) :dialog "ハンドルを取得できませんでした", 0, kSoftName :swbreak
			}
			gosub *get_pos_child
			swbreak
		case 1
			// 座標を手動で取得する
			if(get_handle_flg){
				//デスクトップを撮影する
				GetDesktopWindow kDeskBufferID
				//手動で枠を選択させる
				;初期設定
				bgscr kSelectWindowID, kDispX, kDispY, , kOffsetX, kOffsetY
				gsel kSelectWindowID, 2
				font msgothic, kLargeFontSize
				;画面表示
				gcopy kDeskBufferID, 0, 0, kDispX, kDispY
				color :mes "枠を選択して下さい。(Escで終了)"
				;選択操作
				is_mouse_button = FALSE
				is_mouse_select = FALSE
				mouse_pos_x1 = 0 :mouse_pos_y1 = 0
				repeat
					stick key, kStickMouse
					if(key & kStickEscKey) :break
					if(key & kStickMouse){
						if(is_mouse_button){
							// 選択中
							redraw 0
								pos 0, 0
								gcopy kDeskBufferID, 0, 0, kDispX, kDispY
								color :mes "枠を選択して下さい。(Escで終了)"
								DrawMouseSquare mousex, mousey, mouse_pos_x1, mouse_pos_y1
							redraw 1
						}else{
							// 選択開始
							mouse_pos_x1 = mousex
							mouse_pos_y1 = mousey
							is_mouse_button = TRUE
						}
					}else{
						if(is_mouse_button){
							// 選択終了
							mouse_pos_x2 = mousex
							mouse_pos_y2 = mousey
							if(mouse_pos_x1 < mouse_pos_x2){
								square_x = mouse_pos_x1
								square_xsize = mouse_pos_x2 - mouse_pos_x1 + 1
							}else{
								square_x = mouse_pos_x2
								square_xsize = mouse_pos_x1 - mouse_pos_x2 + 1
							}
							if(mouse_pos_y1 < mouse_pos_y2){
								square_y = mouse_pos_y1
								square_ysize = mouse_pos_y2 - mouse_pos_y1 + 1
							}else{
								square_y = mouse_pos_y2
								square_ysize = mouse_pos_y1 - mouse_pos_y2 + 1
							}
							is_mouse_button = FALSE
							is_mouse_select = TRUE
							break
						}else{
							// 何もしていない
						}
					}
					wait 5
				loop
				;選択結果から検索を行う
				gsel kSelectWindowID, -1
				handle = 0
				if(is_mouse_select){
					buffer kTempBufferID, square_xsize, square_ysize
					gcopy kDeskBufferID, square_x, square_y, square_xsize, square_ysize
					if((square_xsize < kFlashWX) || (square_ysize < kFlashWY)){
					}else{
						GetPosFlashSquare kTempBufferID, kFlashBufferID, flash_px, flash_py
						flash_px += square_x :flash_py += square_y
						;座標補正
						flash_px += kOffsetX :flash_py += kOffsetY
						;handleを取得
						handle = GetPointHandle(flash_px + kFlashWX / 2, flash_py + kFlashWY / 2)
					}
				}
				if(handle == 0) :dialog "ハンドルを取得できませんでした", 0, kSoftName :swbreak
			}
			gosub *get_pos_child
			swbreak
		case 2
			// 座標を自動で取得する(ウィンドウ相手にBitBltするVer)
			//艦これを開いているブラウザを撮影する
			if(get_handle_flg){
				handle = GetKanColleHandle()
				if(handle == 0) :dialog "ハンドルを取得できませんでした", 0, kSoftName :swbreak
			}
			gosub *get_pos_child
			swbreak
		case 3
			// 座標を手動で取得する(クリック版)
			if(get_handle_flg){
				//デスクトップを撮影する
				GetDesktopWindow kDeskBufferID
				//手動でクリックさせる
				;初期設定
				bgscr kSelectWindowID, kDispX, kDispY, , kOffsetX, kOffsetY
				gsel kSelectWindowID, 2
				font msgothic, kLargeFontSize
				;画面表示
				gcopy kDeskBufferID, 0, 0, kDispX, kDispY
				color :mes "クリックして下さい。(Escで終了)"
				;選択操作
				is_mouse_button = FALSE
				mouse_pos_x = 0 :mouse_pos_y = 0
				repeat
					stick key, kStickMouse
					if(key & kStickEscKey) :break
					if(key & kStickMouse){
						/*mouse_pos_x = mousex + kOffsetX
						mouse_pos_y = mousey + kOffsetY*/
						mouse_pos_x = ginfo(0)
						mouse_pos_y = ginfo(1)
						is_mouse_button = TRUE
						break
					}
					wait 5
				loop
				;選択結果から検索を行う
				gsel kSelectWindowID, -1
				handle = 0
				if(is_mouse_button) :handle = GetPointHandle(mouse_pos_x, mouse_pos_y)
				if(handle == 0) :dialog "ハンドルを取得できませんでした", 0, kSoftName :swbreak
			}
			gosub *get_pos_child
			swbreak
	swend
return
*get_pos_child
	dim rect, 4
	GetClientSize handle, rect
	wx = rect(2) - rect(0) :wy = rect(3) - rect(1)
	if((wx < kFlashWX) || (wy < kFlashWY)){
		if(get_handle_flg){
			dialog "画面サイズを取得できませんでした", 0, kSoftName
		}
		return
	}
	GetKanColleWindow handle, kDeskBufferID, wx, wy
	//撮影した画像から座標を検索する
	GetPosFlashSquare kDeskBufferID, kFlashBufferID, flash_px, flash_py
	flash_px += rect(0) :flash_py += rect(1)
	SetTitle
	get_pos_flg = TRUE
return

//画像保存
*save_picture
	error_log += NowTime() + ",save_picture," + cap_crop_flg + "+" + denoise_flg + "\n"
	//画面クロップにチェックが入っているかで対応が変わる
	screen_shot_type2 = JudgeSituation(kPutTempWindowID, 0)
	if((cap_crop_flg) && (screen_shot_type2 >= kSceneListSize)){
		//クロップして保存
		if(screen_shot_type2 >= kSceneListSize + kFleetNum){
			//改装画面
			buffer kTempBufferID, kUnitWX, kUnitWY
			gcopy kPutTempWindowID, kUnitPX, kUnitPY, kUnitWX, kUnitWY
		}else{
			//編成画面
			buffer kTempBufferID, kFleetWX, kFleetWY
			gcopy kPutTempWindowID, kFleetPX, kFleetPY, kFleetWX, kFleetWY
		}
	}else{
		//通常保存
		gsel kPutTempWindowID
	}
	if(denoise_flg) :Denoise
	if(auto_save_picture_flg){
		if(save_picture2_index == 0){
			bmpsave pic_save_path(my_folder_flg) + "\\" + AutoFileName_()
		}else{
			bmpsave pic_save_path(my_folder_flg) + "\\" + save_picture2_firstname + strf("%05d", save_picture2_count) + ".bmp"
			save_picture2_count++
		}
	}else{
		//毎回バッファを初期化し直すのは、他画像保存モードでもこのバッファを使いまわすため
		//(Ver.2.1.0におけるバグ修正)
		cvbuffer kCVTempBufferID, ginfo_sx, ginfo_sy
		cvputimg kCVTempBufferID
		if(mode_index == kTypeNow){
			;現在画面
			cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCVTempBufferID
		}else{if(mode_index == kSceneListSize + 1){
			;編成画面
			cvsave pic_save_path(my_folder_flg) + "\\" + GetLastUpdate(kSceneListSize + fleets_index) + ".png", kCVTempBufferID
		}else{if(mode_index == kSceneListSize + 2){
			;改装画面
			cvsave pic_save_path(my_folder_flg) + "\\" + GetLastUpdate(kSceneListSize + kFleetNum + units_index) + ".png", kCVTempBufferID
		}else{if(mode_index == kSceneListSize + 3){
			;戦闘画面
			cvsave pic_save_path(my_folder_flg) + "\\" + GetLastUpdate(kSceneListSize + kFleetNum + kFleetNum * kUnitNum) + ".png", kCVTempBufferID
		}else{
			;その他
			cvsave pic_save_path(my_folder_flg) + "\\" + GetLastUpdate(mode_index - 1) + ".png", kCVTempBufferID
		}}}}
	}
	gsel kMainWindowID
return
*save_picture2
	if(auto_save_picture_flg){
		error_log += NowTime() + ",auto_save_picture,end\n"
		auto_save_picture_flg = FALSE
		gsel kMainWindowID
		objprm auto_save_picture_id, "【連写保存】"
	}else{
		error_log += NowTime() + ",auto_save_picture,start\n"
		auto_save_picture_flg = TRUE
		gsel kMainWindowID
		objprm auto_save_picture_id, "【連写停止】"
		if(save_picture2_index == 1){
			save_picture2_firstname = NowTime() + "_"
			save_picture2_count = 1
		}
	}
return

//艦隊画像保存
*save_fleets
	error_log += NowTime() + ",save_fleets," + commands_index + "\n"
	if(commands_index < kFleetNum){
		// 第1〜第4艦隊
		buffer kTempBufferID, kUnitWX * 3, kUnitWY * 2
		for y, 0, 2
			for x, 0, 3
				pos x * kUnitWX, y * kUnitWY
				gcopy kUnitIdOffset + commands_index * kUnitNum + (y * 3 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
			next
		next
		cvbuffer kCVTempBufferID, kUnitWX * 3, kUnitWY * 2
		cvputimg kCVTempBufferID
		cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCVTempBufferID
	}else{
		// 連合・支援艦隊
		buffer kTempBufferID, kUnitWX * 4, kUnitWY * 3
		for z, 0, 2
			for y, 0, 3
				for x, 0, 2
					pos (z * 2 + x) * kUnitWX, y * kUnitWY
					gcopy kUnitIdOffset + (commands_index - kFleetNum) * (kUnitNum * 2) + (z * 6 + y * 2 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
				next
			next
		next
		cvbuffer kCVTempBufferID, kUnitWX * 4, kUnitWY * 3
		cvputimg kCVTempBufferID
		cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCVTempBufferID
		gsel kMainWindowID
	}
	gsel kMainWindowID
return

//BGM参照
*browse_bgm
	dialog "wav;*.mp3;*.wma", 16, "音楽ファイル"
	if(stat){
		bgm_list_filename(bgm_index) = refstr
		mmload refstr, bgm_index, 1
		bgm_list_flg(bgm_index) = TRUE
		if(bgm_index == bgm_type) :mmplay bgm_index :now_bgm = bgm_index
		gosub *init_bgm_list
		gsel kMainWindowID
		objprm bgm_index_id, bgm_list
		objprm bgm_index_id, bgm_index
		error_log += NowTime() + ",browse_bgm," + bgm_index + "-" + bgm_list_filename(bgm_index) + "\n"
	}
return
//BGM切り替え
*switch_bgm
	error_log += NowTime() + ",switch_bgm," + bgm_index + "\n"
	if(bgm_list_flg(bgm_index)){
		bgm_list_flg(bgm_index) = FALSE
		if(bgm_index == bgm_type) :mmstop
	}else{
		exist bgm_list_filename(bgm_index)
		if(strsize != -1){
			bgm_list_flg(bgm_index) = TRUE
			if(bgm_index == bgm_type) :mmplay bgm_index :now_bgm = bgm_index
		}
	}
	gosub *init_bgm_list
	gsel kMainWindowID
	objprm bgm_index_id, bgm_list
	objprm bgm_index_id, bgm_index
return
//BGM再生
*start_bgm
	error_log += NowTime() + ",start_bgm," + bgm_type + "\n"
	if((bgm_type >= 0) && (bgm_type < kBgmListSize)){
		if(bgm_list_flg(bgm_type)){
			mmplay bgm_type
			now_bgm = bgm_type
			bgm_type_ = bgm_type
		}
	}
return
//BGM停止
*stop_bgm
	error_log += NowTime() + ",stop_bgm,\n"
	mmstop
return

//経験値計算機を閉じる
*close_exp
	error_log += NowTime() + ",close_exp,\n"
	gsel kExpCalcWindowID, -1
return
//経験値の計算
*exp_calc
	error_log += NowTime() + ",exp_calc,\n"
	now_id = ginfo_sel
	;レベル・経験値自動補完機能
	if((exp_ss_flg) && (sst_str == "編成画面")){
		;レベル補間
		gsel kFlashBufferID
		now_level = limit(GetLevel(exp_unit_index), 1, 150) - 1
		now_level_ = now_level
		gsel kExpCalcWindowID
		objprm 0, now_level
		if(now_level >= goal_level){
			goal_level = now_level + 1
			objprm 1, goal_level
		}
		;経験値補間
		gsel kFlashBufferID
		unit_exp_double = GetUnitExp(exp_unit_index)
		if(now_level != 150 - 1){
			now_exp_plus = int(unit_exp_double * (need_exp_table(now_level + 1) - need_exp_table(now_level)))
		}
	}else{
		now_exp_plus = 0
	}
	gsel kExpCalcWindowID
	;レベルの矛盾を修正
	if(now_level > goal_level){
		if(now_level != now_level_){
			goal_level = now_level
			objprm 1, goal_level
		}
		if(goal_level != goal_level_){
			now_level = goal_level
			objprm 0, now_level
		}
	}
	;必要経験値を計算
	now_exp = need_exp_table(now_level) + now_exp_plus
	goal_exp = need_exp_table(goal_level)
	diff_exp = goal_exp - now_exp
	objprm 8, diff_exp
	;戦闘経験値を計算
	battle_exp = 1.0 * exp_data(area_index)
	if(reader_ship_flg) :battle_exp *= 1.5
	if(mvp_flg) :battle_exp *= 2.0
	switch result_index
		case 0	;完全勝利S
			battle_exp *= 1.2
			swbreak
		case 1	;勝利S
			battle_exp *= 1.2
			swbreak
		case 2	;勝利A
			battle_exp *= 1.0
			swbreak
		case 3	;戦術的勝利B
			battle_exp *= 1.0
			swbreak
		case 4	;戦術的敗北C
			battle_exp *= 0.8
			swbreak
		case 5	;敗北D
			battle_exp *= 0.7
			swbreak
		case 6	;敗北E
			battle_exp *= 0.5
			if(mvp_flg) :battle_exp *= 0.5	;MVP無効
	swend
	battle_exp = int(battle_exp)
	objprm 9, battle_exp
	;必要周回数を計算
	if(need_exp \ battle_exp == 0){
		need_battles = need_exp / battle_exp
	}else{
		need_battles = need_exp / battle_exp + 1
	}
	objprm 10, need_battles
	gsel now_id
return
//経験値計算機を出す
*calc_exp
	error_log += NowTime() + ",calc_exp,\n"
	gsel kExpCalcWindowID, 2
return

//カウンターリセット
*reset_counter_a
	error_log += NowTime() + ",reset_counter,a\n"
	a_sortie_count = 0			;あ号出撃
	a_to_boss_count = 0			;あ号ボス到達
	a_win_boss_count = 0		;あ号ボス勝利
	a_s_win_count = 0			;あ号S勝利
	gosub *redraw_counter
return
*reset_counter_r
	error_log += NowTime() + ",reset_counter,r\n"
	r_count = 0					;ろ号
	gosub *redraw_counter
return
*reset_counter_i
	error_log += NowTime() + ",reset_counter,i\n"
	i_count = 0					;い号
	gosub *redraw_counter
return
//カウンターを閉じる
*close_counter
	error_log += NowTime() + ",close_counter,\n"
	gsel kCountWindowID, -1
return
//カウンターを出す
*count_task
	error_log += NowTime() + ",count_task,\n"
	gsel kCountWindowID, 2
return
//カウントする
*count_a_sortie :a_sortie_count++ :gosub *redraw_counter :return
*count_a_to_boss :a_to_boss_count++ :gosub *redraw_counter :return
*count_a_win_boss :a_win_boss_count++ :gosub *redraw_counter :return
*count_a_s_win :a_s_win_count++ :gosub *redraw_counter :return
*count_r :r_count++ :gosub *redraw_counter :return
*count_i :i_count++ :gosub *redraw_counter :return
//カウンター再描画
*redraw_counter
	error_log += NowTime() + ",redraw_counter,\n"
	count_result = ""
	;あ号
	count_result += "あ号：" + a_sortie_count + "回/" + a_to_boss_count + "回/" + a_win_boss_count + "回/" + a_s_win_count + "回("
	if((a_sortie_count >= 36) && (a_to_boss_count >= 24) && (a_win_boss_count >= 12) && (a_s_win_count >= 6)){
		count_result += "達成)\n"
	}else{
		count_result += "未達成)\n"
	}
	;ろ号
	count_result += "ろ号：" + r_count + "回("
	if(r_count >= 50) :count_result += "達成)\n" :else :count_result += "未達成)\n"
	;い号
	count_result += "い号：" + i_count + "回("
	if(i_count >= 20) :count_result += "達成)\n" :else :count_result += "未達成)\n"
	id = ginfo_sel
	gsel kCountWindowID
	objprm 0, count_result
	gsel id
return

//タイマーを出す
*dock_timer
	error_log += NowTime() + ",dock_timer,\n"
	gsel kDockWindowID, 2
return
//タイマーを閉じる
*close_dock
	error_log += NowTime() + ",close_dock,\n"
	gsel kDockWindowID, -1
return
//時間を取得
*get_dock
	gsel kFlashBufferID
	if(screen_shot_type >= kSceneListSize + 1) :return
	if(sst_str == "入渠画面"){
		error_log += NowTime() + ",get_dock,normal\n"
		buffer kTempBufferID, 11, 16
		dim number, 6
		for i, 0, kDocks
			gsel kFlashBufferID
			dock_hour(i) = 0
			dock_minute(i) = 0
			dock_second(i) = 0
			if(NearColor(480, ypos(i), 33, 174, 178)){	//ドックに艦娘がいるかを判定
				for j, 0, 6
					gsel kTempBufferID
					gcopy kFlashBufferID, xpos(j), ypos(i) + 25, 11, 16
					number(j) = limit(MatchNumber(170, FALSE), 0, 9)
					if(j == 0) :number(j) = limit(number(j), 0, 5)
					if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
				next
				dock_hour(i)   = number(0) * 10 + number(1)
				dock_minute(i) = number(2) * 10 + number(3)
				dock_second(i) = number(4) * 10 + number(5)
			}
			gsel kDockWindowID
			gosub *redraw_dock
		next
	}
	if(sst_str == "工廠画面"){
		error_log += NowTime() + ",get_dock,b\n"
		buffer kTempBufferID, 11, 16
		dim number, 6
		for i, 0, kDocks
			gsel kFlashBufferID
			bdock_hour(i) = 0
			bdock_minute(i) = 0
			bdock_second(i) = 0
			if(NearColor(730, bypos(i), 204, 128, 73)){	//ドックに艦娘がいるかを判定
				for j, 0, 6
					gsel kTempBufferID
					gcopy kFlashBufferID, bxpos(j), bypos(i), 11, 16
					number(j) = limit(MatchNumber(170, FALSE), 0, 9)
					if(j == 0) :number(j) = limit(number(j), 0, 5)
					if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
				next
				bdock_hour(i)   = number(0) * 10 + number(1)
				bdock_minute(i) = number(2) * 10 + number(3)
				bdock_second(i) = number(4) * 10 + number(5)
			}
			gsel kDockWindowID
			gosub *redraw_dock
		next
	}
return
*get_dock_e2
	gsel kFlashBufferID
	//遠征時間の計測は地味に面倒臭い……
	;まず遠征の画面かを判定
	if(NearColor(509,113,252,180,88) && NearColor(286,139,54,70,44) && NearColor(585,393,35,158,159)){
		;次に、時間が表示されているかを判定
		if(NearColor(598,451,118,113,114)){
			error_log += NowTime() + ",get_dock,e2\n"
			;そして、第何艦隊が対象かを判定
			;「旗左下から1つ上」基準で、上から
			;x=517, y=180, 210, 240, ..., 390(約R76 G168 B168)
			for k, 0, kExpPagePer
				if(NearColor(517,180 + k * 30,76,168,168)){
					;(517,180+k*30)を基準とした場合、、
					;(+8,0)が第2→R224 G230 B227、第3→R47  G164 B165、第4→R237 G229 B217
					;(+6,0)が第2→R84  G176 B174、第3→R236 G228 B215、第4→R239 G231 B219
					;として判別可能
					if(NearColor(525,180 + k * 30,224,230,227) && NearColor(523,180 + k * 30, 84,176,174)){
						;右上の遠征名とリストの遠征名が一致しているかをチェックする
						exp_small_name = GetExpSmallName(k)
						exp_large_name = GetExpLargeName()
						if((exp_small_name == exp_large_name) || (exp_small_name == -1) || (exp_large_name == -1)){
							buffer kTempBufferID, 9, 13
							dim number, 6
							gsel kFlashBufferID
							i = 0
							edock_hour(i) = 0
							edock_minute(i) = 0
							edock_second(i) = 0
							for j, 0, 6
								gsel kTempBufferID
								gcopy kFlashBufferID, expos(j), 387, 9, 13
								number(j) = limit(MatchNumber(190, FALSE), 0, 9)
								if(j == 0) :number(j) = limit(number(j), 0, 5)
								if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
							next
							edock_hour(i)   = number(0) * 10 + number(1)
							edock_minute(i) = number(2) * 10 + number(3)
							edock_second(i) = number(4) * 10 + number(5)
							gsel kDockWindowID
							gosub *redraw_dock
							_break
						}
					}
				}
			next
		}
	}
return
*get_dock_e3
	gsel kFlashBufferID
	;まず遠征の画面かを判定
	if(NearColor(509,113,252,180,88) && NearColor(286,139,54,70,44) && NearColor(585,393,35,158,159)){
		;次に、時間が表示されているかを判定
		if(NearColor(598,451,118,113,114)){
			error_log += NowTime() + ",get_dock,e3\n"
			;そして、第何艦隊が対象かを判定
			;「旗左下から1つ上」基準で、上から
			;x=517, y=180, 210, 240, ..., 390(約R76 G168 B168)
			for k, 0, 8
				if(NearColor(517,180 + k * 30,76,168,168)){
					if(NearColor(525,180 + k * 30, 47,164,165) && NearColor(523,180 + k * 30,236,228,215)){
						;右上の遠征名とリストの遠征名が一致しているかをチェックする
						exp_small_name = GetExpSmallName(k)
						exp_large_name = GetExpLargeName()
						if((exp_small_name == exp_large_name) || (exp_small_name == -1) || (exp_large_name == -1)){
							buffer kTempBufferID, 9, 13
							dim number, 6
							gsel kFlashBufferID
							i = 1
							edock_hour(i) = 0
							edock_minute(i) = 0
							edock_second(i) = 0
							for j, 0, 6
								gsel kTempBufferID
								gcopy kFlashBufferID, expos(j), 387, 9, 13
								number(j) = limit(MatchNumber(190, FALSE), 0, 9)
								if(j == 0) :number(j) = limit(number(j), 0, 5)
								if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
							next
							edock_hour(i)   = number(0) * 10 + number(1)
							edock_minute(i) = number(2) * 10 + number(3)
							edock_second(i) = number(4) * 10 + number(5)
							gsel kDockWindowID
							gosub *redraw_dock
							_break
						}
					}
				}
			next
		}
	}
return
*get_dock_e4
	gsel kFlashBufferID
	;まず遠征の画面かを判定
	if(NearColor(509,113,252,180,88) && NearColor(286,139,54,70,44) && NearColor(585,393,35,158,159)){
		;次に、時間が表示されているかを判定
		if(NearColor(598,451,118,113,114)){
			;そして、第何艦隊が対象かを判定
			error_log += NowTime() + ",get_dock,e4\n"
			for k, 0, 8
				if(NearColor(517,180 + k * 30,76,168,168)){
					if(NearColor(525,180 + k * 30,237,229,217) && NearColor(523,180 + k * 30,239,231,219)){
						;右上の遠征名とリストの遠征名が一致しているかをチェックする
						exp_small_name = GetExpSmallName(k)
						exp_large_name = GetExpLargeName()
						if((exp_small_name == exp_large_name) || (exp_small_name == -1) || (exp_large_name == -1)){
							buffer kTempBufferID, 9, 13
							dim number, 6
							gsel kFlashBufferID
							i = 2
							edock_hour(i) = 0
							edock_minute(i) = 0
							edock_second(i) = 0
							for j, 0, 6
								gsel kTempBufferID
								gcopy kFlashBufferID, expos(j), 387, 9, 13
								number(j) = limit(MatchNumber(190, FALSE), 0, 9)
								if(j == 0) :number(j) = limit(number(j), 0, 5)
								if((j == 2) || (j == 4)) :number(j) = limit(number(j), 0, 5)
							next
							edock_hour(i)   = number(0) * 10 + number(1)
							edock_minute(i) = number(2) * 10 + number(3)
							edock_second(i) = number(4) * 10 + number(5)
							gsel kDockWindowID
							gosub *redraw_dock
							_break
						}
					}
				}
			next
		}
	}
return
//インクリメント
*increment_dock
	for k, 0, kDocks
		if((dock_hour(k) != 0) || (dock_minute(k) != 0) || (dock_second(k) != 0)){
			dock_second(k)--
			if(dock_second(k) < 0){
				dock_second(k) += 60
				dock_minute(k)--
				if(dock_minute(k) < 0){
					dock_minute(k) += 60
					dock_hour(k) --
				}
			}
		}
		if((bdock_hour(k) != 0) || (bdock_minute(k) != 0) || (bdock_second(k) != 0)){
			bdock_second(k)--
			if(bdock_second(k) < 0){
				bdock_second(k) += 60
				bdock_minute(k)--
				if(bdock_minute(k) < 0){
					bdock_minute(k) += 60
					bdock_hour(k) --
				}
			}
		}
	next
	for k, 0, kDocks - 1
		if((edock_hour(k) != 0) || (edock_minute(k) != 0) || (edock_second(k) != 0)){
			edock_second(k)--
			if(edock_second(k) < 0){
				edock_second(k) += 60
				edock_minute(k)--
				if(edock_minute(k) < 0){
					edock_minute(k) += 60
					edock_hour(k) --
				}
			}
		}
	next
return
//再描画
*redraw_dock
	for k, 0, kDocks
		objprm k * 2, strf("%02d:%02d:%02d", dock_hour(k), dock_minute(k), dock_second(k))
		if((dock_hour(k) != 0) || (dock_minute(k) != 0) || (dock_second(k) != 0)){
			now_hour   = gettime(4) + dock_hour(k)
			now_minute = gettime(5) + dock_minute(k)
			now_second = gettime(6) + dock_second(k)
			if(now_second >= 60) :now_minute += now_second / 60 :now_second \= 60
			if(now_minute >= 60) :now_hour += now_minute / 60 :now_minute \= 60
			objprm k * 2 + 1, strf("%02d:%02d:%02d", now_hour, now_minute, now_second)
		}else{
			objprm k * 2 + 1, ""
		}
		objprm k * 2 + 8, strf("%02d:%02d:%02d", bdock_hour(k), bdock_minute(k), bdock_second(k))
		if((bdock_hour(k) != 0) || (bdock_minute(k) != 0) || (bdock_second(k) != 0)){
			now_hour   = gettime(4) + bdock_hour(k)
			now_minute = gettime(5) + bdock_minute(k)
			now_second = gettime(6) + bdock_second(k)
			if(now_second >= 60) :now_minute += now_second / 60 :now_second \= 60
			if(now_minute >= 60) :now_hour += now_minute / 60 :now_minute \= 60
			objprm k * 2 + 9, strf("%02d:%02d:%02d", now_hour, now_minute, now_second)
		}else{
			objprm k * 2 + 9, ""
		}
	next
	for k, 0, kDocks - 1
		objprm k * 2 + 16, strf("%02d:%02d:%02d", edock_hour(k), edock_minute(k), edock_second(k))
		if((edock_hour(k) != 0) || (edock_minute(k) != 0) || (edock_second(k) != 0)){
			now_hour   = gettime(4) + edock_hour(k)
			now_minute = gettime(5) + edock_minute(k)
			now_second = gettime(6) + edock_second(k)
			if(now_second >= 60) :now_minute += now_second / 60 :now_second \= 60
			if(now_minute >= 60) :now_hour += now_minute / 60 :now_minute \= 60
			objprm k * 2 + 17, strf("%02d:%02d:%02d", now_hour, now_minute, now_second)
		}else{
			objprm k * 2 + 17, ""
		}
	next
return

//ソート一覧画面を出す
*show_sort_list
	error_log += NowTime() + ",show_sort_list,\n"
	gsel kSortListWindowID, 2
return
//ソート一覧画面を閉じる
*close_sort_list
	error_log += NowTime() + ",close_sort_list,\n"
	gsel kSortListWindowID, -1
return
//追加
*add_sort_list
	if(SstToStr(JudgeSituation(kPutTempWindowID, 0)) == "ソート画面"){
		error_log += NowTime() + ",add_sort_list,\n"
		;バッファの追加
		buffer kSortIdOffset + sort_list_size, kSortWX, kSortWY
		gcopy kPutTempWindowID, kSortPX, kSortPY, kSortWX, kSortWY
		;リストの追加
		sort_list += NowTime() + "\n"
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
		sort_list_size++
	}
return
//↑
*upper_sort_list
	if((sort_index >= 1) && (sort_index < sort_list_size)){
		error_log += NowTime() + ",upper_sort_list,\n"
		;バッファの入れ替え
		buffer kTempBufferID, kSortWX, kSortWY
		gcopy kSortIdOffset + sort_index - 1, 0, 0, kSortWX, kSortWY
		gsel kSortIdOffset + sort_index - 1
		gcopy kSortIdOffset + sort_index, 0, 0, kSortWX, kSortWY
		gsel kSortIdOffset + sort_index
		gcopy kTempBufferID, 0, 0, kSortWX, kSortWY
		;リストの入れ替え
		notesel sort_list
		noteget text_buffer,  sort_index - 1
		noteget text_buffer2, sort_index
		noteadd text_buffer2, sort_index - 1, 1
		noteadd text_buffer,  sort_index,     1
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
	}
return
//↓
*lower_sort_list
	if((sort_index >= 0) && (sort_index < sort_list_size - 1)){
		error_log += NowTime() + ",lower_sort_list,\n"
		;バッファの入れ替え
		buffer kTempBufferID, kSortWX, kSortWY
		gcopy kSortIdOffset + sort_index + 1, 0, 0, kSortWX, kSortWY
		gsel kSortIdOffset + sort_index + 1
		gcopy kSortIdOffset + sort_index, 0, 0, kSortWX, kSortWY
		gsel kSortIdOffset + sort_index
		gcopy kTempBufferID, 0, 0, kSortWX, kSortWY
		;リストの入れ替え
		notesel sort_list
		noteget text_buffer,  sort_index + 1
		noteget text_buffer2, sort_index
		noteadd text_buffer2, sort_index + 1, 1
		noteadd text_buffer,  sort_index,     1
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
	}
return
//削除
*del_sort_list
	if((sort_index >= 0) && (sort_index < sort_list_size)){
		error_log += NowTime() + ",del_sort_list,\n"
		;バッファの削除
		for k, sort_index, sort_list_size - 1
			gsel kSortIdOffset + k
			gcopy kSortIdOffset + k + 1, 0, 0, kSortWX, kSortWY
		next
		;リストの削除
		notesel sort_list
		notedel sort_index
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
		sort_list_size--
	}
return
//全削除
*alldel_sort_list
	error_log += NowTime() + ",alldel_sort_list,\n"
	sort_list = ""
	gsel kSortListWindowID
	objprm sort_index_id, sort_list
	sort_list_size = 0
return
//画像を出力
*make_sort_list
	error_log += NowTime() + ",make_sort_list,\n"
	;出力用バッファを準備
	ListSizeX = (sort_width_index + 1) * kSortWX
	ListSizeY = sort_list_size / (sort_width_index + 1) * kSortWY
	if(sort_list_size \ (sort_width_index + 1) != 0) :ListSizeY + kSortWY
	buffer kTempBufferID, ListSizeX, ListSizeY
	;バッファに書き込んでいく
	for k, 0, sort_list_size
		x = k \ (sort_width_index + 1)
		y = (k - x) / (sort_width_index + 1)
		pos x * kSortWX, y * kSortWY
		gcopy kSortIdOffset + k, 0, 0, kSortWX, kSortWY
	next
	cvbuffer kCaptureBufferID, ginfo_sx, ginfo_sy
	cvputimg kCaptureBufferID
	cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCaptureBufferID
return
//リストクリックに応じて画像変更
*redraw_sort_preview
	if((sort_index >= 0) && (sort_index < sort_list_size)){
		error_log += NowTime() + ",redraw_sort_preview,\n"
		gsel kSortListWindowID
		pos kObjSpace * 2 + kObjX * 2, kObjSpace
		gzoom2 kObjX * 2, kObjY * 10, kSortIdOffset + sort_index, 0, 0, kSortWX, kSortWY
	}
return

//資材グラフを出す
*show_graph
	error_log += NowTime() + ",show_graph,\n"
	gsel kSupplyGraphID, 2
return
//資材グラフを閉じる
*close_graph
	error_log += NowTime() + ",close_graph,\n"
	gsel kSupplyGraphID, -1
return
//資材グラフを作成する
*make_graph
	error_log += NowTime() + ",make_graph,\n"
	// 日付の最小値・最大値を取り出す
	day_first = ConvertDay(supply_log_int(0, 0))
	day_last  = ConvertDay(supply_log_int(supply_log_size - 1, 0))
	// 資源の最小値・最大値を取り出す
	max_param = supply_log_int(0, 2)
	min_param = supply_log_int(0, 2)
	for n, 0, supply_log_size
		for k, 2, 6
			if(max_param < supply_log_int(n, k)) :max_param = supply_log_int(n, k)
			if(min_param > supply_log_int(n, k)) :min_param = supply_log_int(n, k)
		next
	next
	max_param = ((max_param / 1000) + 1) * 1000
	min_param = ((min_param / 1000) - 1) * 1000 :if(min_param < 0) :min_param = 0
	diff_param = max_param - min_param
	;バケツ
	max_bucket = supply_log_int(0, 6)
	min_bucket = supply_log_int(0, 6)
	for n, 0, supply_log_size
		if(max_bucket < supply_log_int(n, 6)) :max_bucket = supply_log_int(n, 6)
		if(min_bucket > supply_log_int(n, 6)) :min_bucket = supply_log_int(n, 6)
	next
	max_bucket = ((max_bucket / 10) + 1) * 10
	min_bucket = ((min_bucket / 10) - 1) * 10 :if(min_bucket < 0) :min_bucket = 0
	diff_bucket = max_bucket - min_bucket
	// グラフを作成する
	day_diff = day_last - day_first + 1
	block_num = day_diff / scale_blocking(scale_mode)
	if(day_diff \ scale_blocking(scale_mode) != 0) :block_num++
	buffer kGraphBufferID, block_num * kGraphWX, kGraphWY
	//縦線
	font msgothic, kGraphFontSize
	for k, 0, block_num * scale_zooming(scale_mode)
		color $C0,$C0,$C0
		line k * kGraphStepX, 0, k * kGraphStepX, kGraphWY
		color 0, 0, 255
		pos k * kGraphStepX, kGraphWY - kGraphFontSize * 2
		switch scale_mode
			case 0	;1日
				mes strf("%02dh", (k \ 12) * 2)
				swbreak
			case 1	;1週間
				mes strf("%01dd", k \ 7)
				swbreak
			case 2	;2週間
				mes strf("%02dd", (k \ 7) * 2)
				swbreak
			case 3	;1ヶ月
				mes strf("%02dd", (k \ 10) * 3)
				swbreak
			case 4	;2ヶ月
				mes strf("%02dd", (k \ 10) * 6)
				swbreak
			case 5	;3ヶ月
				mes strf("%02dd", (k \ 12) * 7)
				swbreak
			case 6	;半年
				mes strf("%02dm", k \ 6)
				swbreak
			case 7	;1年
				mes strf("%02dm", k \ 12)
				swbreak
		swend
	next
	//横線
	interval_y = 1
	if(diff_param > 10) :interval_y = 10
	if(diff_param > 100) :interval_y = 100
	if(diff_param > 1000) :interval_y = 1000
	if(diff_param > 10000) :interval_y = 10000
	if(diff_param > 100000) :interval_y = 100000
	color $C0,$C0,$C0
	for yy, 0, 500000, interval_y
		if(limit(yy, min_param, max_param) != yy) :_continue
		yy2 = kGraphWY - 1.0 * (yy - min_param) / diff_param * kGraphWY
		line 0, yy2, block_num * kGraphWX, yy2
	next
	;バケツ
	interval_y_b = 1
	if(diff_bucket > 10) :interval_y_b = 10
	if(diff_bucket > 100) :interval_y_b = 100
	if(diff_bucket > 1000) :interval_y_b = 1000
	color $A0,$A0,$F0
	for yy, 0, 5000, interval_y_b
		if(limit(yy, min_bucket, max_bucket) != yy) :_continue
		yy2 = kGraphWY - 1.0 * (yy - min_bucket) / diff_bucket * kGraphWY
		line 0, yy2, block_num * kGraphWX, yy2
	next
	//グラフ線
	;燃料・弾薬・鋼材・ボーキ
	for n, 0, supply_log_size - 1
		for k, 2, 6
			switch k
				case 2	;燃料
					color $00,$80,$00
					swbreak
				case 3	;弾薬
					color $66,$33,$00
					swbreak
				case 4	;鋼材
					color $A0,$A0,$A0
					swbreak
				case 5	;ボーキ
					color $CC,$33,$00
					swbreak
			swend
			p1 = ((ConvertDay(supply_log_int(n, 0)) - day_first) * kGraphWX + ConvertTime(supply_log_int(n, 1)) * kGraphWX) / scale_blocking(scale_mode)
			p2 = kGraphWY - 1.0 * (supply_log_int(n, k) - min_param) / diff_param * kGraphWY
			p3 = ((ConvertDay(supply_log_int(n + 1, 0)) - day_first) * kGraphWX + ConvertTime(supply_log_int(n + 1, 1)) * kGraphWX) / scale_blocking(scale_mode)
			p4 = kGraphWY - 1.0 * (supply_log_int(n + 1, k) - min_param) / diff_param * kGraphWY
			if((zero_interpolation_flg) && (supply_log_int(n + 1, k) == 0)){
				for n2, n + 2, supply_log_size
					if(supply_log_int(n2, k) != 0){
						p3 = ((ConvertDay(supply_log_int(n2, 0)) - day_first) * kGraphWX + ConvertTime(supply_log_int(n2, 1)) * kGraphWX) / scale_blocking(scale_mode)
						p4 = kGraphWY - 1.0 * (supply_log_int(n2, k) - min_param) / diff_param * kGraphWY
						line p1, p2, p3, p4
						n = n2 - 1
						_break
					}
				next
			}else{
				line p1, p2, p3, p4
			}
		next
	next
	;バケツ
	for n, 0, supply_log_size - 1
		color $7B,$BB,$E4
		p1 = ((ConvertDay(supply_log_int(n, 0)) - day_first) * kGraphWX + ConvertTime(supply_log_int(n, 1)) * kGraphWX) / scale_blocking(scale_mode)
		p2 = kGraphWY - 1.0 * (supply_log_int(n, 6) - min_bucket) / diff_bucket * kGraphWY
		p3 = ((ConvertDay(supply_log_int(n + 1, 0)) - day_first) * kGraphWX + ConvertTime(supply_log_int(n + 1, 1)) * kGraphWX) / scale_blocking(scale_mode)
		p4 = kGraphWY - 1.0 * (supply_log_int(n + 1, 6) - min_bucket) / diff_bucket * kGraphWY
		if((zero_interpolation_flg) && (supply_log_int(n + 1, 6) == 0)){
			for n2, n + 2, supply_log_size
				if(supply_log_int(n2, k) != 0){
					p3 = ((ConvertDay(supply_log_int(n2, 0)) - day_first) * kGraphWX + ConvertTime(supply_log_int(n2, 1)) * kGraphWX) / scale_blocking(scale_mode)
					p4 = kGraphWY - 1.0 * (supply_log_int(n2, 6) - min_bucket) / diff_bucket * kGraphWY
					line p1, p2, p3, p4
					n = n2 - 1
					_break
				}
			next
		}else{
			line p1, p2, p3, p4
		}
	next
	//日付
	color 0, 0, 255
	for k, 0, block_num
		pos k * kGraphStepX * scale_zooming(scale_mode), kGraphFontSize
		mes ConvertDay2(day_first + k * scale_blocking(scale_mode))
	next
	// 表示座標を初期化
	plot_graph_px = (block_num - 1) * scale_zooming(scale_mode) * kGraphStepX
return
//資材グラフを表示する
*plot_graph
	gsel kSupplyGraphID
	redraw 0
		;画像
		color $FF, $FF, $FF
		boxf
		pos 0, 0
		gcopy kGraphBufferID, plot_graph_px, 0, kGraphWX, kGraphWY
		;文字
		font msgothic, kGraphFontSize
		color
		pos 0, 0
		mes max_param
		pos 0, kGraphWY - kGraphFontSize
		mes min_param
			pos kGraphWX - strlen(str(max_bucket)) * kGraphFontSize / 2, 0
			mes max_bucket
			pos kGraphWX - strlen(str(min_bucket)) * kGraphFontSize / 2, kGraphWY - kGraphFontSize
			mes min_bucket
	redraw 1
return
//資材グラフのスクショを保存
*save_graph
	error_log += NowTime() + ",save_graph,\n"
	gsel kSupplyGraphID
	cvbuffer kCaptureBufferID, ginfo_sx, ginfo_sy
	cvputimg kCaptureBufferID
	cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCaptureBufferID
return

//資源画像を保存
*save_stock
	if(CheckHomeFlg(kPutTempWindowID)){
		error_log += NowTime() + ",save_stock,\n"
		buffer kTempBufferID, kStockAllWX, kStockAllWY
		pos 0, 0
		gcopy kPutTempWindowID, kStockTimePX, kStockTimePY, kStockTimeWX, kStockTimeWY
		pos kStockTimeWX, 0
		gcopy kPutTempWindowID, kStockOtherPX, kStockOtherPY, kStockOtherWX, kStockOtherWY
		cvbuffer kCVTempBufferID, ginfo_sx, ginfo_sy
		cvputimg kCVTempBufferID
		cvsave pic_save_path(my_folder_flg) + "\\" + AutoFileName(), kCVTempBufferID
		gsel kMainWindowID
	}
return

//オプション画面を閉じる
*close_option
	error_log += NowTime() + ",close_option,\n"
	gsel kOptionWindowID, -1
return
//保存フォルダを参照する
*browse_folder
	selfolder pic_save_path(1), "保存フォルダ..."
	if(strlen(pic_save_path(1)) == 3) :pic_save_path(1) = strmid(pic_save_path(1), 0, 2)	;ドライブ直下対策
	error_log += NowTime() + ",browse_folder," + pic_save_path(1) + "\n"
	gsel kOptionWindowID
	redraw 0
		color 255, 255, 255 :boxf
		color
		font msgothic, kSmallFontSize
			pos kObjSpace                 , kObjSpace + kObjSpaceY * 3 + kObjOffset
				mes pic_save_path(1)
	redraw 1
	gsel kMainWindowID
return
//オプション画面を開く
*show_option
	error_log += NowTime() + ",show_option,\n"
	gsel kOptionWindowID, 2
return

//データセーブ(手動)
*save_soft_data
	error_log += NowTime() + ",save_soft_data,\n"
	notesel error_log
	notesave pic_save_path(0) + "\\soft.log"
	WriteSaveData 1
return

//このソフトについて
*about
	error_log += NowTime() + ",about,\n"
	dialog "ソフト名：" + kSoftName + " " + kSoftVer + "\n作成者：YSR\n最終更新日：" + kSoftLastUpdate,,kSoftName
return

*main2
