※等幅フォントで閲覧してください
【全体の構成】
○ファイル構成
const.hsp……定数宣言と各種初期化担当
│module.hsp……関数定義担当
││window.hsp……サブルーチン担当
↓↓↓
orikou.hsp……本体。画面描画を担当

area_exp.txt……マップ経験値一覧
exp_table.txt……レベル―経験値対応表
scene_list.txt……認識可能なシーン一覧
cursor.png……カーソルアイコン画像

○フローチャート
定数宣言
　↓
各種初期化
　↓
関数定義
　↓
ウィンドウ生成・オブジェクト配置
　↓
メインループ先頭
　　↓
　艦これ画像をスクショ
　　↓
　場面を判定し、あらかじめ用意したバッファに格納する
　　↓
　艦隊における艦娘数を認識し、自動で余計なバッファをクリアする
　　↓
　選択した表示モードに応じて、バッファから画像を取り出す
　　↓
　その画像に名前隠し処理を行い、サブ画面に転送する
　　↓
　その他処理
　・大破チェッカー
　・経験値計算機
　・入渠タイマー
　・BGM機能
　・自動ズレ補正
　・ソート一覧
　・最終更新日時を表示
　・資源グラフ機能
　・自動カウント
　・自動タイマー更新
　　↓
　指定fpsを満たす程度にウェイトを掛ける
　　↓
メインループ末尾(先頭に戻る)

○ソース読解のポイント
・全体
　変数や関数の命名規則……
　　Googleが決めた規則に準じている。つまり、
　　通常変数は小文字+スネークケース(mode_listなど)、
　　自前で定義した定数はk+キャメルケース(kMainWindowIDなど)、
　　関数名はキャメルケース(GetFlashWindowなど)、
　　関数の引数は小文字+スネークケース+アンダーバー(buffer_id_など)。
　　特にHSPは関数の引数と内部で宣言した引数が別扱いなので、
　　アンダーバーで区別しないとそれなりに紛らわしい……。
　　ちなみにモジュールからモジュール外の変数(定数)を読むには
　　@を付ける必要がある(global宣言したものを除く)。
　画面IDの対応表(enumである程度楽しているが)……
　　ID                   意味                 数字
　　kMainWindowID        メイン画面           0
　　kPutWindowID         サブ画面             1
　　kPutTempWindowID     サブ画面用バッファ   2
　　kTempBufferID        テンポラリ画面       3
　　kSelectWindowID      手動指定用画面       4
　　kDeskBufferID        スクショ用           5
　　kFlashBufferID       検索用               6
　　kOptionWindowID      オプション画面       7
　　kExpCalcWindowID     経験値計算機         8
　　kDockWindowID        入渠タイマー         9
　　kCountWindowID       ○号カウンター       10
　　kSortListWindowID    ソート一覧           11
　　kSupplyGraphID       資源グラフ           12
　　kGraphBufferID       資源グラフ用バッファ 13
　　kMatchBufferID       マッチング用の捨てID 14
　　kDeadZoneWindowID    大破進撃阻止用画面   15
　　kNumGetBufferID1     数字認識用           16
　　kCursorBufferID      カーソル用           17
　　kBattleBufferID      戦闘画面(特殊)       18
　　kDropBufferID        ドロップ画面         19
　　kCaptureBufferID以降 シーン保存用         20〜20 + 保存シーン数 - 1
　　kFleetIdOffset以降   編成画面用           20 + 保存シーン数〜17 + 保存シーン数 + (4 - 1)
　　kUnitIdOffset以降    改装画面用           20 + 保存シーン数 + 4〜19 + 保存シーン数 + 4 + (4 * 6 - 1)
　　kSortIdOffset以降    ソート画面用         20 + 保存シーン数 + 4 + 4 * 6〜
・const.hsp
　#enumで定義された定数群……
　　画面IDを決定するためのもの。具体的には、IDがkCaptureBufferID
　　であるもの以降が、上記の「あらかじめ用意したバッファ」に相当する。
　　もちろん編成画面は4枚、改装画面は24枚分のバッファが用意されている。
　オブジェクト関係の定数……
　　この辺を弄ると、画面におけるオブジェクトの表示が変わる。
　　例えばkObjSpaceを増やすと、全体的に隙間が開くようになる。
　認識用変数としてのkPointsとkParams……
　　後者はあまり弄るべきではないが前者は弄ってもよい。
　　たとえ増やしても、ダミーとして同一座標+RGBな設定を増やせば
　　いいだけだからだ。
　get_pos_flg……
　　近くに記述された普通のフラグ(メイン画面用)と異なりこれは、
　　「座標取得」ボタンを押した際にTRUEになる。要するに、自動ズレ補正機能が
　　座標も取得してないのに勝手に発動するのを防ぐためのもの。
　other_get_pos_flg……
　　自動設定・手動設定ではディスプレイ全体のデバイスコンテキストを取得していたが、
　　自動設定IIでは艦これを開いているブラウザのデバイスコンテキストを取得している。
　　この際使用するAPIが変わるので、それをお知らせするためのフラグ。
　get_handle_flg……
　　要するに、ズレ補正で毎回艦これを開いているブラウザをアクティブにするなんか
　　面倒にも程があるので。
　pic_save_path……
　　画像を保存するフォルダ。pic_save_path(0)は従来のcurrent_dirと同じ、
　　pic_save_path(1)は自分で変更できてセーブもされる部分。
　bgm_listやその周辺の変数……
　　現在は「母港」「マップ」「戦闘」の3通りしか想定していないので、
　　増やそうと思えば増やせる。アルゴリズムとしては、
　　「bgm_typeで場面判定」→
　　「bgm_typeが変化し、かつ-1以外なら状況を変更」
　　となるので、例えば工廠でのBGMを設定したい場合、const.hspを弄って
　　工廠の項目を追加し、orikou15.hspを弄って工廠を「bgm_type = 3」、
　　交戦結果や戦果報告を「bgm_type = 4」とでもすればいい。
　　なお、mode_listはコンボボックス用、mode_list2は実行モード用、
　　mode_list3は判定結果用である。
　sort_list……
　　ぶっちゃけ内容はほぼフェイクである。なぜならsort_indexとソート画面を
　　保存したIDとは1:1対応しており、sort_listの中身なんて関係ないからである。
　　「1」「2」だけじゃ味気ないのでとりあえず撮影日時を載せてはいるが。
　supply_log_int……
　　supply_logを読み込んで整数配列にぶち込んでいる。
　　第1引数で縦(時間)・第2引数で横(種類)を表しており、第2引数は
　　日付・時間・燃料・弾薬・鋼材・ボーキの順である。
　*match_init(サブルーチン)……
　　アルゴリズムとしては、
　　「適当に大きな数字を出力」→「大津の方法で二値化」→
　　「数字をギリギリ覆えるぐらいの長方形のサイズと位置を計算」→
　　「上手く切り取って32x32サイズに拡大コピー」→
　　「周囲を赤線で囲うことで判定ミスを阻止させる」
　　といったところ。よく分からない場合は、画面IDがkMatchBufferIDな
　　バッファをbmpsaveなどで表示させてみよう。
・module.hsp
　3つのモジュール名……
　　ぶっちゃけ割と適当。しかしHSPは「モジュール毎に」名前空間が決まる
　　とかいう信じられないクソ仕様(関数で定義した変数がローカルじゃない)
　　なので、一応分けておくことには意味がある。
　　apiモジュールは名前の通りスクショ用のAPIを利用するもの、
　　miscモジュールはその他様々な関数を定義するためのもの、
　　get_numモジュールは画像認識用に自前で書いたもの。
　GetPosFlashSquare……
　　最初に発見した時はビビったが、「デスクトップのスクショ」に、
　　「800x480な灰色画像」をマッチングさせることで艦これの座標が分かる。
　　前Verまでは黒色画像だったが、それだとマルチディスプレイの時に困る
　　(黒領域が多くなるため)ので灰色になった。
　　……と書いていたが、「流星観測機」の制作経験を踏まえて、マッチングさせる
　　画像を「802x482の白画像の中央に800x480の灰色画像を置いた画像」にした。
　　これにより認識精度が上がる、はず。
　NearColorとFarColor……
　　要は、座標とRGB値を引数に入れると、その座標のRGB値を取得し、
　　それが離れすぎているか否かで判定してくれる。このソフトにおける
　　シーン判定は、数点取って色を比較するだけなのでこれで十分なのだ。
　　(「厳密にRGBが一致するとき」で判定してないのは、艦これにおける
　　各アイコンが正確に等間隔とは限らず、またRGB値も微妙に違うため)
　JudgeSituation……
　　何故「judge_type = i + 1」などとイチイチ1を足してるかというと、
　　この関数の返り値が0な時はすなわち「不明」な場面だから。
　　mode_list2およびmode_list3(どちらも文字列の配列)を見れば分かるように、
　　ずらしておかないと「不明」が全部「母港画面」と表示されかねない。
　GetUnits……
　　編成画面と改装画面に分けて判定する。どちらにせよ「ある艦隊に何隻いるか」
　　を末尾からチェックすることで産出することには違いはない。
　　なお、unit_k(更新する艦隊の番号)の計算法がそれぞれ違うので注意。
　WriteSaveData、ReadSaveData……
　　名前の通りだが、前者はあくまでルール通りにセーブするのに対し、
　　後者は「読めるところだけ読む」というのが違っている。具体的には、
　　save.txtの各項目は順不同でもOK(流石にVersionは必須)であり、
　　そのVersionと矛盾するsave.pngはそもそも読み込まないといったもの。
　　なお、画像保存のせいでWriteSaveDataはちょっと重いので注意。
　SetLastUpdateなど最終更新日時関係……
　　見たまんまなので詳細略。ミリ秒まで記録しております
　GetSupply……
　　資源が写ってる画面で自動的に資源量を読み取る。
　ConvertDayとConvertDay2……
　　統一日付とは、1/1/1を「1」として表す統一的な日付のこと。
　　便宜上のものなので全部グレゴリオ暦で計算しているが、
　　どうせ艦これが始まったのはグレゴリオ暦時代なので問題ないだろう。
　　なお、ConvertDay2は見ての通り計算コストが重いが、
　　実際処理させるとさほど重くないのでOKと判断した。
　ConvertTime……
　　10:23:45.789を0.4331688541666666と表す感じ。
　　要するに、「○日」の「○」部分を表すもの。
　OtsuThreshold……
　　大津の方法(判別分析法)によって自動的な二値化を行う。
　　なぜかこの機能の存在がHSPのヘルプにないというのは謎すぎる……。
　　ちなみにcvxorsで色反転が可能(NormalThresholdも同様)
・window.hsp
　*save_fleets……
　　要するに、バッファを切り取ってコピーする作業を6回or12回行い
　　保存する機能。若干数式がややこしいのは仕方ない。
　BGM関係……
　　now_bgmは現在流れているBGM、
　　bgm_type_はメインループの前回におけるbgm_typeを保存しておく変数。
　　また、bgm_index_idはBGMのcomboxのオブジェクトID。
　各種タイマー……
　　各ドックごとに艦娘がいるか否かを判定した後、時間部分を
　　うまく切り取って数字を判定し、タイマーに反映させる。
　　後1秒以上残っていた場合は、定期的にデクリメントさせる。
　　当然、建造ドックと入渠ドックとで変数は分けている。
　　なお、建造ドックは4つとも埋まってる画像を提供してくださった方の
　　お陰で仕上がったが、100％の精度は保証しない。
　ソート一覧……
　　sort_index_idはソート一覧のlistboxのオブジェクトID。
　　実装としてはスタックに近いが、途中の削除も可能。
　　ちなみにソート画面から艦船名とレベルをクロップする際ちょっと右に余らせて
　　いるのは、ギリギリまで詰めるとリストを出力した際、すぐ隣りのリストの
　　艦船名とレベルとが近すぎて見づらいため。さる方がケッコン大和型が載ってる
　　ソート画面を提供してくださったので、その場合でも大丈夫だと証明できた。
　資源グラフ……
　　超横長の画像を生成した後、スクロール時は適宜コピーして表示している。
　　なお、グラフは「最大・最小値部分だけ後で書き足す」ようにしている。
　　(日付・時間帯表示は画像生成時に書き込んでいる)
・orikou.hsp
　now_level_など……
　　経験値計算機にて、レベルなどの操作が即座に反映されるのは、
　　これらの変数で監視し、変化したら即座に再計算しているから。
　大破チェッカー……
　　3つもフラグがあるからややこしいが、要するに
　　　dead_zone_flg→「大破チェック」にチェックが入っているか
　　　dead_zone_flg_→戦果報告画面で大破艦を見つけたか。
　　　　　　　　　　　「不明」以外の他場面に遷移するとFALSEになる
　　　dead_zone_flg__→進撃防止用の白い枠を表示しているか
　　ということ。この白い枠は自動設定II以外ではスクショでも記録されるので注意。
　自動ズレ補正……
　　スレでも書いたが、自動設定IIのAPIを変更したせいで色々と追加されている。
　　で、「自動設定IIでも、セーブされた左上座標がちゃんと効く」という副作用が。
　最終更新日時関係……
　　サブ画面の上の方(画像表示部分)と共に、毎フレームごとに書き換えてるけど、
　　この程度の負荷なんて誤差、だよね？
　資源ログ……
　　timeGetTime()関数で間隔を測って、一定以上経ったら記録する。
　　ただ、戦闘などで設定時間以上に母港から離れた場合は、母港を発見した直後から
　　記録を開始する。また、ソフト起動時も自動で記録される。
　　なお、資源ログが書き込まれる度にグラフも更新される。
　自動カウント……
　　出撃→出撃画面が出てから、マップ画面に切り替わった瞬間にカウント
　　S勝利→勝利Sと完全勝利Sの場合のどちらかが来た瞬間にカウント
　　輸送艦と空母→交戦結果の画面だと、艦娘や敵艦が吹き上げる煙が判定に邪魔なので、
　　　　　　　　　「交戦結果のタイミングで、バッファに保存された戦闘画面の画像を読み取る」
　　　　　　　　　ことにより正確な判定を果たした。なお、空母は「航」「軽母」しか判定
　　　　　　　　　してないので、姫だの鬼だのはガン無視なことに注意。でも仕方ないよね。
　自動タイマー……
　　基本的には「シーン切り替わりを検出して画像読み取り」なのだが、
　　遠征画面だとシーンチェンジの検出が面倒だという問題がある。
　　そこで、読み取れる条件(遠征画面で時間が表示されている状態)の際は
　　あえてwaitを挿入することで負荷を減らす作戦にした。
　ウェイト……
　　awaitは「次にawaitが呼ばれるまでの時間」を指定するので、
　　一定の間隔で刻む必要がある場合に都合がいい。1000が30などで
　　綺麗に割り切れるかといわれると……そこまで厳密でもないでしょ？
　*exit……
　　ソフトが終了する際に呼ばれるルーチン。
　　要するに、誤クリックしても「終了しますか？」と聞くためのルーチン。
　　ちなみにここでいきなりendせずフラグを立てるだけなのは、
　　HSPの実行ランタイムの都合上、Win8だといきなりendした際にランタイムエラーが
　　出てしまうため。要するに急場しのぎ。
・scene_list.txt
　中身はTSV形式(CSVのコンマがタブになったのでTSV)なので、編集は容易かと。
　1行目に説明があるように、1列目以降は判定用の座標+RGBのセット。
　シーンの名前が重複していてもエラーではないので、例えば複数の場面を
　同一名で登録しておけば、それぞれが別バッファに保存され、かつmode_list3で
　読み取った際は同一名となる。
・save.txt
　詳細はformat.txtを参照。
