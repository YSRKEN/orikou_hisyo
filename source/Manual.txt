※等幅フォントで閲覧してください
【全体の構成】
○ファイル構成
const.hsp……定数宣言と各種初期化担当
│module.hsp……関数定義担当
││window.hsp……サブルーチン担当
↓↓↓
orikou15.hsp……本体。画面描画を担当

area_exp.txt……マップ経験値一覧
exp_table.txt……レベル―経験値対応表
scene_list.txt……認識可能なシーン一覧
cursor.png……カーソルアイコン画像

○フローチャート
定数宣言
　↓
各種初期化
　↓
関数定義
　↓
ウィンドウ生成・オブジェクト配置
　↓
メインループ先頭
　　↓
　艦これ画像をスクショ
　　↓
　場面を判定し、あらかじめ用意したバッファに格納する
　　↓
　艦隊における艦娘数を認識し、自動で余計なバッファをクリアする
　　↓
　選択した表示モードに応じて、バッファから画像を取り出す
　　↓
　その画像に名前隠し処理を行い、サブ画面に転送する
　　↓
　その他処理
　・大破チェッカー
　・経験値計算機
　・入渠タイマー
　・BGM機能
　・自動ズレ補正
　　↓
　指定fpsを満たす程度にウェイトを掛ける
　　↓
メインループ末尾(先頭に戻る)

○ソース読解のポイント
・全体
　変数や関数の命名規則……
　　Googleが決めた規則に準じている。つまり、
　　通常変数は小文字+スネークケース(mode_listなど)、
　　自前で定義した定数はk+キャメルケース(kMainWindowIDなど)、
　　関数名はキャメルケース(GetFlashWindowなど)、
　　関数の引数は小文字+スネークケース+アンダーバー(buffer_id_など)。
　　特にHSPは関数の引数と内部で宣言した引数が別扱いなので、
　　アンダーバーで区別しないとそれなりに紛らわしい……。
　　ちなみにモジュールからモジュール外の変数(定数)を読むには
　　@を付ける必要がある(global宣言したものを除く)。
・const.hsp
　#enumで定義された定数群……
　　画面IDを決定するためのもの。具体的には、IDがkCaptureBufferID
　　であるもの以降が、上記の「あらかじめ用意したバッファ」に相当する。
　　もちろん編成画面は4枚、改装画面は24枚分のバッファが用意されている。
　オブジェクト関係の定数……
　　この辺を弄ると、画面におけるオブジェクトの表示が変わる。
　　例えばkObjSpaceを増やすと、全体的に隙間が開くようになる。
　認識用変数としてのkPointsとkParams……
　　後者はあまり弄るべきではないが前者は弄ってもよい。
　　たとえ増やしても、ダミーとして同一座標+RGBな設定を増やせば
　　いいだけだからだ。
　get_pos_flg……
　　近くに記述された普通のフラグ(メイン画面用)と異なりこれは、
　　「座標取得」ボタンを押した際にTRUEになる。要するに、自動ズレ補正機能が
　　座標も取得してないのに勝手に発動するのを防ぐためのもの。
　bgm_listやその周辺の変数……
　　現在は「母港」「マップ」「戦闘」の3通りしか想定していないので、
　　増やそうと思えば増やせる。アルゴリズムとしては、
　　「bgm_typeで場面判定」→
　　「bgm_typeが変化し、かつ-1以外なら状況を変更」
　　となるので、例えば工廠でのBGMを設定したい場合、const.hspを弄って
　　工廠の項目を追加し、orikou15.hspを弄って工廠を「bgm_type = 3」、
　　交戦結果や戦果報告を「bgm_type = 4」とでもすればいい。
　　なお、mode_listはコンボボックス用、mode_list2は実行モード用、
　　mode_list3は判定結果用である。
　*match_init(サブルーチン)……
　　アルゴリズムとしては、
　　「適当に大きな数字を出力」→「大津の方法で二値化」→
　　「数字をギリギリ覆えるぐらいの長方形のサイズと位置を計算」→
　　「上手く切り取って32x32サイズに拡大コピー」→
　　「周囲を赤線で囲うことで判定ミスを阻止させる」
　　といったところ。よく分からない場合は、画面IDがkMatchBufferIDな
　　バッファをbmpsaveなどで表示させてみよう。
・module.hsp
　3つのモジュール名……
　　ぶっちゃけ割と適当。しかしHSPは「モジュール毎に」名前空間が決まる
　　とかいう信じられないクソ仕様(関数で定義した変数がローカルじゃない)
　　なので、一応分けておくことには意味がある。
　　apiモジュールは名前の通りスクショ用のAPIを利用するもの、
　　miscモジュールはその他様々な関数を定義するためのもの、
　　get_numモジュールは画像認識用に自前で書いたもの。
　GetPosFlashSquare……
　　最初に発見した時はビビったが、「デスクトップのスクショ」に、
　　「800x480な灰色画像」をマッチングさせることで艦これの座標が分かる。
　　前Verまでは黒色画像だったが、それだとマルチディスプレイの時に困る
　　(黒領域が多くなるため)ので灰色になった。
　NearColorとFarColor……
　　要は、座標とRGB値を引数に入れると、その座標のRGB値を取得し、
　　それが離れすぎているか否かで判定してくれる。このソフトにおける
　　シーン判定は、数点取って色を比較するだけなのでこれで十分なのだ。
　　(「厳密にRGBが一致するとき」で判定してないのは、艦これにおける
　　各アイコンが正確に等間隔とは限らず、またRGB値も微妙に違うため)
　JudgeSituation……
　　何故「judge_type = i + 1」などとイチイチ1を足してるかというと、
　　この関数の返り値が0な時はすなわち「不明」な場面だから。
　　mode_list2およびmode_list3(どちらも文字列の配列)を見れば分かるように、
　　ずらしておかないと「不明」が全部「母港画面」と表示されかねない。
　　なお、この関数はさりげなく
　GetUnits……
　　編成画面と改装画面に分けて判定する。どちらにせよ「ある艦隊に何隻いるか」
　　を末尾からチェックすることで産出することには違いはない。
　　なお、unit_k(更新する艦隊の番号)の計算法がそれぞれ違うので注意。
　WriteSaveData、ReadSaveData……
　　名前の通りだが、前者はあくまでルール通りにセーブするのに対し、
　　後者は「読めるところだけ読む」というのが違っている。具体的には、
　　save.txtの各項目は順不同でもOK(流石にVersionは必須)であり、
　　そのVersionと矛盾するsave.pngはそもそも読み込まないといったもの。
　　なお、画像保存のせいでWriteSaveDataはちょっと重いので注意。
　OtsuThreshold……
　　大津の方法(判別分析法)によって自動的な二値化を行う。
　　なぜかこの機能の存在がHSPのヘルプにないというのは謎すぎる……。
・window.hsp
　*save_fleets……
　　要するに、バッファを切り取ってコピーする作業を6回or12回行い
　　保存する機能。若干数式がややこしいのは仕方ない。
　BGM関係……
　　now_bgmは現在流れているBGM、
　　bgm_type_はメインループの前回におけるbgm_typeを保存しておく変数。
　入渠タイマー……
　　各ドックごとに艦娘がいるか否かを判定した後、時間部分を
　　うまく切り取って数字を判定し、タイマーに反映させる。
　　後1秒以上残っていた場合は、定期的にデクリメントさせる。
・orikou15.hsp
　now_level_など……
　　経験値計算機にて、レベルなどの操作が即座に反映されるのは、
　　これらの変数で監視し、変化したら即座に再計算しているから。
　ウェイト……
　　awaitは「次にawaitが呼ばれるまでの時間」を指定するので、
　　一定の間隔で刻む必要がある場合に都合がいい。1000が30などで
　　綺麗に割り切れるかといわれると……そこまで厳密でもないでしょ？
　*exit……
　　ソフトが終了する際に呼ばれるルーチン。
　　要するに、誤クリックしても「終了しますか？」と聞くためのルーチン。
・scene_list.txt
　中身はTSV形式(CSVのコンマがタブになったのでTSV)なので、編集は容易かと。
　1行目に説明があるように、1列目以降は判定用の座標+RGBのセット。
　シーンの名前が重複していてもエラーではないので、例えば複数の場面を
　同一名で登録しておけば、それぞれが別バッファに保存され、かつmode_list3で
　読み取った際は同一名となる。
・save.txt
　詳細はformat.txtを参照。
