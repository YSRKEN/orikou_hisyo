/* モジュール */

	#uselib "winmm.dll"
	#cfunc timeGetTime "timeGetTime"

	// API用
	#module api
		// API呼び出し
		#uselib "gdi32.dll"
		#cfunc CreateDC "CreateDCA" sptr,sptr,sptr,int
		#func DeleteDC  "DeleteDC"  int
		#func BitBlt    "BitBlt"    int,int,int,int,int,int,int,int,int
		#uselib "user32.dll"
		#cfunc GetSystemMetrics "GetSystemMetrics" int
		#cfunc GetForegroundWindow   "GetForegroundWindow"
		#func GetWindowRect "GetWindowRect" int, int
		#cfunc GetWindowDC        "GetWindowDC"         int
		#func ReleaseDC     "ReleaseDC"     int, int
		// API用の定数
		#const SRCCOPY    0x00CC0020
		#const CAPTUREBLT 0x40000000
		#const SM_CMONITORS 0x00000050
		#const SM_CXVIRTUALSCREEN 0x0000004E
		#const SM_CYVIRTUALSCREEN 0x0000004F
		#const SM_XVIRTUALSCREEN  0x0000004C
		#const SM_YVIRTUALSCREEN  0x0000004D
		// 各種関数定義
		//座標取得
		#deffunc GetMonitorParam var all_size_x_, var all_size_y_, var all_offset_x_, var all_offset_y_
			all_size_x_ =   GetSystemMetrics(SM_CXVIRTUALSCREEN)
			all_size_y_ =   GetSystemMetrics(SM_CYVIRTUALSCREEN)
			all_offset_x_ = GetSystemMetrics(SM_XVIRTUALSCREEN)
			all_offset_y_ = GetSystemMetrics(SM_YVIRTUALSCREEN)
		return
		//デスクトップキャプチャ
		#deffunc GetDesktopWindow int window_id_
			buffer window_id_, kDispX@, kDispY@
			//デスクトップのデバイスコンテキストを作成する
			hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
			//デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kDispX@, kDispY@, hdc_screen, kOffsetX@, kOffsetY@, SRCCOPY | CAPTUREBLT
			//デバイスコンテキストを削除する
			DeleteDC hdc_screen
			redraw 1
		return
		//デスクトップの一部をキャプチャ
		#deffunc GetFlashWindow int buffer_id_, int flash_px_, int flash_py_
			buffer buffer_id_, kFlashWX, kFlashWY
			//デスクトップのデバイスコンテキストを作成する
			hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
			//デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kFlashWX, kFlashWY, hdc_screen, kOffsetX@ + flash_px_, kOffsetY@ + flash_py_, SRCCOPY | CAPTUREBLT
			//デバイスコンテキストを削除する
			DeleteDC hdc_screen
			redraw 1
		return
		//艦これ画面の自動認識
		#deffunc GetPosFlashSquare int window_id_, int output_buffer_id_, var px_, var py_
			;バッファ1：検索先画像
			gsel window_id_
			cvbuffer window_id_, ginfo_sx, ginfo_sy
			cvputimg window_id_
			//バッファ2:802x482の白画像の中央に800x480の灰色画像を置いた画像
			buffer output_buffer_id_, kFlashWX + 2, kFlashWY + 2
			color 100, 100, 100 :boxf 1, 1, kFlashWX, kFlashWY
			cvbuffer output_buffer_id_, kFlashWX, kFlashWY
			cvputimg output_buffer_id_
			//マッチング処理を行う
			cvmatch px_, py_, CV_TM_SQDIFF, output_buffer_id_, window_id_
			px_ = px_ + 1 :py_ = py_ + 1
		return
		//艦これ画面がずれていないかを調べる
		#defcfunc CheckAutoSet
			buffer kTempBufferID@, kFlashWX + 2, kFlashWY + 2
			if(manual_getpos_flg@ != 2){
				//デスクトップのデバイスコンテキストを作成する
				hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
				//デスクトップの画像をコピーする
				BitBlt hdc, 0, 0, kFlashWX + 2, kFlashWY + 2, hdc_screen, kOffsetX@ + flash_px@ - 1, kOffsetY@ + flash_py@ - 1, SRCCOPY | CAPTUREBLT
				//デバイスコンテキストを削除する
				DeleteDC hdc_screen
			}else{
				if(other_get_pos_flg@){
					hdc_browser = GetWindowDC(handle@)
					BitBlt hdc, 0, 0, kFlashWX + 2, kFlashWY + 2, hdc_browser, flash_px@ - rect@(0) - 1, flash_py@ - rect@(1) - 1, SRCCOPY | CAPTUREBLT
					ReleaseDC handle@, hdc_browser
				}
			}
			//四隅と各辺の中央の色を取得し、1つでも違うものがあればアウト
			pget 0, 0
			check_r = ginfo_r :check_g = ginfo_g :check_b = ginfo_b
			auto_set_flg = FALSE
			check_x.0 = kFlashWX / 2, kFlashWX + 1, kFlashWX + 1, kFlashWX + 1, kFlashWX / 2, 0, 0
			check_y.0 = 0, 0, kFlashWX / 2, kFlashWY + 1, kFlashWY + 1, kFlashWY + 1, kFlashWX / 2
			for k, 0, 7
				pget check_x(k), check_y(k)
				if((check_r != ginfo_r) || (check_g != ginfo_g) || (check_b != ginfo_b)){
					auto_set_flg = TRUE
					_break
				}
			next
		return auto_set_flg
		//艦これを開いているブラウザのハンドルを取得する
		#defcfunc GetKanColleHandle
			gsel kPutWindowID@
			title "5秒以内に艦これの画面をアクティブにしてください..."
			aplsel@ "艦隊これくしょん〜艦これ〜"
			aplact@
			wait 500
		return GetForegroundWindow()
		//ブラウザのクライアント領域のサイズを取得する
		#deffunc GetClientSize int handle_, array rect_
			GetWindowRect handle_, varptr(rect_)
		return
		//艦これを開いているブラウザの画像を取得する
		#deffunc GetKanColleWindow int handle_, int window_id_, int wx_, int wy_
			buffer window_id_, wx_, wy_
			hdc_browser = GetWindowDC(handle_)
			BitBlt hdc, 0, 0, wx_, wy_, hdc_browser, 0, 0, SRCCOPY | CAPTUREBLT
			ReleaseDC handle_, hdc_browser
		return
		//デスクトップの一部をキャプチャ2
		#deffunc GetFlashWindow2 int handle_, int buffer_id_, int flash_px_, int flash_py_
			gsel buffer_id_
			hdc_browser = GetWindowDC(handle_)
			BitBlt hdc, 0, 0, kFlashWX, kFlashWY, hdc_browser, flash_px_ - rect@(0), flash_py_ - rect@(1), SRCCOPY | CAPTUREBLT
			ReleaseDC handle_, hdc_browser
		return
	#global

	// 汎用
	#module misc
		//長方形枠を描画
		#deffunc DrawMouseSquare int mouse_x1_, int mouse_y1_, int mouse_x2_, int mouse_y2_
			if(mouse_x1_ < mouse_x2_){
				square_x1 = mouse_x1_
				square_x2 = mouse_x2_
			}else{
				square_x1 = mouse_x2_
				square_x2 = mouse_x1_
			}
			if(mouse_y1_ < mouse_y2_){
				square_y1 = mouse_y1_
				square_y2 = mouse_y2_
			}else{
				square_y1 = mouse_y2_
				square_y2 = mouse_y1_
			}
			color 0, 255, 255
			line square_x1, square_y1, square_x2, square_y1
			line square_x2, square_y1, square_x2, square_y2
			line square_x2, square_y2, square_x1, square_y2
			line square_x1, square_y2, square_x1, square_y1
		return
		//タイトルバーの文字列を設定
		#deffunc SetTitle
			sdim title_str, 1024
			//実行モード
			title_str += mode_list2@(mode_index@) + " - "
			//判定結果
			if(screen_shot_type@ >= kSceneListSize@ + kFleetNum + 1){
				title_str += "改装画面 - "
			}else{
				if(screen_shot_type@ >= kSceneListSize@ + 1){
					title_str += "編成画面 - "
				}else{
					title_str += mode_list3@(screen_shot_type@) + " - "
				}
			}
			//艦これ画面の座標
			title_str += "(" + flash_px@ + ","  +flash_py@ + ")"
			//反映
			gsel kPutWindowID@
			title title_str
			gsel kMainWindowID@
		return
		//色判定
		#defcfunc NearColor int px_, int py_, int clr_r_, int clr_g_, int clr_b_
			pget px_, py_
			diff_r = ginfo_r - clr_r_
			diff_g = ginfo_g - clr_g_
			diff_b = ginfo_b - clr_b_
			diff = diff_r * diff_r + diff_g * diff_g + diff_b * diff_b
			if(diff < 500) :return TRUE
		return FALSE
		#defcfunc FarColor int scene_type_, int point_index_
			pget mode_filter@(scene_type_, point_index_, 0), mode_filter@(scene_type_, point_index_, 1)
			diff_r = ginfo_r - mode_filter@(scene_type_, point_index_, 2)
			diff_g = ginfo_g - mode_filter@(scene_type_, point_index_, 3)
			diff_b = ginfo_b - mode_filter@(scene_type_, point_index_, 4)
			diff = diff_r * diff_r + diff_g * diff_g + diff_b * diff_b
			if(diff < 500) :return FALSE
		return TRUE
		//状況を判別する
		#defcfunc JudgeSituation int flash_id_
			gsel flash_id_
			//通常の画面
			judge_type = -1
			for i, 0, kSceneListSize@
				type_flg = TRUE
				for j, 0, kPoints
					if(FarColor(i, j)){
						type_flg = FALSE
						_break
					}
				next
				if(type_flg){
					judge_type = i + 1
					_break
				}
			next
			if(judge_type != -1) :return judge_type
			//編成画面
			if(NearColor(420, 118, 195, 180, 169)){
				;左上の旗
				for k, 0, kFleetNum
					if(NearColor(123 + 30 * k, 126, 33, 150, 151)) :return kSceneListSize@ + k + 1
				next
			}
			//改装画面
			;枠の柱
			if(NearColor(300, 172, 241, 191, 119)){
				;左上の旗
				offset = -1
				for k, 0, kFleetNum
					if(NearColor(136 + 30 * k, 122, 33, 150, 151)){
						offset = k * kUnitNum
						_break
					}
				next
				if(offset < 0) :return kTypeUnknown
				;枠
				for k, 0, kUnitNum
					if(NearColor(294, 145 + 54 * k, 255, 102, 29)) :return kSceneListSize@ + kFleetNum + offset + k + 1
				next
			}
		return kTypeUnknown
		//サブ画面にコピー
		#deffunc PutWindowSet int window_id_, int buffer_id_
			//カーソルを擬似的に表示させる(オプション)
			if((cursor_flg@) && ((mode_index@ == kTypeNow))){
				gsel buffer_id_
				mx = ginfo_mx - flash_px@ :my = ginfo_my - flash_py@
				;カーソルを描画する
				color 255, 0, 0
				gmode 4,0,0,256
				pos mx, my
				gcopy kCursorBufferID@, 0, 0, cursor_x@, cursor_y@
				gmode 0
				pos 0, 0
			}
			//サブ画面に画像を転送する
			gsel window_id_
			pos 0, 0
			redraw 0
				gzoom zooming_num@(zooming_index@) * kFlashWX / 100, zooming_num@(zooming_index@) * kFlashWY / 100, buffer_id_, 0, 0, kFlashWX, kFlashWY, 1
			redraw 1
		return
		//現在時刻を取得
		#defcfunc NowTime
		return strf("%04d-%02d-%02d %02d-%02d-%02d.%03d", gettime(0), gettime(1), gettime(3), gettime(4), gettime(5), gettime(6), gettime(7))
		//ファイル名を自動設定
		#defcfunc AutoFileName
			file_name = NowTime()
			exist file_name + ".png"
			if(strsize == -1) :return file_name + ".png"
			number = 1
			while
				exist file_name + "_" + number + ".png"
				if(strsize != -1){
					number++
				}else{
					_break
				}
				wait 5
			wend
		return file_name + "_" + number + ".png"
		//「母港画面」かどうかを判定する(BGM・名前隠し用)
		#defcfunc CheckHomeFlg int flash_id_
			gsel flash_id_
			if(NearColor(665, 42, 83, 159, 73)){		;バケツアイコン
				if(NearColor(736, 61, 172, 128, 95)){	;ボーキアイコン
					return TRUE
				}
			}
		return FALSE
		//「大破した艦娘」がいるかどうかを判定する
		#defcfunc CheckDeadZone int flash_id_, int screen_shot_type_
			if(mode_list3@(screen_shot_type_) == "出撃画面"){
				gsel flash_id_
				flg = FALSE
				for k, 0, kUnitNum
					;大破
					if(NearColor(482, 137 + 50 * k, 251, 114, 94)){
						flg = TRUE
						_break
					}
					;橙疲労+大破
					if(NearColor(482, 137 + 50 * k, 250, 99, 53)){
						flg = TRUE
						_break
					}
					;赤疲労+大破
					if(NearColor(482, 137 + 50 * k, 251, 58, 54)){
						flg = TRUE
						_break
					}
				next
				return flg
			}
			if(mode_list3@(screen_shot_type_) == "戦果報告"){
				gsel flash_id_
				flg = FALSE
				for k, 0, kUnitNum
					if(NearColor(327, 191 + 45 * k, 250, 98, 90)){
						flg = TRUE
						_break
					}
				next
				return flg
			}
		return FALSE
		//選択画面かを判定する
		#defcfunc CheckSelect int flash_id_
			gsel flash_id_
			flg = TRUE
			if(NearColor(164, 217,  93, 182, 226) == FALSE) :flg = FALSE
			if(NearColor(268, 249, 239, 248, 247) == FALSE) :flg = FALSE
			if(NearColor(398, 240,  81, 201, 251) == FALSE) :flg = FALSE
		return flg
		#defcfunc CheckSelect2 int flash_id_
			gsel flash_id_
			flg = TRUE
			if(NearColor(607, 124,  62,  62,  62) == FALSE) :flg = FALSE
			if(NearColor(726, 381, 255, 246, 242) == FALSE) :flg = FALSE
		return flg
		// 艦隊ごとの艦娘数を更新する
		#deffunc GetUnits int flash_id_, int screen_shot_type_, array unit_count__
			gsel flash_id_
			if(screen_shot_type_ >= kSceneListSize@ + kFleetNum + 1){
				//改装画面
				unit_k = (screen_shot_type_ - (kSceneListSize@ + kFleetNum + 1)) / kUnitNum
				unit_count__(unit_k) = 0
				for k, kUnitNum - 1, -1, -1
					if(NearColor(160, 180 + 54 * k, 235, 218, 203) == FALSE){
						if(NearColor(260, 180 + 54 * k, 234, 217, 202) == FALSE){
							//艦娘がいた時点でカウントを終了させる
							unit_count__(unit_k) = k + 1
							_break
						}
					}
				next
			}else{
				//編成画面
				unit_k = screen_shot_type_- (kSceneListSize@ + 1)
				unit_count__(unit_k) = 0
				for k, kUnitNum - 1, -1, -1
					x = k \ 2 :y = k / 2
					if(NearColor(140 + 342 * x, 200 + 113 * y, 255, 242, 238)){
						//艦娘がいた時点でカウントを終了させる
						unit_count__(unit_k) = k + 1
						_break
					}
				next
			}
		return
		// フォルダパスについての判定
		#defcfunc CheckSaveFolder str path_
			sdim path, 260
			path = path_
			dirlist xx, path, 5
		return stat
		// ソフトのデータをセーブする
		#deffunc WriteSaveData
			gsel kPutWindowID@, 2
			title "セーブ中..."
			// テキスト
			sdim output, 32000
			output += "Version\t"        + kSoftVer2@         + "\n"
			output += "ManualPosition\t" + manual_getpos_flg@ + "\n"
			output += "ShowMode\t"       + mode_index@        + "\n"
			output += "ShowFleet\t"      + fleets_index@      + "\n"
			output += "ShowUnit\t"       + units_index@ + "\n"
			output += "SaveUnits\t"      + commands_index@ + "\n"
			output += "HomeBGMMode\t"    + bgm_list_flg@(0) + "\n"
			output += "HomeBGMPath\t"    + bgm_list_filename@(0) + "\n"
			output += "MapBGMMode\t"     + bgm_list_flg@(1) + "\n"
			output += "MapBGMPath\t"     + bgm_list_filename@(1) + "\n"
			output += "BattleBGMMode\t"  + bgm_list_flg@(2) + "\n"
			output += "BattleBGMPath\t"  + bgm_list_filename@(2) + "\n"
			output += "DisableName\t"    + name_disable_flg@ + "\n"
			output += "ShowCursor\t"     + cursor_flg@ + "\n"
			output += "CheckDeadZone\t"  + dead_zone_flg@ + "\n"
			output += "CaptureCrop\t"    + cap_crop_flg@ + "\n"
			output += "AutoPosSet\t"     + auto_set_flg@ + "\n"
			output += "ShutdownSave\t"   + auto_save_flg@ + "\n"
			output += "MySaveFolder\t"   + my_folder_flg@ + "\n"
			output += "SaveFolderPath\t" + pic_save_path@(1) + "\n"
			output += "SupplyLogging\t"  + auto_supply_flg@ + "\n"
			output += "LoggingTime\t" + (logging_index@ + 1) + "\n"
			output += "CounterA1\t"      + a_sortie_count@ + "\n"
			output += "CounterA2\t"      + a_to_boss_count@ + "\n"
			output += "CounterA3\t"      + a_win_boss_count@ + "\n"
			output += "CounterA4\t"      + a_s_win_count@ + "\n"
			output += "CounterR\t"       + r_count@ + "\n"
			output += "CounterI\t"       + i_count@ + "\n"
			output += "GetFps\t"         + fps_index@ + "\n"
			output += "Zooming\t"        + zooming_index@ + "\n"
			output += "FlashPositionX\t" + flash_px@ + "\n"
			output += "FlashPositionY\t" + flash_py@ + "\n"
			;艦隊毎の艦娘数
			for k, 0, kFleetNum
				output += "UnitCount" + (k + 1) + "\t" + unit_count@(k) + "\n"
			next
			;最終更新日時
			for k, 0, kSceneListSize@ + kFleetNum + kFleetNum * kUnitNum + 1
				output += "LastUpdate" + (k + 1) + "\t" + strf("%04d%02d%02d%02d%02d%02d%03d", last_up_date@(k, 0), last_up_date@(k, 1), last_up_date@(k, 2), last_up_date@(k, 3), last_up_date@(k, 4), last_up_date@(k, 5), last_up_date@(k, 6)) + "\n"
			next
			notesel output
			notesave pic_save_path@(0) + "\\save.txt"
			// 資材量
			if(CheckHomeFlg(kFlashBufferID@)){
				GetSupply kFlashBufferID@, supply_list@
				supply_log@ += NowTime() + "," + supply_list@(0) + "," + supply_list@(1) + "," + supply_list@(2) + "," + supply_list@(3) + "\n"
				notesel supply_log@ :notesave "supply.csv"
			}
			// 画像
			buffer kTempBufferID@, kFlashWX * 6, kFlashWY * (kSceneListSize@ + 1)
			for k, 0, kSceneListSize@
				pos 0, k * kFlashWY
				gcopy kCaptureBufferID@ + k, 0, 0, kFlashWX, kFlashWY
			next
			pos 0, kSceneListSize@ * kFlashWY
			gcopy kBattleBufferID@, 0, 0, kFlashWX, kFlashWY
			for k, 0, kFleetNum
				pos kFlashWX, k * kFlashWY
				gcopy kFleetIdOffset@ + k, 0, 0, kFlashWX, kFlashWY
			next
			for i, 0, kFleetNum
				for j, 0, kUnitNum
					pos kFlashWX * (i + 2), j * kFlashWY
					gcopy kUnitIdOffset@ + (i * kUnitNum + j), 0, 0, kFlashWX, kFlashWY
				next
			next
			cvbuffer kCaptureBufferID@, ginfo_sx, ginfo_sy
			cvputimg kCaptureBufferID@
			cvsave pic_save_path@(0) + "\\save.png", kCaptureBufferID@
		return
		// ソフトのデータをロードする
		#deffunc ReadSaveData
			// テキスト
			exist pic_save_path@(0) + "\\save.txt"
			if(strsize == -1) :return
			notesel text_buffer :noteload pic_save_path@(0) + "\\save.txt"
			;とりあえずバージョンを取得する
			read_ver = -1
			for k, 0, notemax
				noteget get, k
				split get, "\t", temp
				if(temp(0) == "Version"){
					read_ver = abs(int(temp(1)))
					_break
				}
			next
			if(read_ver < 0) :return
			;後は上から適当に読み込み
			for k, 0, notemax
				noteget get, k
				split get, "\t", temp
				if(temp(0) == "ManualPosition") :manual_getpos_flg@    = limit(int(temp(1)), 0, 2)
				if(temp(0) == "ShowMode")       :mode_index@           = limit(int(temp(1)), 0, kSceneListSize@ + 3)
				if(temp(0) == "ShowFleet")      :fleets_index@         = limit(int(temp(1)), 0, kUnitNum@ - 1)
				if(temp(0) == "ShowUnit")       :units_index@          = limit(int(temp(1)), 0, kFleetNum@ * kUnitNum@ - 1)
				if(temp(0) == "SaveUnits")      :commands_index@       = limit(int(temp(1)), 0, kFleetNum@ + 1)
				if(temp(0) == "HomeBGMMode")    :bgm_list_flg@(0)      = limit(int(temp(1)), 0, 1)
				if(temp(0) == "HomeBGMPath")    :bgm_list_filename@(0) = temp(1)
				if(temp(0) == "MapBGMMode")     :bgm_list_flg@(1)      = limit(int(temp(1)), 0, 1)
				if(temp(0) == "MapBGMPath")     :bgm_list_filename@(1) = temp(1)
				if(temp(0) == "BattleBGMMode")  :bgm_list_flg@(2)      = limit(int(temp(1)), 0, 1)
				if(temp(0) == "BattleBGMPath")  :bgm_list_filename@(2) = temp(1)
				if(temp(0) == "DisableName")    :name_disable_flg@     = limit(int(temp(1)), 0, 1)
				if(temp(0) == "ShowCursor")     :cursor_flg@           = limit(int(temp(1)), 0, 1)
				if(temp(0) == "CheckDeadZone")  :dead_zone_flg@        = limit(int(temp(1)), 0, 1)
				if(temp(0) == "CaptureCrop")    :cap_crop_flg@         = limit(int(temp(1)), 0, 1)
				if(temp(0) == "AutoPosSet")     :auto_set_flg@         = limit(int(temp(1)), 0, 1)
				if(temp(0) == "CounterA1")      :a_sortie_count@       = abs(int(temp(1)))
				if(temp(0) == "CounterA2")      :a_to_boss_count@      = abs(int(temp(1)))
				if(temp(0) == "CounterA3")      :a_win_boss_count@     = abs(int(temp(1)))
				if(temp(0) == "CounterA4")      :a_s_win_count@        = abs(int(temp(1)))
				if(temp(0) == "CounterR")       :r_count@              = abs(int(temp(1)))
				if(temp(0) == "CounterI")       :i_count@              = abs(int(temp(1)))
				if(temp(0) == "GetFps")         :fps_index@            = limit(int(temp(1)), 0, length(fps_num@) - 1)
				if(temp(0) == "Zooming")        :zooming_index@        = limit(int(temp(1)), 0, length(zooming_num@) - 1)
				if(temp(0) == "FlashPositionX") :flash_px@             = int(temp(1))
				if(temp(0) == "FlashPositionY") :flash_py@             = int(temp(1))
				if(read_ver >= 16){
					if(temp(0) == "ShutdownSave")   :auto_save_flg@        = limit(int(temp(1)), 0, 1)
				}
				if(read_ver >= 18){
					if(strmid(temp(0), 0, 9) == "UnitCount"){
						f = limit(int(strmid(temp(0), 9, strlen(temp(0)) - 9)) - 1, 0, 3)
						unit_count@(k) = f
					}
					if(strmid(temp(0), 0, 10) == "LastUpdate"){
						t = limit(int(strmid(temp(0), 10, strlen(temp(0)) - 10)) - 1, 0, kSceneListSize@ + kFleetNum + kFleetNum * kUnitNum)
						;バージョンによってtにオフセットを掛ける(間違えて上書きされる対策)
						if((read_ver <= 19) && (t >= 16)) :t += 2
						if((read_ver == 20) && (t >= 17)) :t += 1
						;最終更新日時を反映
						last_up_date@(t, 0) = limit(int(strmid(temp(1),  0, 4)), 0, 9999)
						last_up_date@(t, 1) = limit(int(strmid(temp(1),  4, 2)), 0, 12)
						last_up_date@(t, 2) = limit(int(strmid(temp(1),  6, 2)), 0, 31)
						last_up_date@(t, 3) = limit(int(strmid(temp(1),  8, 2)), 0, 23)
						last_up_date@(t, 4) = limit(int(strmid(temp(1), 10, 2)), 0, 59)
						last_up_date@(t, 5) = limit(int(strmid(temp(1), 12, 2)), 0, 59)
						last_up_date@(t, 6) = limit(int(strmid(temp(1), 14, 3)), 0, 999)
					}
				}
				if(read_ver >= 20){
					if(temp(0) == "MySaveFolder")   :my_folder_flg@ = limit(int(temp(1)), 0, 1)
					if(temp(0) == "SaveFolderPath") :pic_save_path@(1) = temp(1)
					;セーブデータについて判定を行う
					if(CheckSaveFolder(pic_save_path@(1)) == FALSE) :pic_save_path@(1) = ""
				}
				if(read_ver >= 202){
					if(temp(0) == "SupplyLogging") :auto_supply_flg@ = limit(int(temp(1)), 0, 1)
					if(temp(0) == "LoggingTime")   :logging_index@  = limit(int(temp(1)), 1, 10) - 1
				}
			next
			;微修正
			for k, 0, 3
				exist bgm_list_filename@(k)
				if(strsize == -1){
					bgm_list_flg@(k) = FALSE
					bgm_list_filename@(k) = "<NONE>"
				}
			next
			// 画像
			exist pic_save_path@(0) + "\\save.png"
			if(strsize == -1) :return
			buffer kTempBufferID@
			picload pic_save_path@(0) + "\\save.png"
			for k, 0, kSceneListSize@
				gsel kCaptureBufferID@ + k
				pos 0, 0
				gcopy kTempBufferID@, 0, k * kFlashWY, kFlashWX, kFlashWY
			next
			gsel kBattleBufferID@
			pos 0, 0
			gcopy kTempBufferID@, 0, kSceneListSize@ * kFlashWY, kFlashWX, kFlashWY
			for k, 0, kFleetNum
				gsel kFleetIdOffset@ + k
				pos 0, 0
				gcopy kTempBufferID@, kFlashWX, k * kFlashWY, kFlashWX, kFlashWY
			next
			for i, 0, kFleetNum
				for j, 0, kUnitNum
					gsel kUnitIdOffset@ + (i * kUnitNum + j)
					pos 0, 0
					gcopy kTempBufferID@, kFlashWX * (i + 2), j * kFlashWY, kFlashWX, kFlashWY
				next
			next
		return
		// 縦横比を一定にしたgzoom
		#deffunc gzoom2 int wx2_, int wy2_, int buffer_id_, int px_, int py_, int wx_, int wy_
			if(wx2_ * wy_ > wy2_ * wx_){
				;より横長の範囲にコピーするので縦を合わせる
				gzoom wx_ * wy2_ / wy_, wy2_, buffer_id_, px_, py_, wx_, wy_, 1
			}else{
				;より縦長の範囲にコピーするので横を合わせる
				gzoom wx2_, wy_ * wx2_ / wx_, buffer_id_, px_, py_, wx_, wy_, 1
			}
		return
		// 時刻を格納するためのラッパー関数
		#deffunc SetLastUpdate int index_
			last_up_date@(index_, 0) = gettime(0)
			last_up_date@(index_, 1) = gettime(1)
			last_up_date@(index_, 2) = gettime(3)
			last_up_date@(index_, 3) = gettime(4)
			last_up_date@(index_, 4) = gettime(5)
			last_up_date@(index_, 5) = gettime(6)
			last_up_date@(index_, 6) = gettime(7)
		return
		// 時刻を表示するためのラッパー関数
		#defcfunc GetLastUpdate int index_
		return strf("%04d-%02d-%02d %02d-%02d-%02d.%03d", last_up_date@(index_, 0), last_up_date@(index_, 1), last_up_date@(index_, 2), last_up_date@(index_, 3), last_up_date@(index_, 4), last_up_date@(index_, 5), last_up_date@(index_, 6))
		// 資源量を取得
		#deffunc GetSupply int flash_id_, array supply_list_
			;燃料
			fuel = 0
			for k, 0, 6
				buffer kTempBufferID@, 7, 11
				gcopy flash_id_, 683 + k * 7, 36, 7, 11
				number = MatchNumber(150, TRUE)
				;assert
				if(number < 10){
					fuel *= 10
					if(k == 0) :number = limit(number, 0, 3)
					fuel += number
				}
			next
			;弾薬
			ammo = 0
			for k, 0, 6
				buffer kTempBufferID@, 8, 11
				gcopy flash_id_, 680 + k * 8, 55, 8, 11
				number = MatchNumber(150, TRUE)
				;assert
				if(number < 10){
					ammo *= 10
					if(k == 0) :number = limit(number, 0, 3)
					ammo += number
				}
			next
			;鋼材
			steel = 0
			for k, 0, 6
				buffer kTempBufferID@, 8, 11
				gcopy flash_id_, 749 + k * 8, 36, 8, 11
				number = MatchNumber(150, TRUE)
				;assert
				if(number < 10){
					steel *= 10
					if(k == 0) :number = limit(number, 0, 3)
					steel += number
				}
			next
			;ボーキ
			bauxite = 0
			for k, 0, 6
				buffer kTempBufferID@, 8, 11
				gcopy flash_id_, 749 + k * 8, 55, 8, 11
				number = MatchNumber(150, TRUE)
				;assert
				if(number < 10){
					bauxite *= 10
					if(k == 0) :number = limit(number, 0, 3)
					bauxite += number
				}
			next
			;代入
			supply_list_(0) = fuel
			supply_list_(1) = ammo
			supply_list_(2) = steel
			supply_list_(3) = bauxite
		return
	#global
	#module get_num
		#deffunc DrawSquare int px_, int py_, int wx_, int wy_
			color 255, 0, 0
			line px_ + wx_, py_, px_, py_
			line px_ + wx_ - 1, py_ + wy_, px_ + wx_ - 1, py_
			line px_ + wx_ - 1, py_ + wy_ - 1, px_ , py_ + wy_ - 1
			line px_      , py_ + wy_, px_      , py_
		return
		#deffunc OtsuThreshold int reverse_flg_
			cvbuffer kCVTempBufferID, ginfo_sx, ginfo_sy
			cvputimg kCVTempBufferID
			cvconvert 0, kCVTempBufferID
			if(reverse_flg_) :cvxors ,,,kCVTempBufferID
			cvthreshold CV_THRESH_OTSU, 0, 255, kCVTempBufferID
			cvgetimg kCVTempBufferID, 1
		return
		#deffunc NormalThreshold int thres_, int reverse_flg_
			cvbuffer kCVTempBufferID, ginfo_sx, ginfo_sy
			cvputimg kCVTempBufferID
			cvconvert 0, kCVTempBufferID
			if(reverse_flg_) :cvxors ,,,kCVTempBufferID
			cvthreshold CV_THRESH_BINARY, thres_, 255, kCVTempBufferID
			cvgetimg kCVTempBufferID, 1
		return
		#deffunc GetSquare var px__, var py__, var wx__, var wy__
			for x, 0, ginfo_sx
				flg = FALSE
				for y, 0, ginfo_sy
					pget x, y
					if(ginfo_r == 0) :flg = TRUE :_break
				next
				if(flg) :px__ = x :_break
			next
			for y, 0, ginfo_sy
				flg = FALSE
				for x, 0, ginfo_sx
					pget x, y
					if(ginfo_r == 0) :flg = TRUE :_break
				next
				if(flg) :py__ = y :_break
			next
			for x, ginfo_sx - 1, -1, -1
				flg = FALSE
				for y, 0, ginfo_sy
					pget x, y
					if(ginfo_r == 0) :flg = TRUE :_break
				next
				if(flg) :wx__ = x - px__ + 1 :_break
			next
			for y, ginfo_sy - 1, -1, -1
				flg = FALSE
				for x, 0, ginfo_sx
					pget x, y
					if(ginfo_r == 0) :flg = TRUE :_break
				next
				if(flg) :wy__ = y - py__ + 1 :_break
			next
		return
		#defcfunc MatchNumber_ int thres_, int reverse_flg_
			id = ginfo_sel :sx = ginfo_sx :sy = ginfo_sy
			gsel kNumGetBufferID :color 255, 255, 255 :boxf
			pos 0, 0
			gzoom kMatchSize, kMatchSize, id, 0, 0, sx, sy, 1
			if(thres_ < 0){
				OtsuThreshold reverse_flg_
			}else{
				NormalThreshold thres_, reverse_flg_
			}
			GetSquare px, py, wx, wy
			;常識的に考えて、面積が小さすぎると数字として成り立たないよね？
			if((wx * 2 < kMatchSize) || (wy * 2 < kMatchSize)){
				return 10
			}
			;
			gsel kNumGetBufferID
			pos 0, 0
			gzoom kMatchSize, kMatchSize, kNumGetBufferID, px, py, wx, wy
			;bmpsave "hoge_" + strf("%05d", ttt@) + ".bmp"
			;ttt@++
			OtsuThreshold FALSE
			DrawSquare 0, 0, kMatchSize, kMatchSize
			cvbuffer kCVNumBufferID, kMatchSize, kMatchSize
			cvputimg kCVNumBufferID
			cvmatch px, py, CV_TM_SQDIFF, kCVNumBufferID, kCVMatchBufferID
		return limit(int(1.0 * px / (2 * kMatchSize) + 0.5), 0, 11)
		#defcfunc MatchNumber int thres_, int reverse_flg_
			number = MatchNumber_(thres_, reverse_flg_)
			if(number == 11) :number = 1	;暫定的な仕様
		return number
	#global
