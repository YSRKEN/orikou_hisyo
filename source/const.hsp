/* 定数宣言 */

/* ウィンドウ・バッファ */
	// 画面ID
	//ウィンドウ
	#enum global kMainWindowID = 0	;メイン画面のID
	#enum global kSubWindowID		;サブ画面のID
	#enum global kOptionWindowID	;オプション画面のID
	#enum global kTimerWindowID		;各種タイマー画面のID
	#enum global kSortListWindowID	;ソート一覧画面のID
	#enum global kSupplyGraphWindowID	;資材グラフ画面のID
	#enum global kExpCalcWindowID	;経験値計算機のID
	#enum global kCounterWindowID	;○号カウンタのID
	#enum global kCondMeterWindowID	;cond値メータのID
	#enum global kBgmWindowID		;BGM機能のID
	;↑マウスで動かせるのはここまで
	#enum kSelectWindowID			;選択画面のID
	#enum global kStopperWindowID	;進撃/出撃ストッパー画面用ID
	#enum global kLockerWindowID	;ロック/ロック解除ストッパー画面用ID
	//バッファ
	#enum kDesktopBufferID			;デスクトップのスクショを保存するためのID
	#enum global kFlashBufferID		;艦これの画面を探すためのID
	#enum global kCheckBufferID		;座標ズレを検出するためのID
	#enum global kMainBufferID		;艦これの画面を取得するためのID
	#enum global kSubBufferID		;サブ画面に表示するためのID
	#enum global kSortListBufferID	;ソート一覧を保存するためのID(艦娘)
	#enum global kSort2ListBufferID	;ソート一覧を保存するためのID(装備)
	#enum global kTempBufferID		;テンポラリ用バッファID
	#enum global kGraphBufferID		;グラフ描画用バッファID
	#enum global kSaveBufferID		;セーブ用バッファID
	#enum global kNumGetBufferID	;画像認識用ID
	;↑kSceneBufferID以外の全ての画面IDはここまで
	#enum global kSceneBufferID		;各シーン保存用ID
	// OpenCVの画面ID
	#enum global kCVDesktopBufferID = 0
	#enum global kCVFlashBufferID
	#enum global kCVSaveBufferID
	#enum global kCVTempBufferID
	#enum global kCVMatchBufferID
	#enum global kBossJudgeBufferID1	;赤い四角形
	#enum global kBossJudgeBufferID2	;緑の四角形
	#enum global kBossJudgeBufferID3	;マップ画像

/* インターフェース */
	// マクロ
	#define ctype POS_X(%1)  (%1) * kObjX + ((%1) + 1) * kSpace
	#define ctype POS_XX(%1)  (%1) * kObjX2 + ((%1) + 1) * kSpace
	#define ctype POS_Y(%1)  (%1) * kObjY + ((%1) + 1) * kSpace
	#define ctype SIZE_X(%1) (%1) * kObjX + ((%1) - 1) * kSpace
	#define ctype SIZE_X2(%1) (%1) * kObjX2 + ((%1) - 1) * kSpace
	#define ctype SIZE_Y(%1) (%1) * kObjY + ((%1) - 1) * kSpace
	#define POS_XY(%1, %2) pos POS_X(%1), POS_Y(%2)
	#define POS_X2Y(%1, %2) pos POS_XX(%1), POS_Y(%2)
	// 各種オブジェクトのサイズ
	;ボタン等のオブジェクトのサイズ
	#const kObjX  80
	#const kObjX2 1.5 * kObjX
	#const kObjY 20
	#const kSpace 8
	#const global kStatusBarY 48
	;各種画面のサイズ
	#const kTimerWX 250
	#const kTimerWY 250
	;艦これの画面のサイズ
	#const global kFlashWX 800
	#const global kFlashWY 480
	;編成画面のサイズ・オフセット座標
	#const kFleetWX 684
	#const kFleetWY 368
	#const kFleetPX 110
	#const kFleetPY 96
	;改装画面(通常画面)のサイズ・オフセット座標
	#const kUnitWX 455
	#const kUnitWY 365
	#const kUnitPX 330
	#const kUnitPY 100
	;改装画面(改修画面)のサイズ・オフセット座標
	#const kUnitWX2 356
	#const kUnitWY2 375
	#const kUnitPX2 116
	#const kUnitPY2 95
	;ソート画面のサイズ・オフセット座標
	#const kSortWX 194
	#const kSortWY 279
	#const kSortPX 398
	#const kSortPY 154
	#const kSort2WX 198
	#const kSort2WY 300
	#const kSort2PX 200
	#const kSort2PY 130
	;資源画像用のパラメータ
	#const kStockAllWX 229	;全体のサイズ
	#const kStockAllWY 60
	#const kStockTimePX 9	;時刻部分の左上座標
	#const kStockTimePY 407
	#const kStockTimeWX 86	;時刻部分のサイズ
	#const kStockTimeWY kStockAllWY	
	#const kStockOtherPX 657	;資源部分の左上座標
	#const kStockOtherPY 9
	#const kStockOtherWX kStockAllWX - kStockTimeWX	;資源部分のサイズ
	#const kStockOtherWY kStockAllWY
	;資材グラフ用のパラメータ
	#const kGraphWX 5
	#const kGraphWY 10
	#const kGraphWX2 SIZE_X(kGraphWX)
	#const kGraphWY2 SIZE_Y(kGraphWY)
	#const kSupplyLogKinds 7
	;
	#const kLargeFontSize 30
	#const kSmallFontSize 12
	#const kObjOffset kObjY / 2 - kSmallFontSize / 2
	// 座標取得モード
	#enum global kGetPosAuto = 0	;座標取得方法
	#enum global kGetPosClick
	#enum global kGetPosCrop
	#enum global kGetPosManual
	// キーボード・マウス操作
	#const kStickEscKey 128
	#const kStickMouse  256

/* その他の定数 */
	// 基本
	#const global TRUE  1
	#const global FALSE 0
	// API
	#const WM_NCLBUTTONDOWN $000000A1
	#const HTCAPTION 2
	#const global kRectDim 4	;「座標2つ」「オフセットと座標」における次元数
	#const global kPosDim 2		;「座標1つ」「オフセット」における次元数
	// 画像認識
	#const global kMatchSize 64
	#const kExpPagePer 8		;遠征のページ毎の数
	#const kExpPages 5			;遠征のページ数
	#const global kExpStrLength 128	;遠征データの長さ
	#const global kExpAllPage kExpPages * kExpPagePer
	#const kMaxSortPages 30		;ソート一覧の最大ページ数
	#const kSortListHeight 10	;ソート一覧の縦サイズ
	#const kSortWY2 28			;取得する際の縦幅
	#const kSortWY3 27			;クロップする際の縦幅
	#const kMaxSort2Pages 130	;ソート一覧(装備)の最大ページ数
	#const kSort2ListHeight 10	;ソート一覧(装備)の縦サイズ
	#const kSort2WY2 30			;取得する際の縦幅(装備)
	#const kSort2WY3 30			;クロップする際の縦幅(装備)
	#const kSortType 19			;艦種の種類数
	#const kSortStrLength 40	;艦種データの長さ
	// その他
	#const global kMaxScenePoints 6		;判定に必要な点数の最大値
	#const global kMaxSelectScenes 10	;1カテゴリにおける最大シーン数
	#const global kFleetNum 4	;艦隊数
	#const global kUnitNum  6	;艦隊毎の艦娘数
	#const global kDocks    4	;ドック数
	#const global kMaxYear 2099	;サポートする最大年
	#const global kStopperDeadZone  1	;ストッパー機能
	#const global kStopperExhausted 2
	#const global kLockerKammusu 1	;ロック機能
	#const global kLockerWeapon  2
	#const kBattleType 2	;戦闘の種類(昼戦・夜戦)
	#const global kCounterType 6	;○号カウンタでカウントする種類
	#enum global kBattleRankS = 0
	#enum global kBattleRankA
	#enum global kBattleRankB
	#enum global kBattleRankLoss
	#const global kSupplyLogBlockSize 28
	#const kPutSupplyLogInterval 10.0 / 60 / 24
	#const kAutoSaveInterval 10.0 / 60 / 24
	#const global kBgmKinds 4
	#enum kBgmTypeHome = 0
	#enum kBgmTypeMap
	#enum kBgmTypeBattle
	#enum kBgmTypeBoss

/* 初期設定 */
	// 座標設定
	dim window_param, kRectDim	;ウィンドウのオフセットとサイズ
	dim flash_position, kPosDim	;艦これの画面のオフセット
	get_pos_flg = FALSE
	// ズレ検出用定数(左上・右上・右下・左下・上・右・下・左)
	pos_x1 = kFlashWX / 2 :pos_x2 = kFlashWX + 1
	pos_y1 = kFlashWY / 2 :pos_y2 = kFlashWY + 1
	check_x.0 = 0, pos_x2, pos_x2,      0, pos_x1, pos_x2, pos_x1,      0
	check_y.0 = 0,      0, pos_y2, pos_y2,      0, pos_y1, pos_y2, pos_y1
	move_x.0 = 1, -1, -1,  1,  0, -1,  0,  1
	move_y.0 = 1,  1, -1, -1,  1,  0, -1,  0
	// セーブファイルの保存フォルダを作成
	dirlist x, dir_cur + "\\save", 5
	if(stat == 0) :mkdir dir_cur + "\\save"
	// 画像のデフォルトな保存フォルダを作成
	sdim pic_save_path, 260, 2
	pic_save_path(0) = dir_cur + "\\pic"
	dirlist x, pic_save_path(0), 5
	if(stat == 0) :mkdir pic_save_path(0)
	pic_save_path_flg = FALSE
	// サブ画面の状況
	sdim sub_window_size_list, 1024
		sub_window_size_list = "300%\n200%\n150%\n100%\n75%\n50%\n25%"
	sub_window_size_x.0 = 3 * kFlashWX, 2 * kFlashWX, int(1.5 * kFlashWX), kFlashWX, int(0.75 * kFlashWX), int(0.5 * kFlashWX), int(0.25 * kFlashWX)
	sub_window_size_y.0 = 3 * kFlashWY, 2 * kFlashWY, int(1.5 * kFlashWY), kFlashWY, int(0.75 * kFlashWY), int(0.5 * kFlashWY), int(0.25 * kFlashWY)
	status_y.0 = 3 * kStatusBarY, 2 * kStatusBarY, int(1.5 * kStatusBarY), kStatusBarY, int(0.75 * kStatusBarY), int(0.5 * kStatusBarY), int(0.25 * kStatusBarY)
	//取得fps
	capture_fps.0 = 30, 20, 15, 10, 5, 3, 2, 1
	sdim capture_fps_list, 1024
		for k, 0, length(capture_fps)
			capture_fps_list += "" + capture_fps(k) + "fps\n"
		next
	// 日付変換用
	dim yearplus,13,2
	yearplus(0,0)=0		:yearplus(0,1)=0
	yearplus(1,0)=31	:yearplus(1,1)=31
	yearplus(2,0)=59	:yearplus(2,1)=60
	yearplus(3,0)=90	:yearplus(3,1)=91
	yearplus(4,0)=120	:yearplus(4,1)=121
	yearplus(5,0)=151	:yearplus(5,1)=152
	yearplus(6,0)=181	:yearplus(6,1)=182
	yearplus(7,0)=212	:yearplus(7,1)=213
	yearplus(8,0)=243	:yearplus(8,1)=244
	yearplus(9,0)=273	:yearplus(9,1)=274
	yearplus(10,0)=304	:yearplus(10,1)=305
	yearplus(11,0)=334	:yearplus(11,1)=335
	yearplus(12,0)=365	:yearplus(12,1)=366
	dim year_offset, kMaxYear + 2	;とりあえず2099年まで用意しとけばいいやろ(フラグ)
	for k, 1, kMaxYear + 2
		leap_flg = (k \ 4 == 0) - (k \ 100 == 0) + (k \ 400 == 0)
		year_offset(k) = year_offset(k - 1) + 365 + leap_flg
	next
	// 各種タイマー
	ddim dock_finish_time, kDocks + kDocks + (kFleetNum - 1)	;入渠・建造・遠征終了時刻
	dim dock_finish_flg, kDocks + kDocks + (kFleetNum - 1)		;ラスト1分を切ったかを判定する
	dim expedition_kind, (kFleetNum - 1)						;遠征における遠征の種類
	sdim timer_output, 1024	;各種タイマーを表示するためのバッファ
	//認識に使用する座標
	dck_pos_x.0 = 623, 634, 652, 663, 680, 691
	dck_pos_y.0 = 136, 216, 298, 380
	bld_pos_x.0 = 402, 414, 433, 445, 464, 476
	bld_pos_y.0 = 185, 263, 341, 419
	exp_pos_x.0 = 722, 731, 745, 754, 768, 777
	exp_pos_y   = 387
	//認識に使用する遠征データ
	sdim exped_small_str, kExpStrLength, kExpAllPage	;リスト内の表示
	sdim exped_large_str, kExpStrLength, kExpAllPage	;右上の表示
	sdim exped_name, 64, kExpAllPage					;遠征名
	notesel text_buffer
	noteload "expedition.csv"
	for k, 0, kExpAllPage
		noteget get, k + 1
		split get, ",", temp
		exped_small_str(k) = temp(0)
		exped_large_str(k) = temp(1)
		exped_name(k) = temp(2)
	next
	//認識に使用するテンプレート
	buffer kTempBufferID, kMatchSize * 23, kMatchSize	//テンプレート
	buffer kNumGetBufferID, kMatchSize, kMatchSize		//書き込むためのバッファ
	for k, 0, 10
		// とりあえず数字を出力する
		gsel kNumGetBufferID
		color 255, 255, 255 :boxf
		color :font "Symbol", kMatchSize, 1 :pos 0,0 :mes k
		// 二値化した後、数字の位置および大きさを求める
		cvbuffer kCVTempBufferID, kMatchSize, kMatchSize
		cvputimg kCVTempBufferID
		cvconvert 0, kCVTempBufferID
		cvthreshold CV_THRESH_OTSU, 0, 255, kCVTempBufferID
		cvgetimg kCVTempBufferID
		GetSquare2 px, py, wx, wy
		// テンプレートに向けて拡大コピーする
		gsel kTempBufferID
		pos k * kMatchSize * 2, 0
		gzoom kMatchSize, kMatchSize, kNumGetBufferID, px, py, wx, wy, 1
	next
	//テンプレートを二値化して、黒塗りの領域("11")を別途用意する
	cvbuffer kCVMatchBufferID, kMatchSize * 23, kMatchSize
	cvputimg kCVMatchBufferID
	cvconvert 0, kCVMatchBufferID
	cvthreshold CV_THRESH_OTSU, 0, 255, kCVMatchBufferID
	cvgetimg kCVMatchBufferID
	color :boxf kMatchSize * 22, 0, kMatchSize * 23, kMatchSize
	for k, 0, 12
		DrawSquare k * kMatchSize * 2, 0
	next
	//CVバッファ側に書き込む
	cvbuffer kCVMatchBufferID, kMatchSize * 23, kMatchSize
	cvputimg kCVMatchBufferID
	// ソート画面認識用のデータ
	sdim sort_type_str, kSortStrLength, kSortType	;左側の表示
	sdim sort_type_name, 64, kSortType				;それの日本語Ver
	notesel text_buffer
	noteload "sort_type.csv"
	for k, 0, kSortType
		noteget get, k + 1
		split get, ",", temp
		sort_type_str(k) = temp(0)
		sort_type_name(k) = temp(1)
	next
	sort_pos_x.0 = 163, 172
	sort_pos_y.0 = 0, 28, 55, 83, 111, 139, 167, 195, 223, 251
	// ソート一覧
	sdim sort_list, 1024, 2
	sort_list_size.0 = 0, 0
	sort_key_flg = FALSE
	sdim sort_kind_name, 64, 2
	sort_kind_name.0 = "艦娘", "装備"
	// 経験値計算機
	sdim level_list, 1024
		for k, 1, 150 + 1
			level_list += "" + k + "\n"
		next
	sdim area_list, 1024
		notesel text_buffer
		noteload "area_exp.csv"
		dim exp_data, notemax
		repeat notemax
			noteget get, cnt
			split get, ",", temp
			area_list += temp(0) + "\n"
			exp_data(cnt) = int(temp(1)) 
		loop
		noteload "exp_table.csv"
		dim need_exp_table, notemax
		repeat notemax
			noteget get ,cnt
			need_exp_table(cnt) = int(get)
		loop
	sdim unit_list, 1024
		for k, 1, kUnitNum + 1
			unit_list += "第" + k + "番艦\n"
		next
	unit_pos_x.0 = 261, 270
	// ○号カウンタ
	dim auto_count_flg, kCounterType
	dim count_num, kCounterType
	sdim counter_output, 1024
	exercises_flg = FALSE
	;ボス判定用
	buffer kTempBufferID, 5, 5
		color 219,24,24 :boxf
			cvbuffer kBossJudgeBufferID1, 5, 5	;赤色
				cvputimg kBossJudgeBufferID1
		color 158,229,97 :boxf
			cvbuffer kBossJudgeBufferID2, 5, 5	;緑色
				cvputimg kBossJudgeBufferID2
	cvbuffer kBossJudgeBufferID3, kFlashWX, kFlashWY
	boss_battle_flg = FALSE
	// cond値メータ
	dim cond, kUnitNum
	sdim cond_msg, 645, kUnitNum
		for k, 0, kUnitNum
			cond(k) = 49
		next
	cond_step = 0
	auto_calc_flg = TRUE
	// 資材ログ機能
	// 日時・燃料・弾薬・鋼材・ボーキ・高速修復材・開発資材・司令部レベルをロギングする。
	// 1データに(2+1+1+1+1+1)+4*4+2*2+1=28Byteとすれば1MiBで37449件も記録できる。
	// 1件につき10分間隔とすると260日分。ただ、件数も記録しておけば、毎回再確保して
	// 延々とロギング可能。
	dim supply_list, kSupplyLogKinds
	supply_log_size = 0
	sdim supply_log, 64	;64は適当なサイズ
	supply_last_time = 0.0
	supply_pos_x1.0 = 680, 689, 697, 704, 712, 719	;燃料と弾薬
	supply_pos_x2.0 = 749, 758, 766, 773, 781, 788	;鋼材とボーキ
	supply_pos_x3.0 = 695, 704, 713, 722	;高速修復材
	supply_pos_x4.0 = 760, 769, 778, 787	;開発資材
	supply_pos_x5.0 = 395, 404, 413			;司令部レベル
	graph_scale_interval.0 = 1.0, 7.0, 14.0, 30.0, 60.0, 90.0, 180.0, 365.0
	// BGM機能
	dim bgm_index, kBgmKinds
	for k, 0, kBgmKinds
		bgm_index(k) = -1
	next
	dim bgm_flg, kBgmKinds
	sdim bgm_list, 1024, kBgmKinds
	sdim bgm_list_size, kBgmKinds
	sdim bgm_name_list, 1024, kBgmKinds
	bgm_type_now = -1
	sdim battle_bgm_text, 1024
	battle_bgm_text = "交戦形態 昼戦画面 夜戦画面 砲撃・連撃 対空カットイン 昼カットイン 昼カットイン 魚雷カットイン 主砲カットイン 砲雷カットイン 中破画面 大破画面"
	home_bgm_text1 = "母港画面 母港画面 編成画面 改装画面 工廠画面 入渠画面 補給画面 戦績表示 アイテム 任務画面 遠征出撃"
	home_bgm_text2 = "演習個別 艦隊選択"
	// その他の初期設定
	sdim soft_log, 32000
	exe_path = dir_cur
	sdim scene_result, 64, kPosDim
	save_buffer_turn = 10	;セーブデータにおける縦の最大枚数
	dim hwnd_window, 10		;マウスで動かせるようにするウィンドウのハンドル
	dim unit_count, kFleetNum	;各艦隊の艦娘数
	sdim status_bar_str, 1024	;ステータスバーに表示する文字列
	dim battle_index, kBattleType	;各画面のインデックス
