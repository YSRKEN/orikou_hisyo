/* イベント処理 */

//*情報表示
*about
	sdim about_info, 1024
	// ソフトウェア情報
	about_info += "ソフト名：" + kSoftName + "\n"
	about_info += "バージョン：" + kVersion + "\n"
	about_info += "作者：YSR\n"
	about_info += "最終更新日：" + kLastUpdate + "\n"
	// 練度表示
	if((scene_result(0) == "編成画面") && (strmid(scene_result(1), 0, 2) == "第")){
		dim level_temp, kUnitNum
		// 画像から練度を読み取る
		for k, 0, kUnitNum
			gsel kMainBufferID
			x = k \ 2
			y = k / 2
			pget 342 * x + 256, 113 * y + 153
			if(ginfo_r >= 128){
				level_temp(k) = 100
			}else{
				level_temp(k) = 0
			}
			dim number, 2
			unit_pos_x_.0 = 342 * x + unit_pos_x(0), 342 * x + unit_pos_x(1)
			ReadNumber number, 2, unit_pos_x_, 113 * y + 149, 8, 12, 85, TRUE
			NormalizeLevel number
			level_temp(k) += number(0) * 10 + number(1)
		next
		about_info += "旗艦連度：" + level_temp(0) + "\n"
		sum = 0
		for k, 0, kUnitNum
			sum += level_temp(k)
		next
		about_info += "艦隊総連度：" + sum + "\n"
	}
	dialog about_info
return

//*シーンが切り替わった際に行う処理
*check_scene_change
	// ○号カウンタ
	//演習中であることを検出する
	if((scene_result(0) == "演習出撃") && (scene_result(1) == "陣形選択")){
		exercises_flg = TRUE
	}
	if(scene_result(0) == "母港画面"){
		exercises_flg = FALSE
	}
	//自動カウント処理
	gosub *counter_auto
	// BGM機能
	//現在の状況を更新する
	gosub *check_bgm_type
return

//*サブ画面下の表示を更新する
*redraw_status_bar
	if(show_status_flg == FALSE) :return
	redraw 0
		// 消去する
		color $FF, $FF, $FF
		boxf 0, sub_window_size_y@(sub_window_size_index@), sub_window_size_x@(sub_window_size_index@), sub_window_size_y@(sub_window_size_index@) + show_status_flg@ * status_y@(sub_window_size_index@)
		// 書き込むための内容を準備する
		;最終更新日時
		status_bar_str = ""
		if(scene_list_index == 0){
			status_bar_str += CnvStrTime(flash_time)
		}else{
			status_bar_str += CnvStrTime(show_scene_list_time(scene_list_index - 1))
		}
		;艦隊数
		status_bar_str + = " ("
		for k, 0, kFleetNum
			if(k != 0) :status_bar_str += ", "
			status_bar_str += "" + unit_count(k)
		next
		status_bar_str += ")"
		// 書き込む
		color
		pos 0, sub_window_size_y@(sub_window_size_index@) - 2
		font "Symbol", status_y@(sub_window_size_index@) - 2
		mes status_bar_str
	redraw 1
return

//*オプション画面を表示する
*show_option
	gsel kOptionWindowID, 2
return

//*画像の保存パスを指定する
*browse_pic
	selfolder pic_save_path(1),"保存先フォルダ"
	gsel kOptionWindowID
	objprm pic_save_path_id, pic_save_path(1)
return

//*名前隠し処理
//CheckHomeFlg関数とかでkMainBufferIDではなくkSubBufferIDを引数にしているのは、
//CheckHomeFlg関数が描画先を変更する関数なので、毎回gselするのが面倒だから
*name_disable_filter
	// 母港左上の提督名
	if(CheckHomeFlg(kSubBufferID)){
		color 38, 38, 38
		boxf 111, 0, 273, 25
	}
	// その他特殊な画面に対する処理
	if(scene_result2(1) == "艦隊司令部情報"){
		color 241, 234, 221
		boxf 201, 123, 496, 153
	}
	if(scene_result2(1) == "ランキング"){
		color 54, 54, 54
		boxf 225, 153, 375, 451
	}
	if(scene_result2(1) == "演習一覧"){
		color 225, 209, 181
		boxf 338, 178, 503, 192
		color 237, 223, 207
		boxf 338, 233, 503, 247
		color 225, 209, 181
		boxf 338, 288, 503, 302
		color 237, 223, 207
		boxf 338, 343, 503, 357
		color 225, 209, 181
		boxf 338, 398, 503, 412
	}
	if(scene_result2(1) == "演習個別"){
		color 246, 239, 228
		boxf 130, 87, 425, 117
	}
	if((scene_result2(1) == "交戦結果") || (scene_result2(1) == "戦闘判定")){
		color 37, 44, 47
		boxf 92, 82, 264, 106
	}
	if((scene_result2(0) == "出撃経過") && (scene_result2(1) == "戦果報告")){
		color 37, 44, 47
		boxf 56, 82, 228, 106
	}
	if((scene_result2(0) == "遠征出撃") && (scene_result2(1) == "戦果報告")){
		color 37, 44, 47
		boxf 65, 78, 237, 102
	}
return

//*大破・消耗チェック
*check_stopper
	logmes "" + show_stopper_flg1 + " " + show_stopper_flg2 + " " + CheckStopperType()
	ShowStopperWindow stopper_type	//ウィンドウ表示
	if(show_stopper_flg1){
		// 表示を無くすかどうかの判定
		if(show_stopper_flg2){
			if((check_deadzone_flg == FALSE) && (stopper_type == kStopperDeadZone)){
				show_stopper_flg1 = FALSE
				show_stopper_flg2 = FALSE
				gsel kStopperWindowID, -1
			}
			if((check_exhausted_flg == FALSE) && (stopper_type == kStopperExhausted)){
				show_stopper_flg1 = FALSE
				show_stopper_flg2 = FALSE
				gsel kStopperWindowID, -1
			}
			if((CheckStopperType() == 0) && (scene_result(1) != "進撃確認")){
				show_stopper_flg1 = FALSE
				show_stopper_flg2 = FALSE
				gsel kStopperWindowID, -1
			}
		}else{
			if(((check_deadzone_flg) && (stopper_type == kStopperDeadZone)) || ((check_exhausted_flg) && (stopper_type == kStopperExhausted))){
				ShowStopperWindow stopper_type
			}
		}
	}else{
		// まだ表示していない場合の処理
		stopper_type = CheckStopperType()
		switch stopper_type
			case kStopperDeadZone
				if(check_deadzone_flg){
					PutLog "【大破・消耗チェック】"
					PutLog "判定結果：大破状態"
					TasktrayPopup2 "艦娘が大破しています", kSoftName, 2, 1000
					show_stopper_flg1 = TRUE
				}
			swbreak
			case kStopperExhausted
				if(check_exhausted_flg){
					PutLog "【大破・消耗チェック】"
					PutLog "判定結果：消耗状態"
					TasktrayPopup2 "艦娘が消耗しています", kSoftName, 2, 1000
					show_stopper_flg1 = TRUE
				}
			swbreak
		swend
	}
return

//*ロックチェック
*check_locker
	ShowLockerWindow locker_type	//ウィンドウ表示
	if(show_locker_flg1){
		// 表示を無くすかどうかの判定
		if(show_locker_flg2){
			locker_type = CheckLockerType()
			switch locker_type
				case kLockerKammusu
					gsel kLockerWindowID
					pos 0, 0
					gcopy kMainBufferID, 737, 154, 40, 280
					color 255, 0, 0
					DrawLargeSquare 0, 0, 40 - 1, 280 - 1
				swbreak
				case kLockerWeapon
					gsel kLockerWindowID
					pos 0, 0
					gcopy kMainBufferID, 770, 132, 30, 300
					color 255, 0, 0
					DrawLargeSquare 0, 0, 30 - 1, 300 - 1
				swbreak
			swend
			if((kammusu_lock_flg == FALSE) && (locker_type == kLockerKammusu)){
				show_locker_flg1 = FALSE
				show_locker_flg2 = FALSE
				gsel kLockerWindowID, -1
			}
			if((weapon_lock_flg == FALSE) && (locker_type == kLockerWeapon)){
				show_locker_flg1 = FALSE
				show_locker_flg2 = FALSE
				gsel kLockerWindowID, -1
			}
			if(CheckLockerType() == 0){
				show_locker_flg1 = FALSE
				show_locker_flg2 = FALSE
				gsel kLockerWindowID, -1
			}
		}else{
			if(((kammusu_lock_flg) && (stopper_type == kLockerKammusu)) || ((weapon_lock_flg) && (stopper_type == kLockerWeapon))){
				ShowLockerWindow locker_type
			}
		}
	}else{
		// まだ表示していない場合の処理
		locker_type = CheckLockerType()
		switch locker_type
			case kLockerKammusu
				if(kammusu_lock_flg){
					show_locker_flg1 = TRUE
				}
			swbreak
			case kLockerWeapon
				if(weapon_lock_flg){
					show_locker_flg1 = TRUE
				}
			swbreak
		swend
	}
return

/* 座標習得に関する処理 */
//*艦これの画面の座標とハンドルを取得する
*get_pos
	PutLog "【座標取得】"
	// デスクトップのスクリーンショットを取得する
	dim desktop_param, kRectDim	;モニタ全体のオフセットとサイズ
	GetDesktopParam desktop_param
	DesktopScreenShot kDesktopBufferID, desktop_param
	// そこから艦これの画面を探す
	dim flash_point, kPosDim	;艦これの画面内部の座標
	switch get_pos_mode
		// オート
		case kGetPosAuto
			;艦これの画面を直接探す
			FlashPositionSearch kDesktopBufferID, flash_position
			flash_point(0) = desktop_param(0) + flash_position(0) + kFlashWX / 2
			flash_point(1) = desktop_param(1) + flash_position(1) + kFlashWY / 2
		swbreak
		// クリック
		case kGetPosClick
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面をクリックして下さい。(Escで終了)"
			mouse_click_flg = FALSE
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog "キャンセルされました。"
					break
				}
				if(key & kStickMouse){
					flash_point(0) = ginfo(0)
					flash_point(1) = ginfo(1)
					mouse_click_flg = TRUE
					break
				}
				wait 5
			loop
			gsel kSelectWindowID, -1
		swbreak
		// クロップ
		case kGetPosCrop
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面を選択して下さい。(Escで終了)"
			mouse_button_flg = FALSE
			mouse_crop_flg = FALSE
			dim rect, kRectDim
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog "キャンセルされました。"
					gsel kSelectWindowID, -1
					break
				}
				if(key & kStickMouse){
					if(mouse_button_flg){
						// 選択途中
						redraw 0
							pos 0, 0
							gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
							color
							mes "艦これの画面を選択して下さい。(Escで終了)"
							DrawMouseSquare rect(0), rect(1), mousex, mousey
						redraw 1
					}else{
						// 選択開始
						rect(0) = mousex
						rect(1) = mousey
						mouse_button_flg = TRUE
					}
				}else{
					if(mouse_button_flg){
						mouse_button_flg = FALSE
						// 選択終了
						rect(2) = mousex
						rect(3) = mousey
						;選択サイズがFlashのサイズ以上かを判定
						square_x1 = min(rect(0), rect(2))
						square_y1 = min(rect(1), rect(3))
						square_x2 = max(rect(0), rect(2))
						square_y2 = max(rect(1), rect(3))
						if((square_x2 - square_x1 >= kFlashWX) && (square_y2 - square_y1 >= kFlashWY)){
							;艦これの画面の位置を探し、その中央の位置を返す
							;(つまり、オートモードでの探索範囲を制限したVerってこと)
							dim screen_param, kRectDim
							screen_param(0) = square_x1 + desktop_param(0)
							screen_param(1) = square_y1 + desktop_param(1)
							screen_param(2) = square_x2 - square_x1
							screen_param(3) = square_y2 - square_y1
							gsel kSelectWindowID, -1
							DesktopScreenShot kDesktopBufferID, screen_param
							FlashPositionSearch kDesktopBufferID, flash_position
							flash_point(0) = screen_param(0) + flash_position(0) + kFlashWX / 2
							flash_point(1) = screen_param(1) + flash_position(1) + kFlashWY / 2
							mouse_crop_flg = TRUE
							break
						}
					}
				}
				wait 5
			loop
		swbreak
		// マニュアル
		case kGetPosManual
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面を選択して下さい。(Escで終了)"
			mouse_button_flg = FALSE
			mouse_manual_flg = FALSE
			dim rect, kRectDim
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog "キャンセルされました。"
					gsel kSelectWindowID, -1
					break
				}
				if(key & kStickMouse){
					if(mouse_button_flg){
						// 選択途中
						redraw 0
							pos 0, 0
							gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
							color
							mes "艦これの画面を選択して下さい。(Escで終了)"
							DrawMouseSquare rect(0), rect(1), mousex, mousey
						redraw 1
					}else{
						// 選択開始
						rect(0) = mousex
						rect(1) = mousey
						mouse_button_flg = TRUE
					}
				}else{
					if(mouse_button_flg){
						mouse_button_flg = FALSE
						// 選択終了
						rect(2) = mousex
						rect(3) = mousey
						;とりあえず中央の位置を返す(このモードだけ処理が特殊)
						flash_point(0) = desktop_param(0) + (rect(0) + rect(2)) / 2
						flash_point(1) = desktop_param(1) + (rect(1) + rect(3)) / 2
						;認識用に選択した座標・サイズを記憶しておく
						dim square, kRectDim
						square.0 = min(rect(0), rect(2))
						square.1 = min(rect(1), rect(3))
						square.2 = max(rect(0), rect(2)) - min(rect(0), rect(2))
						square.3 = max(rect(1), rect(3)) - min(rect(1), rect(3))
						gsel kSelectWindowID, -1
						mouse_manual_flg = TRUE
						break
					}
				}
				wait 5
			loop
		swbreak
	swend
	if((get_pos_mode == kGetPosClick)  && (mouse_click_flg  == FALSE)) :return
	if((get_pos_mode == kGetPosCrop)   && (mouse_crop_flg   == FALSE)) :return
	if((get_pos_mode == kGetPosManual) && (mouse_manual_flg == FALSE)) :return
	// 艦これの画面のハンドルを取得する
	window_handle = GetWindowHandle(flash_point)
	// 艦これの画面の座標を取得する
	GetWindowParam window_handle, window_param
	WindowScreenShot kDesktopBufferID, window_handle, window_param
	if(get_pos_mode != kGetPosManual){
		FlashPositionSearch kDesktopBufferID, flash_position
	}else{
		square.0 += desktop_param(0) - window_param(0)
		square.1 += desktop_param(1) - window_param(1)
		dim game_window_size, kPosDim
		GamePositionSearch kDesktopBufferID, square, flash_position, game_window_size
		if((game_window_size(0) != kFlashWX) || (game_window_size(1) != kFlashWY)){
			PutLog "画面の捕捉に失敗しました。"
			return
		}
	}
	get_pos_flg = TRUE

	PutLog "ウィンドウハンドル：" + window_handle
	PutLog "ウィンドウ左上座標：" + window_param(0) + "," + window_param(1)
	PutLog "ウィンドウサイズ：" + window_param(2) + "," + window_param(3)
	PutLog "艦これ相対左上座標：" + flash_position(0) + "," + flash_position(1)
return

//*対象の状況を監視
*check_pos
	// 画面サイズを取得できない場合
	GetWindowParam window_handle, window_param_
	if((window_param_(2) == 0) || (window_param_(3) == 0)){
		PutLog "【ズレ検出】"
		PutLog "対象を見失いました。"
		get_pos_flg = FALSE
		// ストッパー画面における処理
		show_stopper_flg1 = FALSE
		show_stopper_flg2 = FALSE
		gsel kStopperWindowID, -1
		show_locker_flg1 = FALSE
		show_locker_flg2 = FALSE
		gsel kLockerWindowID, -1
		return
	}
	// ウィンドウサイズが変わった＝画像位置が動いた可能性がある場合
	// およびウィンドウ自体が動いた場合
	if((window_param_(0) != window_param(0)) || (window_param_(1) != window_param(1)) || (window_param_(2) != window_param(2)) || (window_param_(3) != window_param(3))){
		window_param(0) = window_param_(0)
		window_param(1) = window_param_(1)
		window_param(2) = window_param_(2)
		window_param(3) = window_param_(3)
		gosub *get_pos_local
		return
	}
	// 艦これの画面の周囲のRGB値から、ズレれていると判定された場合
	if(check_move_flash_flg){
		if(CheckMoveFlash(window_handle, flash_position)){
			gosub *get_pos_local
		}
	}
return

//*艦これの座標を取得し直す
*get_pos_local
	PutLog "【ズレ検出】"
	GetWindowParam window_handle, window_param
	WindowScreenShot kDesktopBufferID, window_handle, window_param
	FlashPositionSearch kDesktopBufferID, flash_position
	PutLog "艦これ相対左上座標：" + flash_position(0) + "," + flash_position(1)
	//ストッパー画面を再表示
	show_stopper_flg2 = FALSE
	ShowStopperWindow stopper_type
	show_locker_flg2 = FALSE
	ShowLockerWindow locker_type
return

/* 画像保存に関する処理 */
//*サブ画面に写った画像を保存する
*save_picture
	PutLog "【画像保存】"
	gsel kSubBufferID
	if(scene_list_index == 0){
		file_name = CnvStrTime2(flash_time) + ".png"
	}else{
		file_name = CnvStrTime2(show_scene_list_time(scene_list_index - 1)) + ".png"
	}
	PicSave file_name
	PutLog "ファイル名：" + file_name
return

//*トリミング保存
*save_picture_trim
	// 編成画面におけるトリミング(編成画像)
	if((scene_result2(0) == "編成画面") && (scene_result2(1) != "ソート画面")){
		PutLog "【トリミング】"
		buffer kTempBufferID, kFleetWX, kFleetWY
		gcopy kSubBufferID, kFleetPX, kFleetPY, kFleetWX, kFleetWY
		file_name = NowTime() + ".png"
		PicSave file_name
		PutLog "ファイル名：" + file_name
		return
	}
	// ソート画面におけるトリミング(ソート画像)
	if((scene_result2(0) == "編成画面") && (scene_result2(1) == "ソート画面")){
		PutLog "【トリミング】"
		buffer kTempBufferID, kSortWX, kSortWY
		gcopy kSubBufferID, kSortPX, kSortPY, kSortWX, kSortWY
		file_name = NowTime() + ".png"
		PicSave file_name
		PutLog "ファイル名：" + file_name
		return
	}
	// 改装画面におけるトリミング(艦娘画像)
	if(scene_result2(0) == "改装画面"){
		PutLog "【トリミング】"
		if(scene_result2(1) != "近代化改修"){
			buffer kTempBufferID, kUnitWX, kUnitWY
			gcopy kSubBufferID, kUnitPX, kUnitPY, kUnitWX, kUnitWY
		}else{
			buffer kTempBufferID, kUnitWX2, kUnitWY2
			gcopy kSubBufferID, kUnitPX2, kUnitPY2, kUnitWX2, kUnitWY2
		}
		file_name = NowTime() + ".png"
		PicSave file_name
		PutLog "ファイル名：" + file_name
		return
	}
	// その他母港画面におけるトリミング(資材画像)
	if(CheckHomeFlg(kSubBufferID)){
		PutLog "【トリミング】"
		buffer kTempBufferID, kStockAllWX, kStockAllWY
		;時刻貼り付け
		pos 0, 0
		gcopy kSubBufferID, kStockTimePX, kStockTimePY, kStockTimeWX, kStockTimeWY
		;資材貼り付け
		pos kStockTimeWX, 0
		gcopy kSubBufferID, kStockOtherPX, kStockOtherPY, kStockOtherWX, kStockOtherWY
		;保存
		file_name = NowTime() + ".png"
		PicSave file_name
		PutLog "ファイル名：" + file_name
		return
	}
return

//*艦隊画像を保存
*save_fleet
	PutLog "【艦隊画像】"
	if(save_fleet_index < kFleetNum){
		// 通常艦隊を保存
		buffer kTempBufferID, kUnitWX * 3, kUnitWY * 2
		count = 0
		for y, 0, 2
			if(count >= unit_count(save_fleet_index)) :_break
			for x, 0, 3
				if(count >= unit_count(save_fleet_index)) :_break
				pos x * kUnitWX, y * kUnitWY
				gcopy GetUnitID(save_fleet_index, y * 3 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
				count++
			next
		next
	}else{
		// 連合艦隊か支援艦隊を保存
		buffer kTempBufferID, kUnitWX * 4, kUnitWY * 3
		for z, 0, 2
			count = 0
			for y, 0, 3
				if(count >= unit_count((save_fleet_index - kFleetNum) * 2 + z)) :_break
				for x, 0, 2
					if(count >= unit_count((save_fleet_index - kFleetNum) * 2 + z)) :_break
					pos (z * 2 + x) * kUnitWX, y * kUnitWY
					gcopy GetUnitID((save_fleet_index - kFleetNum) * 2, z * 6 + y * 2 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
					count++
				next
			next
		next
	}
	file_name = NowTime() + ".png"
	PicSave file_name
	PutLog "ファイル名：" + file_name
return

/* 各種タイマーに関する処理 */
//*各種タイマーの値を更新する
*check_timer
	// 入渠画面
	if((scene_result(0) == "入渠画面") && (scene_result(1) == "通常時")){
		for k, 0, kDocks
			dock_finish_time(k) = 0.0
			dock_finish_flg(k) = 0
			// ドックに誰もいなければ無視する
			gsel kMainBufferID
			if(NearColor(480, dck_pos_y(k), 33, 174, 178) == FALSE) :_continue
			// 各桁の数字を読み取って、配列に代入する
			dim number, 6
			ReadNumber number, 6, dck_pos_x, dck_pos_y(k) + 25, 11, 16, 170, FALSE
			// 正規化して、終了時刻を代入する
			NormalizeTime number
			d_time = CnvFloatSec(number(0) * 10 + number(1), number(2) * 10 + number(3), number(4) * 10 + number(5), 0)
			dock_finish_time(k) = GetFloatTime() + d_time
		next
	}
	// 工廠画面
	if((scene_result(0) == "工廠画面") && (scene_result(1) == "通常時")){
		for k, 0, kDocks
			dock_finish_time(k + kDocks) = 0.0
			dock_finish_flg(k + Docks) = 0
			// ドックに誰もいなければ無視する
			gsel kMainBufferID
			if(NearColor(730, bld_pos_y(k), 204, 128, 73) == FALSE) :_continue
			// 各桁の数字を読み取って、配列に代入する
			dim number, 6
			ReadNumber number, 6, bld_pos_x, bld_pos_y(k), 11, 16, 170, FALSE
			// 正規化して、終了時刻を代入する
			NormalizeTime number
			d_time = CnvFloatSec(number(0) * 10 + number(1), number(2) * 10 + number(3), number(4) * 10 + number(5), 0)
			dock_finish_time(k + kDocks) = GetFloatTime() + d_time
		next
	}
	// 遠征画面
	if(scene_result(1) == "遠征詳細"){
		for k, 0, kExpPagePer
			gsel kMainBufferID
			// まず旗が立っているかを判別する
			if(NearColor(517,180 + k * 30,76,168,168) == FALSE) :_continue
			// 次に、右上の遠征名とリストの遠征名が一致しているかを調べる
			// 「名前が一致している」か「全くリスト外の新遠征である」場合のみ認識対象とする
			exp_small_name = GetExpSmallName(k)
			exp_large_name = GetExpLargeName()
			if((exp_small_name != exp_large_name) && (exp_small_name != -1) && (exp_large_name != -1)) :_continue
			// そして、旗の番号を判別する
			// 遠征対象が第(unit_number + 1)艦隊となることに注意
			unit_number = 0
			if(NearColor(525,180 + k * 30,224,230,227) && NearColor(523,180 + k * 30, 84,176,174)) :unit_number = 1
			if(NearColor(525,180 + k * 30, 47,164,165) && NearColor(523,180 + k * 30,236,228,215)) :unit_number = 2
			if(NearColor(525,180 + k * 30,237,229,217) && NearColor(523,180 + k * 30,239,231,219)) :unit_number = 3
			if(unit_number == 0) :_continue
			// 各桁の数字を読み取って、配列に代入する
			dock_finish_time(unit_number - 1 + kDocks * 2) = 0.0
			dock_finish_flg(unit_number - 1 + kDocks * 2) = 0
			expedition_kind(unit_number - 1) = -1
			dim number, 6
			ReadNumber number, 6, exp_pos_x, exp_pos_y, 9, 13, 190, FALSE
			// 正規化して、終了時刻を代入する
			NormalizeTime number
			d_time = CnvFloatSec(number(0) * 10 + number(1), number(2) * 10 + number(3), number(4) * 10 + number(5), 0)
			dock_finish_time(unit_number - 1 + kDocks * 2) = GetFloatTime() + d_time
			if(exp_small_name == exp_large_name){
				expedition_kind(unit_number - 1) = exp_small_name
			}
		next
	}
return

//*各種タイマーの表示を更新する
*redraw_timer
	timer_output = "【入渠ドック】\n"
	now_time = GetFloatTime()
	for k, 0, kDocks
		time_diff = dock_finish_time(k) - now_time
		if((dock_finish_time(k) != 0.0) && (time_diff > 0.0)){
			timer_output += "" + (k + 1) + "→" + CnvStrSec2(time_diff)
			if(time_diff < 1.0 / 24 / 60){
				if(dock_finish_flg(k) == 0){
					dock_finish_flg(k) = 1
					PutLog "【終了通知】"
					PutLog "入渠―第" + (k + 1) + "ドック"
					gsel kMainWindowID
					TasktrayPopup2 "第" + (k + 1) + "ドックの\n入渠がまもなく完了します。", kSoftName, 1, 1000
				}
				timer_output += "☆"
			}
			timer_output += "\n"
		}else{
			timer_output += "" + (k + 1) + "→00:00:00　空\n"
			dock_finish_flg(k) = 0
		}
	next
	timer_output += "【建造ドック】\n"
	for k, 0, kDocks
		time_diff = dock_finish_time(k + kDocks) - now_time
		if((dock_finish_time(k + kDocks) != 0.0) && (time_diff > 0.0)){
			timer_output += "" + (k + 1) + "→" + CnvStrSec2(time_diff)
			if(time_diff < 1.0 / 24 / 60){
				if(dock_finish_flg(k + kDocks) == 0){
					dock_finish_flg(k + kDocks) = 1
					PutLog "【終了通知】"
					PutLog "建造―第" + (k + 1) + "ドック"
					gsel kMainWindowID
					TasktrayPopup2 "第" + (k + 1) + "ドックの\n建造がまもなく完了します。", kSoftName, 1, 1000
				}
				timer_output += "☆"
			}
			timer_output += "\n"
		}else{
			timer_output += "" + (k + 1) + "→00:00:00　空\n"
			dock_finish_flg(k + kDocks) = 0
		}
	next
	timer_output += "【遠征艦隊】\n"
	for k, 0, kFleetNum - 1
		time_diff = dock_finish_time(k + kDocks * 2) - now_time
		if((dock_finish_time(k + kDocks * 2) != 0.0) && (time_diff > 0.0)){
			timer_output += "" + (k + 2) + "→" + CnvStrSec2(time_diff)
			if(time_diff < 1.0 / 24 / 60){
				if(dock_finish_flg(k + kDocks * 2) == 0){
					dock_finish_flg(k + kDocks * 2) = 1
					PutLog "【終了通知】"
					if(expedition_kind(k) != -1){
						PutLog "遠征―第" + (k + 2) + "艦隊" + "(" + exped_name(expedition_kind(k)) + ")"
					}else{
						PutLog "遠征―第" + (k + 2) + "艦隊"
					}
					gsel kMainWindowID
					TasktrayPopup2 "第" + (k + 2) + "艦隊の\n遠征がまもなく完了します。", kSoftName, 1, 1000
				}
				timer_output += "☆"
			}else{
				timer_output += "　"
			}
			if(expedition_kind(k) != -1){
				timer_output += exped_name(expedition_kind(k)) + "\n"
			}else{
				timer_output += "？\n"
			}
		}else{
			timer_output += "" + (k + 2) + "→00:00:00\n"
			dock_finish_flg(k + kDocks * 2) = 0
		}
	next
	gsel kTimerWindowID
	objprm 0, timer_output
return

//*各種タイマーを表示する
*show_timer
	gsel kTimerWindowID, 2
return

/* ソート一覧に関する処理 */
//*ソート一覧を表示する
*show_sort_list
	gsel kSortListWindowID, 2
return

//*ソート一覧に追加する
*add_sort_list
	if(sort_kind == 0){
		if((scene_result2(0) == "編成画面") && (scene_result2(1) == "ソート画面") && (sort_list_size(0) < kMaxSortPages)){
			sort_list(0) += NowTime() + "\n"
			gsel kSortListBufferID
			pos sort_list_size(0) * kSortWX, 0
			gcopy kSubBufferID, kSortPX, kSortPY, kSortWX, kSortWY
			gsel kSortListWindowID
			objprm sort_index_id, sort_list(0)
			sort_list_size(0)++
			title "ソート一覧(艦娘," + sort_list_size(0) + "枚)"
		}
	}
	if(sort_kind == 1){
		if((scene_result2(1) == "廃棄画面") && (sort_list_size(1) < kMaxSort2Pages)){
			sort_list(1) += NowTime() + "\n"
			gsel kSort2ListBufferID
			pos sort_list_size(1) * kSort2WX, 0
			gcopy kSubBufferID, kSort2PX, kSort2PY, kSort2WX, kSort2WY
			gsel kSortListWindowID
			objprm sort_index_id, sort_list(1)
			sort_list_size(1)++
			title "ソート一覧(装備," + sort_list_size(1) + "枚)"
		}
	}
return

//*ソート一覧からまとめ画像を生成する
*make_sort_list
	if(sort_list_size(sort_kind) <= 0) :return
	PutLog "【ソート一覧画像】"
	if(sort_type == 0){
		// 普通のバージョン(練度をベタッと並べていく)
		//出力用バッファを準備
		LX = (sort_width_index + 1)
		LY = sort_list_size(sort_kind) / (sort_width_index + 1)
		if(sort_list_size(sort_kind) \ (sort_width_index + 1) != 0) :LY++
		if(sort_kind == 0){
			ListSizeX = LX * kSortWX
			ListSizeY = LY * kSortWY
			buffer kTempBufferID, ListSizeX, ListSizeY
			//どんどん書き込んでいく
			for k, 0, sort_list_size(sort_kind)
				x = k / LY
				y = k \ LY
				pos x * kSortWX, y * kSortWY
				gcopy kSortListBufferID, k * kSortWX, 0, kSortWX, kSortWY
			next
		}else{
			ListSizeX = LX * kSort2WX
			ListSizeY = LY * kSort2WY
			buffer kTempBufferID, ListSizeX, ListSizeY
			//どんどん書き込んでいく
			for k, 0, sort_list_size(sort_kind)
				x = k / LY
				y = k \ LY
				pos x * kSort2WX, y * kSort2WY
				gcopy kSort2ListBufferID, k * kSort2WX, 0, kSort2WX, kSort2WY
			next
		}
	}else{
		// 特殊バージョン
		if(sort_kind == 0){
			// 艦娘→艦種別・練度順で並べていく
			//リストを一通り読み込む
			dim list_type, kSortListHeight * sort_list_size(sort_kind)
			dim list_level, kSortListHeight * sort_list_size(sort_kind)
			sdim list_pos, 64, kSortListHeight * sort_list_size(sort_kind)
			kammusues = 0
			sdim temp, kSortStrLength
			for i, 0, sort_list_size
				for j, 0, kSortListHeight
					gsel kSortListBufferID
					// 画像からデータを読み込む
					temp = ""
					for k, 0, kSortStrLength
						pget i * kSortWX + k + 2, kSortWY2 * j + 12
						if(ginfo_r < 128){
							temp += "1"
						}else{
							temp += "0"
						}
					next
					// 艦種を判別する(一番近い艦種を求める)
					min_diff = kSortStrLength + 1
					best_type = -1
					for k, 0, kSortType
						diff = 0
						for m, 0, kSortStrLength
							if(strmid(temp, m, 1) != strmid(sort_type_str(k), m, 1)) :diff++
						next
						if(diff < min_diff){
							min_diff = diff
							best_type = k
						}
					next
					if(sort_type_name(best_type) == "なし") :_continue
					list_pos(kammusues) = "" + i + "," + j
					list_type(kammusues) = best_type
					// レベルを読み取る
					//ケッコンしているかを判定(指輪ではなく純粋に100の位を見ている)
					pget i * kSortWX + 158, kSortWY2 * j + 12
					if(ginfo_r < 150){
						list_level(kammusues) = 100
					}else{
						list_level(kammusues) = 0
					}
					//数字部分は文字認識で判定
					sort_pos_x_.0 = i * kSortWX + sort_pos_x(0), i * kSortWX + sort_pos_x(1)
					dim number, 2
					ReadNumber number, 2, sort_pos_x_, kSortWY2 * j + 8, 8, 12, 190, FALSE
					NormalizeLevel number
					list_level(kammusues) += number(0) * 10 + number(1)
					kammusues++
				next
			next
			// 読み込んだ結果を艦種・レベル毎にソートする
			for i, 0, kammusues - 1
				for j, i + 1, kammusues
					flg = FALSE
					if(list_type(i) > list_type(j)){
						flg = TRUE
					}else{
						if(list_type(i) == list_type(j)){
							if(list_level(i) < list_level(j)){
								flg == TRUE
							}
						}
					}
					if(flg){
						temp = list_type(i)  :list_type(i)  = list_type(j)  :list_type(j)  = temp
						temp = list_level(i) :list_level(i) = list_level(j) :list_level(j) = temp
						temp = list_pos(i)   :list_pos(i)   = list_pos(j)   :list_pos(j)   = temp
					}
				next
			next
			//ソート結果から、出力ファイルを生成する
			LX = (sort_width_index + 1)
			LY = kammusues / LX
			if(kammusues \ LX != 0) :LY++
			ListSizeX = LX * kSortWX
			ListSizeY = LY * kSortWY3
			buffer kTempBufferID, ListSizeX, ListSizeY
			// どんどん書き込んでいく
			for k, 0, kammusues
				x = k / LY
				y = k \ LY
				pos x * kSortWX, y * kSortWY3
				split list_pos(k), ",", temp
				px = int(temp(0))
				py = int(temp(1))
				gcopy kSortListBufferID, px * kSortWX, sort_pos_y(py), kSortWX, kSortWY3
			next
		}else{
			// 装備→☆付きor熟練度MAXのを抽出する
			//リストを一通り読み込む
			sdim list_pos, 64, kSort2ListHeight * sort_list_size(sort_kind)
			weapons = 0
			for i, 0, sort_list_size(sort_kind)
				for j, 0, kSort2ListHeight
					gsel kSort2ListBufferID
					if(NearColor(i * kSort2WX + 173, j * kSort2WY2 + 14, 68, 168, 164)){
						// ☆付き装備
						list_pos(weapons) = "" + i + "," + j
						weapons++
						_continue
					}
					if(NearColor(i * kSort2WX + 159, j * kSort2WY2 + 14, 208, 148, 3)){
						if(NearColor(i * kSort2WX + 166, j * kSort2WY2 + 14, 208, 148, 3)){
							// 熟練度MAX
							list_pos(weapons) = "" + i + "," + j
							weapons++
							_continue
						}
					}
				next
			next
			//ソート結果から、出力ファイルを生成する
			LX = (sort_width_index + 1)
			LY = weapons / LX
			if(weapons \ LX != 0) :LY++
			ListSizeX = LX * kSort2WX
			ListSizeY = LY * kSort2WY3
			buffer kTempBufferID, ListSizeX, ListSizeY
			// どんどん書き込んでいく
			for k, 0, weapons
				x = k / LY
				y = k \ LY
				pos x * kSort2WX, y * kSort2WY3
				split list_pos(k), ",", temp
				px = int(temp(0))
				py = int(temp(1))
				gcopy kSort2ListBufferID, px * kSort2WX, py * kSort2WY3, kSort2WX, kSort2WY3
			next
		}
	}
	file_name = NowTime() + ".png"
	PicSave file_name
	PutLog "ファイル名：" + file_name
return

//*ソート一覧で選択項目を上げる
*upper_sort_list
	if(sort_index == limit(sort_index, 1, sort_list_size(sort_kind) - 1)){
		;バッファの入れ替え
		if(sort_kind == 0){
			buffer kTempBufferID, kSortWX, kSortWY
				gcopy kSortListBufferID, sort_index * kSortWX, 0, kSortWX, kSortWY
			gsel kSortListBufferID
				pos sort_index * kSortWX, 0
					gcopy kSortListBufferID, (sort_index - 1) * kSortWX, 0, kSortWX, kSortWY
				pos (sort_index - 1) * kSortWX, 0
					gcopy kTempBufferID, 0, 0, kSortWX, kSortWY
		}else{
			buffer kTempBufferID, kSort2WX, kSort2WY
				gcopy kSort2ListBufferID, sort_index * kSort2WX, 0, kSort2WX, kSort2WY
			gsel kSort2ListBufferID
				pos sort_index * kSort2WX, 0
					gcopy kSort2ListBufferID, (sort_index - 1) * kSort2WX, 0, kSort2WX, kSort2WY
				pos (sort_index - 1) * kSort2WX, 0
					gcopy kTempBufferID, 0, 0, kSort2WX, kSort2WY
		}
		;リストの入れ替え
		notesel sort_list(sort_kind)
		noteget text_buffer,  sort_index - 1
		noteget text_buffer2, sort_index
		noteadd text_buffer2, sort_index - 1, 1
		noteadd text_buffer,  sort_index,     1
		gsel kSortListWindowID
		objprm sort_index_id, sort_list(sort_kind)
		sort_index--
		objprm sort_index_id, sort_index
	}
return

*upper_sort_list2
	loops = sort_index
	for k, 0, loops
		gosub *upper_sort_list
	next
return

//*ソート一覧で選択項目を下げる
*lower_sort_list
	if(sort_index == limit(sort_index, 0, sort_list_size(sort_kind) - 2)){
		;バッファの入れ替え
		if(sort_kind == 0){
			buffer kTempBufferID, kSortWX, kSortWY
				gcopy kSortListBufferID, sort_index * kSortWX, 0, kSortWX, kSortWY
			gsel kSortListBufferID
				pos sort_index * kSortWX, 0
					gcopy kSortListBufferID, (sort_index + 1) * kSortWX, 0, kSortWX, kSortWY
				pos (sort_index + 1) * kSortWX, 0
					gcopy kTempBufferID, 0, 0, kSortWX, kSortWY
		}else{
			buffer kTempBufferID, kSort2WX, kSort2WY
				gcopy kSort2ListBufferID, sort_index * kSort2WX, 0, kSort2WX, kSort2WY
			gsel kSort2ListBufferID
				pos sort_index * kSort2WX, 0
					gcopy kSort2ListBufferID, (sort_index + 1) * kSort2WX, 0, kSort2WX, kSort2WY
				pos (sort_index + 1) * kSort2WX, 0
					gcopy kTempBufferID, 0, 0, kSort2WX, kSort2WY
		}
		;リストの入れ替え
		notesel sort_list(sort_kind)
		noteget text_buffer,  sort_index + 1
		noteget text_buffer2, sort_index
		noteadd text_buffer2, sort_index + 1, 1
		noteadd text_buffer,  sort_index,     1
		gsel kSortListWindowID
		objprm sort_index_id, sort_list(sort_kind)
		sort_index++
		objprm sort_index_id, sort_index
	}
return

*lower_sort_list2
	loops = sort_list_size(sort_kind) - sort_index - 1
	for k, 0, loops
		gosub *lower_sort_list
	next
return

//*ソート一覧で選択項目を削除する
*del_sort_list
	if((sort_index >= 0) && (sort_index < sort_list_size(sort_kind))){
		;バッファの削除
		if(sort_kind == 0){
			gsel kSortListBufferID
			for k, sort_index, sort_list_size(sort_kind) - 1
				pos k * kSortWX
				gcopy kSortListBufferID, (k + 1) * kSortWX, 0, kSortWX, kSortWY
			next
		}else{
			gsel kSort2ListBufferID
			for k, sort_index, sort_list_size(sort_kind) - 1
				pos k * kSort2WX
				gcopy kSort2ListBufferID, (k + 1) * kSort2WX, 0, kSort2WX, kSort2WY
			next
		}
		;リストの削除
		notesel sort_list(sort_kind)
		notedel sort_index
		gsel kSortListWindowID
		objprm sort_index_id, sort_list(sort_kind)
		sort_list_size(sort_kind)--
		if(sort_list_size(sort_kind) == 0){
			title "ソート一覧(" + sort_kind_name(sort_kind) + ")"
		}else{
			title "ソート一覧(" + sort_kind_name(sort_kind) + "," + sort_list_size(sort_kind) + "枚)"
		}
	}
return

//*ソート一覧で項目を全削除する
*alldel_sort_list
	dialog "項目を全削除しますか？", 2, kSoftName
	if(stat == 6){
		if(sort_kind == 0) :gsel kSortListBufferID :else :gsel kSort2ListBufferID
		color 255, 255, 255 :boxf
		gsel kSortListWindowID
		sort_list(sort_kind) = ""
		objprm sort_index_id, sort_list(sort_kind)
		sort_list_size(sort_kind) = 0
		title "ソート一覧(" + sort_kind_name(sort_kind) + ")"
	}
return

//*選択位置が変わった際に表示する画像を変更する
*redraw_sort_preview
	if((sort_index_ != sort_index) && (sort_index >= 0)){
		if(sort_kind == 0){
			gsel kSortListWindowID
			POS_XY 2, 0
			gzoom2 SIZE_X(2), SIZE_Y(8), kSortListBufferID, sort_index * kSortWX, 0, kSortWX, kSortWY
			sort_index_ = sort_index
		}else{
			gsel kSortListWindowID
			POS_XY 2, 0
			gzoom2 SIZE_X(2), SIZE_Y(8), kSort2ListBufferID, sort_index * kSort2WX, 0, kSort2WX, kSort2WY
			sort_index_ = sort_index
		}
	}
return

/* 経験値計算機に関する処理 */
//*計算機の画面を表示する
*show_exp_calc
	gsel kExpCalcWindowID, 2
return

//*経験値を計算し、反映する
*exp_calc
	// 補完機能についての処理
	if((exp_ss_flg) && (scene_result(0) == "編成画面") && (strmid(scene_result(1), 0, 2) == "第")){
		// レベル補間
		if(exp_option_index != 1){
			// 画像から練度を読み取る
			gsel kMainBufferID
			x = exp_unit_index \ 2
			y = exp_unit_index / 2
			pget 342 * x + 256, 113 * y + 153
			if(ginfo_r >= 128){
				now_level_ = 100
			}else{
				now_level_ = 0
			}
			dim number, 2
			unit_pos_x_.0 = 342 * x + unit_pos_x(0), 342 * x + unit_pos_x(1)
			dim number, 2
			ReadNumber number, 2, unit_pos_x_, 113 * y + 149, 8, 12, 85, TRUE
			NormalizeLevel number
			now_level__ = number(0) * 10 + number(1)
			if(now_level_ + now_level__ > 0){
				now_level = now_level_ + now_level__ - 1	//-1するのはコンボボックスの都合
				// 読み取った練度を画面に反映する
				gsel kExpCalcWindowID
				objprm now_level_id, now_level
			}
		}
		// 経験値補間
		if(exp_option_index != 0){
			// 画像から経験値の割合を読み取る
			gsel kMainBufferID
			unit_exp_double = 1.0
			x = exp_unit_index \ 2
			y = exp_unit_index / 2
			for k, 0, 160
				if(NearColor(342 * x + 284 + k, 113 * y + 194, 165, 232, 208) == FALSE){
					unit_exp_double = 1.0 * k / 160
					_break
				}
			next
			// 練度の値から、経験値補正がどれほどあるかを算出する
			if(now_level + 1 != 150){
				now_exp_plus = int(unit_exp_double * (need_exp_table(now_level + 1) - need_exp_table(now_level)))
			}else{
				now_exp_plus = 0
			}
		}else{
			now_exp_plus = 0
		}
	}else{
		now_exp_plus = 0
	}
	// レベル補正についての処理
	if(now_level > goal_level){
		if(now_level != now_level_){
			goal_level = now_level
			gsel kExpCalcWindowID
			objprm goal_level_id, goal_level
		}
		if(goal_level != goal_level_){
			now_level = goal_level
			gsel kExpCalcWindowID
			objprm now_level_id, now_level
		}
	}
	// 経験値の計算処理
	//必要経験値を計算
	now_exp = need_exp_table(now_level) + now_exp_plus
	goal_exp = need_exp_table(goal_level)
	need_exp = goal_exp - now_exp
	//戦闘経験値を計算
	battle_exp = 1.0 * exp_data(area_index)
	if(reader_ship_flg) :battle_exp *= 1.5
	if(mvp_flg) :battle_exp *= 2.0
	switch result_index
		case 0	;完全S
			battle_exp *= 1.2
			swbreak
		case 1	;勝利S
			battle_exp *= 1.2
			swbreak
		case 2	;勝利A
			battle_exp *= 1.0
			swbreak
		case 3	;勝利B
			battle_exp *= 1.0
			swbreak
		case 4	;敗北C
			battle_exp *= 0.8
			swbreak
		case 5	;敗北D
			battle_exp *= 0.7
			swbreak
		case 6	;敗北E
			battle_exp *= 0.5
			if(mvp_flg) :battle_exp *= 0.5	;MVP無効
	swend
	battle_exp = int(battle_exp)
	//必要周回数を計算
	need_battles = need_exp / battle_exp
	if(need_exp \ battle_exp != 0) :need_battles++
	// 出力処理
	gsel kExpCalcWindowID
	objprm need_exp_id, need_exp
	objprm battle_exp_id, battle_exp
	objprm need_battles_id, need_battles
return

//*計算機の更新をチェックする
*check_exp_calc
	if(now_level_        != now_level)        :gosub *exp_calc :now_level_        = now_level
	if(goal_level_       != goal_level)       :gosub *exp_calc :goal_level_       = goal_level
	if(area_index_       != area_index)       :gosub *exp_calc :area_index_       = area_index
	if(result_index_     != result_index)     :gosub *exp_calc :result_index_     = result_index
	if(reader_ship_flg_  != reader_ship_flg)  :gosub *exp_calc :reader_ship_flg_  = reader_ship_flg
	if(mvp_flg_          != mvp_flg)          :gosub *exp_calc :mvp_flg_          = mvp_flg
	if(exp_ss_flg_       != exp_ss_flg)       :gosub *exp_calc :exp_ss_flg_       = exp_ss_flg
	if(exp_unit_index_   != exp_unit_index)   :gosub *exp_calc :exp_unit_index_   = exp_unit_index
	if(exp_option_index_ != exp_option_index) :gosub *exp_calc :exp_option_index_ = exp_option_index
return

/* ○号カウンタに関する処理 */
//*○号カウンタを表示する
*show_counter
	gsel kCounterWindowID, 2
return

//*○号カウンタを更新する
*redraw_counter
	if((count_num(0) >= 36) && (count_num(1) >= 24) && (count_num(2) >= 12) && (count_num(3) >= 6)){
		counter_output = "【あ号(達成)】\n"
	}else{
		counter_output = "【あ号(未達成)】\n"
	}
	counter_output += "海域出撃：" + count_num(0) + " / 36回"
	if(count_num(0) >= 36) :counter_output += "(OK)"
	counter_output += "\nボス到達：" + count_num(1) + " / 24回"
	if(count_num(1) >= 24) :counter_output += "(OK)"
	counter_output += "\nボス勝利" + count_num(2) + " / 12回"
	if(count_num(2) >= 12) :counter_output += "(OK)"
	counter_output += "\nS勝利判定" + count_num(3) + " / 6回"
	if(count_num(3) >= 6) :counter_output += "(OK)"

	if(count_num(4) >= 50){
		counter_output += "\n【ろ号(達成)】"
	}else{
		counter_output += "\n【ろ号(未達成)】"
	}
	counter_output += "\n補給船撃沈：" + count_num(4) + " / 50回\n"

	if(count_num(5) >= 20){
		counter_output += "【い号(達成)】\n"
	}else{
		counter_output += "【い号(未達成)】\n"
	}
	counter_output += "空母系撃沈：" + count_num(5) + " / 20回"
	gsel kCounterWindowID
	objprm 0, counter_output
return

//*ボタン操作
*counter_type_1 :count_num(0)++ :redraw_counter_flg = TRUE :return
*counter_type_2 :count_num(1)++ :redraw_counter_flg = TRUE :return
*counter_type_3 :count_num(2)++ :redraw_counter_flg = TRUE :return
*counter_type_4 :count_num(3)++ :redraw_counter_flg = TRUE :return
*counter_type_5 :count_num(4)++ :redraw_counter_flg = TRUE :return
*counter_type_6 :count_num(5)++ :redraw_counter_flg = TRUE :return

*counter_reset_1 :count_num(0) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_2 :count_num(1) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_3 :count_num(2) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_4 :count_num(3) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_5 :count_num(4) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_6 :count_num(5) = 0 :redraw_counter_flg = TRUE :return

//*カウンターの自動更新処理
*counter_auto
	//海域出撃カウント
	if((pre_scene_type == "海域出撃") && (pre_scene_name == "艦隊選択") && (scene_result(1) == "出撃画面")){
		if(auto_count_flg(0) && (exercises_flg == FALSE)){
			count_num(0)++
			redraw_counter_flg = TRUE
		}
	}
	//ボス到達カウント
	if(pre_scene_name == "海域マップ"){
		// HSPはIF文の判定途中で処理を切り上げないので、
		// こうして処理を分けないとpre_scene_name != "海域マップ"でも
		// CheckBossOfAeraMap()が実行されてしまう
		if(CheckBossOfAeraMap()){
			if(auto_count_flg(1) && (exercises_flg == FALSE)){
				count_num(1)++
				redraw_counter_flg = TRUE
			}
			boss_battle_flg = TRUE
		}
	}
	if(scene_result(0) == "母港画面"){
		boss_battle_flg = FALSE
	}
	if(scene_result(1) == "戦果報告"){
		//ボス勝利カウント
		if((boss_battle_flg) && (battle_rank < kBattleRankLoss)){
			if(auto_count_flg(2) && (exercises_flg == FALSE)){
				count_num(2)++
				redraw_counter_flg = TRUE
			}
			boss_battle_flg = FALSE
		}
		//S勝利判定カウント
		if(battle_rank == kBattleRankS){
			if(auto_count_flg(3) && (exercises_flg == FALSE)){
				count_num(3)++
				redraw_counter_flg = TRUE
			}
		}
	}
	if(scene_result(1) == "交戦結果"){
		// 最後の戦闘が昼戦か夜戦かを、最終更新日時で判断する
		if(show_scene_list_time(battle_index(0)) > show_scene_list_time(battle_index(1))){
			gsel kSceneBufferID + battle_index(0)
		}else{
			gsel kSceneBufferID + battle_index(1)
		}
		//輸送船撃沈カウント
		for k, 0, kUnitNum
			if(NearColor(767,173 + 45 * k,77,166,223)){
				if(NearColor(669,178 + 45 * k,254,254,254)){
					if(NearColor(649,157 + 45 * k,133,133,133)){
						if(auto_count_flg(4) && (exercises_flg == FALSE)){
							count_num(4)++
							redraw_counter_flg = TRUE
						}
					}
				}
			}
		next
		//空母系撃沈カウント
		for k, 0, kUnitNum
			if(NearColor(767,173 + 45 * k,77,166,223)){
				;正規空母
				if(NearColor(670,176 + 45 * k,167,167,167)){
					if(NearColor(671,157 + 45 * k,215,215,215)){
						if(auto_count_flg(5) && (exercises_flg == FALSE)){
							count_num(5)++
							redraw_counter_flg = TRUE
						}
					}
				}
				;軽空母
				if(NearColor(667,177 + 45 * k,183,183,183)){
					if(NearColor(664,170 + 45 * k,252,252,252)){
						if(auto_count_flg(5) && (exercises_flg == FALSE)){
							count_num(5)++
							redraw_counter_flg = TRUE
						}
					}
				}
			}
		next
	}
return

/* cond値メータに関する処理 */
//*cond値メータを表示する
*show_cond_meter
	gsel kCondMeterWindowID, 2
return

//*cond値メータを更新する
*redraw_cond
	// cond値を正規化する
	for k, 0, kUnitNum
		cond(k) = limit(cond(k), 0, 100)
	next
	// 表示を修正する
	for k, 0, kUnitNum
		cond_msg(k) = "" + (k + 1) + "番艦・"
		if(cond(k) >= 50) :cond_msg(k) += "キラ" :_continue
		if(cond(k) >= 40) :cond_msg(k) += "通常" :_continue
		if(cond(k) >= 30) :cond_msg(k) += "間宮" :_continue
		if(cond(k) >= 20) :cond_msg(k) += "橙点灯" :_continue
		cond_msg(k) += "赤点灯"
	next
	// 結果を反映する
	if(auto_calc_flg){
		gsel kCondMeterWindowID
		for k, 0, kUnitNum
			objprm cond_id + k, cond(k)
			objprm cond_msg_id + k, cond_msg(k)
		next
	}
return

//*オブジェクトの状態を変更する
*cond_enable
	gsel kCondMeterWindowID
	switch cond_step
		case 0
			for k, 0, 3
				objenable battle_type_id + k, 1
			next
			for k, 0, 6
				objenable win_type_id + k, 0
			next
			for k, 0, kUnitNum
				objenable mvp_id + k, 0
			next
			for k, 0, kUnitNum
				objenable cond_reset_id + k,1 
			next
			objenable set_kira3_id, 1
			objenable return_home_id, 1
		swbreak
		case 1
			for k, 0, 3
				objenable battle_type_id + k, 0
			next
			for k, 0, 6
				objenable win_type_id + k, 1
			next
			for k, 0, kUnitNum
				objenable mvp_id + k, 0
			next
			for k, 0, kUnitNum
				objenable cond_reset_id + k, 0
			next
			objenable set_kira3_id, 0
			objenable return_home_id, 0
		swbreak
		case 2
			for k, 0, 3
				objenable battle_type_id + k, 0
			next
			for k, 0, 6
				objenable win_type_id + k, 0
			next
			for k, 0, kUnitNum
				objenable mvp_id + k, 1
			next
			for k, 0, kUnitNum
				objenable cond_reset_id + k, 0
			next
			objenable set_kira3_id, 0
			objenable return_home_id, 0
		swbreak
		case 3
			gosub *cond_calc
			cond_step = 0
			gosub *cond_enable
		swbreak
	swend
return

//*cond値を更新する
*cond_calc
	// 戦闘突入時の増減
	if(battle_type < 2){
		for k, 0, kUnitNum
			if(cond(k) >= 30){
				cond(k) -= 3
			}else{
				cond(k) -= 9
			}
		next
	}
	if(battle_type > 0){
		for k, 0, kUnitNum
			cond(k) -= 2
		next
	}
	for k, 0, kUnitNum
		if(cond(k) < 0) :cond(k) = 0
	next
	// MVP獲得による増加
	cond(mvp_num) += 10
	// 旗艦補正
	if(win_type != 5) :cond(0) += 3
	// 戦闘結果による増減
	for k, 0, kUnitNum
		switch win_type
			case 0	;完全S
				cond(k) += 4
			swbreak
			case 1	;勝利S
				cond(k) += 4
			swbreak
			case 2	;勝利A
				cond(k) += 3
			swbreak
			case 3	;勝利B
				cond(k) += 2
			swbreak
			case 4	;勝利C
				cond(k) += 1
			swbreak
		swend
	next
return

//*交戦形態
*battle_type_1 :battle_type = 0 :cond_step = 1 :return
*battle_type_2 :battle_type = 1 :cond_step = 1 :return
*battle_type_3 :battle_type = 2 :cond_step = 1 :return

//*戦闘結果
*win_type_ss :win_type = 0 :cond_step = 2 :return
*win_type_s  :win_type = 1 :cond_step = 2 :return
*win_type_a  :win_type = 2 :cond_step = 2 :return
*win_type_b  :win_type = 3 :cond_step = 2 :return
*win_type_c  :win_type = 4 :cond_step = 2 :return
*win_type_de :win_type = 5 :cond_step = 2 :return

//*MVP
*mvp_1 :mvp_num = 0 :cond_step = 3 :return
*mvp_2 :mvp_num = 1 :cond_step = 3 :return
*mvp_3 :mvp_num = 2 :cond_step = 3 :return
*mvp_4 :mvp_num = 3 :cond_step = 3 :return
*mvp_5 :mvp_num = 4 :cond_step = 3 :return
*mvp_6 :mvp_num = 5 :cond_step = 3 :return

//*リセット
*cond_reset_1 :cond(0) = 49 :return
*cond_reset_2 :cond(1) = 49 :return
*cond_reset_3 :cond(2) = 49 :return
*cond_reset_4 :cond(3) = 49 :return
*cond_reset_5 :cond(4) = 49 :return
*cond_reset_6 :cond(5) = 49 :return

//*その他
*set_kira3
	for k, 0, kUnitNum
		cond(k) = 85
	next
return
*auto_recover
	for k, 0, kUnitNum
		if(cond(k) < 49){
			cond(k) = 49
		}
	next
return
*return_home
	for k, 0, kUnitNum
		if(cond(k) > 30){
			cond(k) -= 15
		}else{
			cond(k) -= 30
		}
	next
return
*reset_all
	for k, 0, kUnitNum
		cond(k) = 49
	next
	cond_step = 0
	gosub *cond_enable
return

/* 資材ログに関する処理 */
//*資材ログに追記する
*put_supply_log
	if(flash_time - supply_last_time >= kPutSupplyLogInterval){
		if(CheckHomeFlg(kMainBufferID) == FALSE) :return
		supply_last_time = flash_time
		PutLog "【資材ログ】"
		GetSupply supply_list
		// バッファを再作成してコピーする
		sdim supply_log_, (supply_log_size + 1) * kSupplyLogBlockSize
		memcpy supply_log_, supply_log, supply_log_size * kSupplyLogBlockSize
		// 書き込む
		p = supply_log_size * kSupplyLogBlockSize
		//日時
		wpoke supply_log_, p, gettime(0) :p += 2
		poke  supply_log_, p, gettime(1) :p += 1
		poke  supply_log_, p, gettime(3) :p += 1
		poke  supply_log_, p, gettime(4) :p += 1
		poke  supply_log_, p, gettime(5) :p += 1
		poke  supply_log_, p, gettime(6) :p += 1
		//燃料・弾薬・鋼材・ボーキ
		lpoke supply_log_, p, supply_list(0) :p += 4
		lpoke supply_log_, p, supply_list(1) :p += 4
		lpoke supply_log_, p, supply_list(2) :p += 4
		lpoke supply_log_, p, supply_list(3) :p += 4
		//高速修復材・開発資材・司令部レベル
		wpoke supply_log_, p, supply_list(4) :p += 2
		wpoke supply_log_, p, supply_list(5) :p += 2
		poke supply_log_, p, supply_list(6)
		// 再コピーしてからファイルに保存する
		sdim supply_log, (supply_log_size + 1) * kSupplyLogBlockSize
		memcpy supply_log, supply_log_, (supply_log_size + 1) * kSupplyLogBlockSize
		bsave exe_path + "\\save\\supply.dat", supply_log, (supply_log_size + 1) * kSupplyLogBlockSize
		supply_log_size++
		PutLog "追記完了"
		gosub *draw_supply_graph
	}
return

//*資材ログをCSV形式で書き出す
*write_supply_csv
	PutLog "【資材ログ】"
	sdim text_buffer, 64
	text_buffer += "日付,燃料,弾薬,鋼材,ボーキ,高速修復材,開発資材,司令部レベル\n"
	p = 0
	for k, 0, supply_log_size
		if(time != gettime(6)){
			PutLog "出力率：" + strf("%.1f", 100.0 * (k + 1) / supply_log_size) + "％"
			time = gettime(6)
		}
		// 日時
		text_buffer += strf("%04d-", wpeek(supply_log, p)) :p += 2
		text_buffer += strf("%02d-",  peek(supply_log, p)) :p += 1
		text_buffer += strf("%02d ",  peek(supply_log, p)) :p += 1
		text_buffer += strf("%02d:",  peek(supply_log, p)) :p += 1
		text_buffer += strf("%02d:",  peek(supply_log, p)) :p += 1
		text_buffer += strf("%02d,",  peek(supply_log, p)) :p += 1
		// 燃料・弾薬・鋼材・ボーキ
		text_buffer += "" + lpeek(supply_log, p) + "," :p += 4
		text_buffer += "" + lpeek(supply_log, p) + "," :p += 4
		text_buffer += "" + lpeek(supply_log, p) + "," :p += 4
		text_buffer += "" + lpeek(supply_log, p) + "," :p += 4
		// 高速修復材・開発資材・司令部レベル
		text_buffer += "" + wpeek(supply_log, p) + ","  :p += 2
		text_buffer += "" + wpeek(supply_log, p) + ","  :p += 2
		text_buffer += "" +  peek(supply_log, p) + "\n" :p += 1
	next
	notesel text_buffer
	notesave exe_path + "\\save\\supply.csv"
	PutLog "出力終了"
	exec exe_path + "\\save\\supply.csv", 16
return

//*資材グラフを表示する
*show_supply_graph
	gsel kSupplyGraphWindowID, 2
	// 描画処理
	gosub *draw_supply_graph
return

//*資材グラフの描画処理を行う
*draw_supply_graph
	if(supply_log_size < 2) :return
	// バイナリデータを読みだす
	ddim supply_time, supply_log_size
	dim supply_value, kSupplyLogKinds, supply_log_size
	p = 0
	for k, 0, supply_log_size
		// 日時
		v1 = wpeek(supply_log, p) :p += 2
		v2 =  peek(supply_log, p) :p += 1
		v3 =  peek(supply_log, p) :p += 1
		v4 =  peek(supply_log, p) :p += 1
		v5 =  peek(supply_log, p) :p += 1
		v6 =  peek(supply_log, p) :p += 1
		supply_time(k) = 1.0 * CnvFloatDay(v1, v2, v3) + CnvFloatSec(v4, v5, v6, 0.0)
		// 燃料・弾薬・鋼材・ボーキ
		supply_value(0, k) = lpeek(supply_log, p) :p += 4
		supply_value(1, k) = lpeek(supply_log, p) :p += 4
		supply_value(2, k) = lpeek(supply_log, p) :p += 4
		supply_value(3, k) = lpeek(supply_log, p) :p += 4
		// 高速修復材・開発資材・司令部レベル
		supply_value(4, k) = wpeek(supply_log, p) :p += 2
		supply_value(5, k) = wpeek(supply_log, p) :p += 2
		supply_value(6, k) =  peek(supply_log, p) :p += 1
	next
	// データを日付順にソートする
	sortval supply_time
	dim supply_value_, kSupplyLogKinds, supply_log_size
	for k, 0, supply_log_size
		sortget p, k	;a(k)に入ってる値は元はa(p)にあった
		memcpy supply_value_, supply_value, kSupplyLogKinds * 4, k * kSupplyLogKinds * 4, p * kSupplyLogKinds * 4
	next
	memcpy supply_value, supply_value_, kSupplyLogKinds * 4 * supply_log_size
	// ソートしたデータから、表示に必要な範囲におけるものを抜き出す
	last_time = supply_time(supply_log_size - 1)
	first_time = last_time - graph_scale_interval(graph_scale_index)
	first_index = 0
	for k, 1, supply_log_size - 1
		if(supply_time(k)> first_time){
			first_index = k - 1
			_break
		}
	next
	// 範囲内における上下スケールを自動で算出する
	min_value_1 = supply_value(0, 0)
	max_value_1 = supply_value(0, 0)
	min_value_2 = supply_value(4, 0)
	max_value_2 = supply_value(4, 0)
	for i, first_index, supply_log_size
		for j, 0, 4
			if(min_value_1 > supply_value(j, i)) :min_value_1 = supply_value(j, i)
			if(max_value_1 < supply_value(j, i)) :max_value_1 = supply_value(j, i)
		next
		for j, 4, 6
			if(min_value_2 > supply_value(j, i)) :min_value_2 = supply_value(j, i)
			if(max_value_2 < supply_value(j, i)) :max_value_2 = supply_value(j, i)
		next
	next
	min_value_1 = (min_value_1 / 1000) * 1000
	max_value_1 = (max_value_1 / 1000 + 1) * 1000
	min_value_2 = (min_value_2 / 100) * 100
	max_value_2 = (max_value_2 / 100 + 1) * 100
	diff_value_1 = max_value_1 - min_value_1
	diff_value_2 = max_value_2 - min_value_2
	diff_time = supply_time(supply_log_size - 1) - supply_time(first_index)
	if(diff_time <= 0) :return
	gsel kSupplyGraphWindowID
	objprm min_value_1_id, min_value_1
	objprm max_value_1_id, max_value_1
	objprm min_value_2_id, min_value_2
	objprm max_value_2_id, max_value_2
	objprm min_time_id, CnvStrDay(int(first_time))
	objprm max_time_id, CnvStrDay(int(last_time))
	// その範囲におけるグラフを別バッファに描画する
	buffer kGraphBufferID, kGraphWX2, kGraphWY2
	if(diff_value_1 != 0){
		for j, 0, 4
			switch j
				case 0	;燃料
					color $00,$80,$00
					swbreak
				case 1	;弾薬
					color $66,$33,$00
					swbreak
				case 2	;鋼材
					color $A0,$A0,$A0
					swbreak
				case 3	;ボーキ
					color $CC,$33,$00
					swbreak
			swend
			for i, 0, supply_log_size - 1
				x1 = 1.0 * (supply_time(i) - supply_time(first_index)) / diff_time * kGraphWX2
				y1 = (1.0 - 1.0 * (supply_value(j, i) - min_value_1) / (diff_value_1)) * kGraphWY2
				x2 = 1.0 * (supply_time(i + 1) - supply_time(first_index)) / diff_time * kGraphWX2
				y2 = (1.0 - 1.0 * (supply_value(j, i + 1) - min_value_1) / (diff_value_1)) * kGraphWY2
				line x1, y1, x2, y2
			next
		next
	}
	if(diff_value_2 != 0){
		for j, 4, 6
			switch j
				case 4	;バケツ
					color $F0, $80, $80
					swbreak
				case 5	;開発資材
					color $76, $99, $FF
					swbreak
			swend
			for i, 0, supply_log_size - 1
				x1 = 1.0 * (supply_time(i) - supply_time(first_index)) / diff_time * kGraphWX2
				y1 = (1.0 - 1.0 * (supply_value(j, i) - min_value_2) / (diff_value_2)) * kGraphWY2
				x2 = 1.0 * (supply_time(i + 1) - supply_time(first_index)) / diff_time * kGraphWX2
				y2 = (1.0 - 1.0 * (supply_value(j, i + 1) - min_value_2) / (diff_value_2)) * kGraphWY2
				line x1, y1, x2, y2
			next
		next
	}
	gsel kSupplyGraphWindowID
	pos POS_X(1), POS_Y(0)
	gcopy kGraphBufferID, 0, 0, kGraphWX2, kGraphWY2
	color :DrawLargeSquare POS_X(1), POS_Y(0), kGraphWX2, kGraphWY2
return

/* BGM機能に関する処理 */
//*BGM機能の画面を出す
*show_bgm_window
	gsel kBgmWindowID, 2
return

*redraw_bgm_window
	gsel kBgmWindowID
	for k, 0, kBgmKinds
		objprm k, bgm_name_list(k)
	next
return

//*BGMを追加する
*browse_bgm_1 :bgm_set_type = kBgmTypeHome   :gosub *browse_bgm :return
*browse_bgm_2 :bgm_set_type = kBgmTypeMap    :gosub *browse_bgm :return
*browse_bgm_3 :bgm_set_type = kBgmTypeBattle :gosub *browse_bgm :return
*browse_bgm_4 :bgm_set_type = kBgmTypeBoss   :gosub *browse_bgm :return
*browse_bgm
	dialog "wav;*.mp3;*.wma", 16, "音楽ファイル"
	if(stat == 0) :return
	bgm_list(bgm_set_type) += refstr + "\n"
	bgm_name_list(bgm_set_type) += getpath(refstr, 1 + 8) + "\n"
	bgm_list_size(bgm_set_type)++
	gosub *redraw_bgm_window
return

//*BGMを削除する
*del_bgm_1 :bgm_del_type = kBgmTypeHome   :gosub *del_bgm :return
*del_bgm_2 :bgm_del_type = kBgmTypeMap    :gosub *del_bgm :return
*del_bgm_3 :bgm_del_type = kBgmTypeBattle :gosub *del_bgm :return
*del_bgm_4 :bgm_del_type = kBgmTypeBoss   :gosub *del_bgm :return
*del_bgm
	if(bgm_index(bgm_del_type) < 0) :return
	notesel bgm_list(bgm_del_type)
	notedel bgm_index(bgm_del_type)
	notesel bgm_name_list(bgm_del_type)
	notedel bgm_index(bgm_del_type)
	bgm_list_size(bgm_del_type)--
	gosub *redraw_bgm_window
return

//*BGMの強制開始
*start_bgm
	bgm_flg(bgm_type_now) = 1
	gsel kBgmWindowID
	objprm kBgmKinds + bgm_type_now, bgm_flg(bgm_type_now)
	gosub *change_bgm
return

//*BGMの強制停止
*stop_bgm
	mmstop
return

//*現在状況を把握(BGM用)
*check_bgm_type
	;PutLog "　" + scene_result(0) + "　" + scene_result(1)
	bgm_type_now = -1
	if(scene_result(1) == "海域マップ") :bgm_type_now = kBgmTypeMap :return
	if(scene_result(0) == "出撃経過"){
		if(instr(battle_bgm_text,,scene_result(1)) != -1){
			if(boss_battle_flg){
				bgm_type_now = kBgmTypeBoss
			}else{
				bgm_type_now = kBgmTypeBattle
			}
			return
		}else{
			if(scene_result(1) == "ドロップ"){
				bgm_type_now = -1	;建造でもドロップ画面が出るので
			}else{
				bgm_type_now = kBgmKinds
			}
			return
		}
	}
	if(instr(home_bgm_text1,,scene_result(0)) != -1) :bgm_type_now = kBgmTypeHome :return
	if(instr(home_bgm_text2,,scene_result(1)) != -1) :bgm_type_now = kBgmTypeHome :return
return

//*BGM切り替え
*change_bgm
	;PutLog "  " + bgm_type_now
	// 不明なシーンなら無視する
	if(bgm_type_now == -1) :return
	// 特定シーンではBGMを止める
	if(bgm_type_now >= kBgmKinds) :mmstop :return
	// フラグによってBGMを鳴らすかを判定する
	if(bgm_flg(bgm_type_now)){
		// BGMを鳴らす
		notesel bgm_list(bgm_type_now)
		noteget get, rnd(bgm_list_size(bgm_type_now))
		mmload get, 0, 1
		mmplay 0
	}else{
		// BGMを止める
		mmstop
	}
return
