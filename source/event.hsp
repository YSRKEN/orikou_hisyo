/* イベント処理 */

//*情報表示
*about
	sdim about_info, 1024
	// ソフトウェア情報
	about_info += "ソフト名：" + kSoftName + "\n"
	about_info += "バージョン：" + kVersion + "\n"
	about_info += "作者：YSR\n"
	about_info += "最終更新日：" + kLastUpdate + "\n"
	// 練度表示
	if((scene_result(0) == "編成画面") && (strmid(scene_result(1), 0, 2) == "第")){
		dim level_temp, kUnitNum
		// 画像から練度を読み取る
		for k, 0, kUnitNum
			gsel kMainBufferID
			x = k \ 2
			y = k / 2
			pget 342 * x + 256, 113 * y + 153
			if(ginfo_r >= 128){
				level_temp(k) = 100
			}else{
				level_temp(k) = 0
			}
			dim number, 2
			unit_pos_x_.0 = 342 * x + unit_pos_x(0), 342 * x + unit_pos_x(1)
			ReadNumber number, 2, unit_pos_x_, 113 * y + 149, 8, 12, 85, TRUE
			NormalizeLevel number
			level_temp(k) += number(0) * 10 + number(1)
		next
		about_info += "旗艦連度：" + level_temp(0) + "\n"
		sum = 0
		for k, 0, kUnitNum
			sum += level_temp(k)
		next
		about_info += "艦隊総連度：" + sum + "\n"
	}
	dialog about_info
return

//*シーンが切り替わった際に行う処理
*check_scene_change
	// ○号カウンタ
	//演習中であることを検出する
	if((scene_result(0) == "演習出撃") && (scene_result(1) == "陣形選択")){
		exercises_flg = TRUE
	}
	if(scene_result(0) == "母港画面"){
		exercises_flg = FALSE
	}
	//自動カウント処理
	gosub *counter_auto
	// BGM機能
	//現在の状況を更新する
	gosub *check_bgm_type
	//現在の状況とチェックを元に、BGMを選曲する
	
return

//*サブ画面下の表示を更新する
*redraw_status_bar
	if(show_status_flg == FALSE) :return
	redraw 0
		// 消去する
		color $FF, $FF, $FF
		boxf 0, sub_window_size_y@(sub_window_size_index@), sub_window_size_x@(sub_window_size_index@), sub_window_size_y@(sub_window_size_index@) + show_status_flg@ * status_y@(sub_window_size_index@)
		// 書き込むための内容を準備する
		;最終更新日時
		status_bar_str = ""
		if(scene_list_index == 0){
			status_bar_str += CnvStrTime(flash_time)
		}else{
			status_bar_str += CnvStrTime(show_scene_list_time(scene_list_index - 1))
		}
		;艦隊数
		status_bar_str + = " ("
		for k, 0, kFleetNum
			if(k != 0) :status_bar_str += ", "
			status_bar_str += "" + unit_count(k)
		next
		status_bar_str += ")"
		// 書き込む
		color
		pos 0, sub_window_size_y@(sub_window_size_index@) - 2
		font "Symbol", status_y@(sub_window_size_index@) - 2
		mes status_bar_str
	redraw 1
return

//*オプション画面を表示する
*show_option
	gsel kOptionWindowID, 2
return

//*画像の保存パスを指定する
*browse_pic
	selfolder pic_save_path(1),"保存先フォルダ"
	gsel kOptionWindowID
	objprm pic_save_path_id, pic_save_path(1)
return

//*名前隠し処理
//CheckHomeFlg関数とかでkMainBufferIDではなくkSubBufferIDを引数にしているのは、
//CheckHomeFlg関数が描画先を変更する関数なので、毎回gselするのが面倒だから
*name_disable_filter
	// 母港左上の提督名
	if(CheckHomeFlg(kSubBufferID)){
		color 38, 38, 38
		boxf 111, 0, 273, 25
	}
	// その他特殊な画面に対する処理
	if(scene_result2(1) == "艦隊司令部情報"){
		color 241, 234, 221
		boxf 201, 123, 496, 153
	}
	if(scene_result2(1) == "ランキング"){
		color 54, 54, 54
		boxf 225, 153, 375, 451
	}
	if(scene_result2(1) == "演習一覧"){
		color 225, 209, 181
		boxf 338, 178, 503, 192
		color 237, 223, 207
		boxf 338, 233, 503, 247
		color 225, 209, 181
		boxf 338, 288, 503, 302
		color 237, 223, 207
		boxf 338, 343, 503, 357
		color 225, 209, 181
		boxf 338, 398, 503, 412
	}
	if(scene_result2(1) == "演習個別"){
		color 246, 239, 228
		boxf 130, 87, 425, 117
	}
	if((scene_result2(1) == "交戦結果") || (scene_result2(1) == "戦闘判定")){
		color 37, 44, 47
		boxf 92, 82, 264, 106
	}
	if((scene_result2(0) == "出撃経過") && (scene_result2(1) == "戦果報告")){
		color 37, 44, 47
		boxf 56, 82, 228, 106
	}
	if((scene_result2(0) == "遠征出撃") && (scene_result2(1) == "戦果報告")){
		color 37, 44, 47
		boxf 65, 78, 237, 102
	}
return

//*大破・消耗チェック
*check_stopper
	ShowStopperWindow stopper_type	//ウィンドウ表示
	if(show_stopper_flg1){
		// 表示を無くすかどうかの判定
		if(show_stopper_flg2){
			if((check_deadzone_flg == FALSE) && (stopper_type == kStopperDeadZone)){
				show_stopper_flg1 = FALSE
				show_stopper_flg2 = FALSE
				gsel kStopperWindowID, -1
			}
			if((check_exhausted_flg == FALSE) && (stopper_type == kStopperExhausted)){
				show_stopper_flg1 = FALSE
				show_stopper_flg2 = FALSE
				gsel kStopperWindowID, -1
			}
			if((CheckStopperType() == 0) && (scene_result(1) != "進撃確認")){
				show_stopper_flg1 = FALSE
				show_stopper_flg2 = FALSE
				gsel kStopperWindowID, -1
			}
		}else{
			if(((check_deadzone_flg) && (stopper_type == kStopperDeadZone)) || ((check_exhausted_flg) && (stopper_type == kStopperExhausted))){
				ShowStopperWindow stopper_type
			}
		}
	}else{
		// まだ表示していない場合の処理
		stopper_type = CheckStopperType()
		switch stopper_type
			case kStopperDeadZone
				if(check_deadzone_flg){
					PutLog "【大破・消耗チェック】"
					PutLog "判定結果：大破状態"
					TasktrayPopup2 "艦娘が大破しています", kSoftName, 2, 1000
					show_stopper_flg1 = TRUE
				}
			swbreak
			case kStopperExhausted
				if(check_exhausted_flg){
					PutLog "【大破・消耗チェック】"
					PutLog "判定結果：消耗状態"
					TasktrayPopup2 "艦娘が消耗しています", kSoftName, 2, 1000
					show_stopper_flg1 = TRUE
				}
			swbreak
		swend
	}
return

//*戦闘シーンを見返す
*show_battle
	gsel kMainWindowID
	objprm scene_list_id, battle_index(show_battle_type) + 1	;この+1は、「現在画面」の分のオフセット
	show_battle_type = (show_battle_type + 1) \ kBattleType
	goto *main

/* 座標習得に関する処理 */
//*艦これの画面の座標とハンドルを取得する
*get_pos
	PutLog "【座標取得】"
	// デスクトップのスクリーンショットを取得する
	dim desktop_param, kRectDim	;モニタ全体のオフセットとサイズ
	GetDesktopParam desktop_param
	DesktopScreenShot kDesktopBufferID, desktop_param
	// そこから艦これの画面を探す
	dim flash_point, kPosDim	;艦これの画面内部の座標
	switch get_pos_mode
		// オート
		case kGetPosAuto
			;艦これの画面を直接探す
			FlashPositionSearch kDesktopBufferID, flash_position
			flash_point(0) = desktop_param(0) + flash_position(0) + kFlashWX / 2
			flash_point(1) = desktop_param(1) + flash_position(1) + kFlashWY / 2
		swbreak
		// クリック
		case kGetPosClick
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面をクリックして下さい。(Escで終了)"
			mouse_click_flg = FALSE
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog "キャンセルされました。"
					break
				}
				if(key & kStickMouse){
					flash_point(0) = ginfo(0)
					flash_point(1) = ginfo(1)
					mouse_click_flg = TRUE
					break
				}
				wait 5
			loop
			gsel kSelectWindowID, -1
		swbreak
		// クロップ
		case kGetPosCrop
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面を選択して下さい。(Escで終了)"
			mouse_button_flg = FALSE
			mouse_crop_flg = FALSE
			dim rect, kRectDim
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog "キャンセルされました。"
					gsel kSelectWindowID, -1
					break
				}
				if(key & kStickMouse){
					if(mouse_button_flg){
						// 選択途中
						redraw 0
							pos 0, 0
							gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
							color
							mes "艦これの画面を選択して下さい。(Escで終了)"
							DrawMouseSquare rect(0), rect(1), mousex, mousey
						redraw 1
					}else{
						// 選択開始
						rect(0) = mousex
						rect(1) = mousey
						mouse_button_flg = TRUE
					}
				}else{
					if(mouse_button_flg){
						mouse_button_flg = FALSE
						// 選択終了
						rect(2) = mousex
						rect(3) = mousey
						;選択サイズがFlashのサイズ以上かを判定
						square_x1 = min(rect(0), rect(2))
						square_y1 = min(rect(1), rect(3))
						square_x2 = max(rect(0), rect(2))
						square_y2 = max(rect(1), rect(3))
						if((square_x2 - square_x1 >= kFlashWX) && (square_y2 - square_y1 >= kFlashWY)){
							;艦これの画面の位置を探し、その中央の位置を返す
							;(つまり、オートモードでの探索範囲を制限したVerってこと)
							dim screen_param, kRectDim
							screen_param(0) = square_x1 + desktop_param(0)
							screen_param(1) = square_y1 + desktop_param(1)
							screen_param(2) = square_x2 - square_x1
							screen_param(3) = square_y2 - square_y1
							gsel kSelectWindowID, -1
							DesktopScreenShot kDesktopBufferID, screen_param
							FlashPositionSearch kDesktopBufferID, flash_position
							flash_point(0) = screen_param(0) + flash_position(0) + kFlashWX / 2
							flash_point(1) = screen_param(1) + flash_position(1) + kFlashWY / 2
							mouse_crop_flg = TRUE
							break
						}
					}
				}
				wait 5
			loop
		swbreak
		// マニュアル
		case kGetPosManual
			;画面のスクショを最前面に表示する
			bgscr kSelectWindowID, desktop_param(2), desktop_param(3), , desktop_param(0), desktop_param(1)
			gsel kSelectWindowID, 2
			gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
			;相手に選択させる
			font msgothic, kLargeFontSize
			color
			mes "艦これの画面を選択して下さい。(Escで終了)"
			mouse_button_flg = FALSE
			mouse_manual_flg = FALSE
			dim rect, kRectDim
			repeat
				stick key, kStickMouse
				if(key & kStickEscKey){
					PutLog "キャンセルされました。"
					gsel kSelectWindowID, -1
					break
				}
				if(key & kStickMouse){
					if(mouse_button_flg){
						// 選択途中
						redraw 0
							pos 0, 0
							gcopy kDesktopBufferID, 0, 0, desktop_param(2), desktop_param(3)
							color
							mes "艦これの画面を選択して下さい。(Escで終了)"
							DrawMouseSquare rect(0), rect(1), mousex, mousey
						redraw 1
					}else{
						// 選択開始
						rect(0) = mousex
						rect(1) = mousey
						mouse_button_flg = TRUE
					}
				}else{
					if(mouse_button_flg){
						mouse_button_flg = FALSE
						// 選択終了
						rect(2) = mousex
						rect(3) = mousey
						;とりあえず中央の位置を返す(このモードだけ処理が特殊)
						flash_point(0) = desktop_param(0) + (rect(0) + rect(2)) / 2
						flash_point(1) = desktop_param(1) + (rect(1) + rect(3)) / 2
						;認識用に選択した座標・サイズを記憶しておく
						dim square, kRectDim
						square.0 = min(rect(0), rect(2))
						square.1 = min(rect(1), rect(3))
						square.2 = max(rect(0), rect(2)) - min(rect(0), rect(2))
						square.3 = max(rect(1), rect(3)) - min(rect(1), rect(3))
						gsel kSelectWindowID, -1
						mouse_manual_flg = TRUE
						break
					}
				}
				wait 5
			loop
		swbreak
	swend
	if((get_pos_mode == kGetPosClick)  && (mouse_click_flg  == FALSE)) :return
	if((get_pos_mode == kGetPosCrop)   && (mouse_crop_flg   == FALSE)) :return
	if((get_pos_mode == kGetPosManual) && (mouse_manual_flg == FALSE)) :return
	// 艦これの画面のハンドルを取得する
	window_handle = GetWindowHandle(flash_point)
	// 艦これの画面の座標を取得する
	GetWindowParam window_handle, window_param
	WindowScreenShot kDesktopBufferID, window_handle, window_param
	if(get_pos_mode != kGetPosManual){
		FlashPositionSearch kDesktopBufferID, flash_position
	}else{
		square.0 += desktop_param(0) - window_param(0)
		square.1 += desktop_param(1) - window_param(1)
		dim game_window_size, kPosDim
		GamePositionSearch kDesktopBufferID, square, flash_position, game_window_size
		if((game_window_size(0) != kFlashWX) || (game_window_size(1) != kFlashWY)){
			PutLog "画面の捕捉に失敗しました。"
			return
		}
	}
	get_pos_flg = TRUE

	PutLog "ウィンドウハンドル：" + window_handle
	PutLog "ウィンドウ左上座標：" + window_param(0) + "," + window_param(1)
	PutLog "ウィンドウサイズ：" + window_param(2) + "," + window_param(3)
	PutLog "艦これ相対左上座標：" + flash_position(0) + "," + flash_position(1)
return

//*対象の状況を監視
*check_pos
	// 画面サイズを取得できない場合
	GetWindowParam window_handle, window_param_
	if((window_param_(2) == 0) || (window_param_(3) == 0)){
		PutLog "【ズレ検出】"
		PutLog "対象を見失いました。"
		get_pos_flg = FALSE
		// ストッパー画面における処理
		show_stopper_flg1 = FALSE
		show_stopper_flg2 = FALSE
		gsel kStopperWindowID, -1
		return
	}
	// ウィンドウサイズが変わった＝画像位置が動いた可能性がある場合
	// およびウィンドウ自体が動いた場合
	if((window_param_(0) != window_param(0)) || (window_param_(1) != window_param(1)) || (window_param_(2) != window_param(2)) || (window_param_(3) != window_param(3))){
		window_param(0) = window_param_(0)
		window_param(1) = window_param_(1)
		window_param(2) = window_param_(2)
		window_param(3) = window_param_(3)
		gosub *get_pos_local
		return
	}
	// 艦これの画面の周囲のRGB値から、ズレれていると判定された場合
	if(check_move_flash_flg){
		if(CheckMoveFlash(window_handle, flash_position)){
			gosub *get_pos_local
		}
	}
return

//*艦これの座標を取得し直す
*get_pos_local
	PutLog "【ズレ検出】"
	GetWindowParam window_handle, window_param
	WindowScreenShot kDesktopBufferID, window_handle, window_param
	FlashPositionSearch kDesktopBufferID, flash_position
	PutLog "艦これ相対左上座標：" + flash_position(0) + "," + flash_position(1)
	//ストッパー画面を再表示
	show_stopper_flg2 = FALSE
	ShowStopperWindow stopper_type
return

/* 画像保存に関する処理 */
//*サブ画面に写った画像を保存する
*save_picture
	PutLog "【画像保存】"
	gsel kSubBufferID
	file_name = NowTime() + ".png"
	PicSave file_name
	PutLog "ファイル名：" + file_name
return

//*トリミング保存
*save_picture_trim
	// 編成画面におけるトリミング(編成画像)
	if((scene_result2(0) == "編成画面") && (scene_result2(1) != "ソート画面")){
		PutLog "【トリミング】"
		buffer kTempBufferID, kFleetWX, kFleetWY
		gcopy kSubBufferID, kFleetPX, kFleetPY, kFleetWX, kFleetWY
		file_name = NowTime() + ".png"
		PicSave file_name
		PutLog "ファイル名：" + file_name
		return
	}
	// ソート画面におけるトリミング(ソート画像)
	if((scene_result2(0) == "編成画面") && (scene_result2(1) == "ソート画面")){
		PutLog "【トリミング】"
		buffer kTempBufferID, kSortWX, kSortWY
		gcopy kSubBufferID, kSortPX, kSortPY, kSortWX, kSortWY
		file_name = NowTime() + ".png"
		PicSave file_name
		PutLog "ファイル名：" + file_name
		return
	}
	// 改装画面におけるトリミング(艦娘画像)
	if(scene_result2(0) == "改装画面"){
		PutLog "【トリミング】"
		if(scene_result2(1) != "近代化改修"){
			buffer kTempBufferID, kUnitWX, kUnitWY
			gcopy kSubBufferID, kUnitPX, kUnitPY, kUnitWX, kUnitWY
		}else{
			buffer kTempBufferID, kUnitWX2, kUnitWY2
			gcopy kSubBufferID, kUnitPX2, kUnitPY2, kUnitWX2, kUnitWY2
		}
		file_name = NowTime() + ".png"
		PicSave file_name
		PutLog "ファイル名：" + file_name
		return
	}
	// その他母港画面におけるトリミング(資材画像)
	if(CheckHomeFlg(kSubBufferID)){
		PutLog "【トリミング】"
		buffer kTempBufferID, kStockAllWX, kStockAllWY
		;時刻貼り付け
		pos 0, 0
		gcopy kSubBufferID, kStockTimePX, kStockTimePY, kStockTimeWX, kStockTimeWY
		;資材貼り付け
		pos kStockTimeWX, 0
		gcopy kSubBufferID, kStockOtherPX, kStockOtherPY, kStockOtherWX, kStockOtherWY
		;保存
		file_name = NowTime() + ".png"
		PicSave file_name
		PutLog "ファイル名：" + file_name
		return
	}
return

//*艦隊画像を保存
*save_fleet
	PutLog "【艦隊画像】"
	if(save_fleet_index < kFleetNum){
		// 通常艦隊を保存
		buffer kTempBufferID, kUnitWX * 3, kUnitWY * 2
		count = 0
		for y, 0, 2
			if(count >= unit_count(save_fleet_index)) :_break
			for x, 0, 3
				if(count >= unit_count(save_fleet_index)) :_break
				pos x * kUnitWX, y * kUnitWY
				gcopy GetUnitID(save_fleet_index, y * 3 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
				count++
			next
		next
	}else{
		// 連合艦隊か支援艦隊を保存
		buffer kTempBufferID, kUnitWX * 4, kUnitWY * 3
		for z, 0, 2
			count = 0
			for y, 0, 3
				if(count >= unit_count((save_fleet_index - kFleetNum) * 2 + z)) :_break
				for x, 0, 2
					if(count >= unit_count((save_fleet_index - kFleetNum) * 2 + z)) :_break
					pos (z * 2 + x) * kUnitWX, y * kUnitWY
					gcopy GetUnitID((save_fleet_index - kFleetNum) * 2, z * 6 + y * 2 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
					count++
				next
			next
		next
	}
	file_name = NowTime() + ".png"
	PicSave file_name
	PutLog "ファイル名：" + file_name
return

/* 各種タイマーに関する処理 */
//*各種タイマーの値を更新する
*check_timer
	// 入渠画面
	if((scene_result(0) == "入渠画面") && (scene_result(1) == "通常時")){
		for k, 0, kDocks
			dock_finish_time(k) = 0.0
			dock_finish_flg(k) = 0
			// ドックに誰もいなければ無視する
			gsel kMainBufferID
			if(NearColor(480, dck_pos_y(k), 33, 174, 178) == FALSE) :_continue
			// 各桁の数字を読み取って、配列に代入する
			dim number, 6
			ReadNumber number, 6, dck_pos_x, dck_pos_y(k) + 25, 11, 16, 170, FALSE
			// 正規化して、終了時刻を代入する
			NormalizeTime number
			d_time = CnvFloatSec(number(0) * 10 + number(1), number(2) * 10 + number(3), number(4) * 10 + number(5), 0)
			dock_finish_time(k) = GetFloatTime() + d_time
		next
	}
	// 工廠画面
	if((scene_result(0) == "工廠画面") && (scene_result(1) == "通常時")){
		for k, 0, kDocks
			dock_finish_time(k + kDocks) = 0.0
			dock_finish_flg(k + Docks) = 0
			// ドックに誰もいなければ無視する
			gsel kMainBufferID
			if(NearColor(730, bld_pos_y(k), 204, 128, 73) == FALSE) :_continue
			// 各桁の数字を読み取って、配列に代入する
			dim number, 6
			ReadNumber number, 6, bld_pos_x, bld_pos_y(k), 11, 16, 170, FALSE
			// 正規化して、終了時刻を代入する
			NormalizeTime number
			d_time = CnvFloatSec(number(0) * 10 + number(1), number(2) * 10 + number(3), number(4) * 10 + number(5), 0)
			dock_finish_time(k + kDocks) = GetFloatTime() + d_time
		next
	}
	// 遠征画面
	if(scene_result(1) == "遠征詳細"){
		for k, 0, kExpPagePer
			gsel kMainBufferID
			// まず旗が立っているかを判別する
			if(NearColor(517,180 + k * 30,76,168,168) == FALSE) :_continue
			// 次に、右上の遠征名とリストの遠征名が一致しているかを調べる
			// 「名前が一致している」か「全くリスト外の新遠征である」場合のみ認識対象とする
			exp_small_name = GetExpSmallName(k)
			exp_large_name = GetExpLargeName()
			if((exp_small_name != exp_large_name) && (exp_small_name != -1) && (exp_large_name != -1)) :_continue
			// そして、旗の番号を判別する
			// 遠征対象が第(unit_number + 1)艦隊となることに注意
			unit_number = 0
			if(NearColor(525,180 + k * 30,224,230,227) && NearColor(523,180 + k * 30, 84,176,174)) :unit_number = 1
			if(NearColor(525,180 + k * 30, 47,164,165) && NearColor(523,180 + k * 30,236,228,215)) :unit_number = 2
			if(NearColor(525,180 + k * 30,237,229,217) && NearColor(523,180 + k * 30,239,231,219)) :unit_number = 3
			if(unit_number == 0) :_continue
			// 各桁の数字を読み取って、配列に代入する
			dock_finish_time(unit_number - 1 + kDocks * 2) = 0.0
			dock_finish_flg(unit_number - 1 + kDocks * 2) = 0
			expedition_kind(unit_number - 1) = -1
			dim number, 6
			ReadNumber number, 6, exp_pos_x, exp_pos_y, 9, 13, 190, FALSE
			// 正規化して、終了時刻を代入する
			NormalizeTime number
			d_time = CnvFloatSec(number(0) * 10 + number(1), number(2) * 10 + number(3), number(4) * 10 + number(5), 0)
			dock_finish_time(unit_number - 1 + kDocks * 2) = GetFloatTime() + d_time
			if(exp_small_name == exp_large_name){
				expedition_kind(unit_number - 1) = exp_small_name
			}
		next
	}
return

//*各種タイマーの表示を更新する
*redraw_timer
	timer_output = "【入渠ドック】\n"
	now_time = GetFloatTime()
	for k, 0, kDocks
		time_diff = dock_finish_time(k) - now_time
		if((dock_finish_time(k) != 0.0) && (time_diff > 0.0)){
			timer_output += "" + (k + 1) + "→" + CnvStrSec2(time_diff)
			if(time_diff < 1.0 / 24 / 60){
				if(dock_finish_flg(k) == 0){
					dock_finish_flg(k) = 1
					PutLog "【終了通知】"
					PutLog "入渠―第" + (k + 1) + "ドック"
					gsel kMainWindowID
					TasktrayPopup2 "第" + (k + 1) + "ドックの\n入渠がまもなく完了します。", kSoftName, 1, 1000
				}
				timer_output += "☆"
			}
			timer_output += "\n"
		}else{
			timer_output += "" + (k + 1) + "→00:00:00\n"
			dock_finish_flg(k) = 0
		}
	next
	timer_output += "【建造ドック】\n"
	for k, 0, kDocks
		time_diff = dock_finish_time(k + kDocks) - now_time
		if((dock_finish_time(k + kDocks) != 0.0) && (time_diff > 0.0)){
			timer_output += "" + (k + 1) + "→" + CnvStrSec2(time_diff)
			if(time_diff < 1.0 / 24 / 60){
				if(dock_finish_flg(k + kDocks) == 0){
					dock_finish_flg(k + kDocks) = 1
					PutLog "【終了通知】"
					PutLog "建造―第" + (k + 1) + "ドック"
					gsel kMainWindowID
					TasktrayPopup2 "第" + (k + 1) + "ドックの\n建造がまもなく完了します。", kSoftName, 1, 1000
				}
				timer_output += "☆"
			}
			timer_output += "\n"
		}else{
			timer_output += "" + (k + 1) + "→00:00:00\n"
			dock_finish_flg(k + kDocks) = 0
		}
	next
	timer_output += "【遠征艦隊】\n"
	for k, 0, kFleetNum - 1
		time_diff = dock_finish_time(k + kDocks * 2) - now_time
		if((dock_finish_time(k + kDocks * 2) != 0.0) && (time_diff > 0.0)){
			timer_output += "" + (k + 2) + "→" + CnvStrSec2(time_diff)
			if(time_diff < 1.0 / 24 / 60){
				if(dock_finish_flg(k + kDocks * 2) == 0){
					dock_finish_flg(k + kDocks * 2) = 1
					PutLog "【終了通知】"
					if(expedition_kind(k) != -1){
						PutLog "遠征―第" + (k + 2) + "艦隊" + "(" + exped_name(expedition_kind(k)) + ")"
					}else{
						PutLog "遠征―第" + (k + 2) + "艦隊"
					}
					gsel kMainWindowID
					TasktrayPopup2 "第" + (k + 2) + "艦隊の\n遠征がまもなく完了します。", kSoftName, 1, 1000
				}
				timer_output += "☆"
			}else{
				timer_output += "　"
			}
			if(expedition_kind(k) != -1){
				timer_output += exped_name(expedition_kind(k)) + "\n"
			}else{
				timer_output += "？\n"
			}
		}else{
			timer_output += "" + (k + 2) + "→00:00:00\n"
			dock_finish_flg(k + kDocks * 2) = 0
		}
	next
	gsel kTimerWindowID
	objprm 0, timer_output
return

//*各種タイマーを表示する
*show_timer
	gsel kTimerWindowID, 2
return

/* ソート一覧に関する処理 */
//*ソート一覧を表示する
*show_sort_list
	gsel kSortListWindowID, 2
return

//*ソート一覧に追加する
*add_sort_list
	if((scene_result2(0) == "編成画面") && (scene_result2(1) == "ソート画面") && (sort_list_size < kMaxSortPages)){
		sort_list += NowTime() + "\n"
		gsel kSortListBufferID
		pos sort_list_size * kSortWX, 0
		gcopy kSubBufferID, kSortPX, kSortPY, kSortWX, kSortWY
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
		sort_list_size++
		title "ソート一覧(" + sort_list_size + "枚)"
	}
return

//*ソート一覧からまとめ画像を生成する
*make_sort_list
	if(sort_list_size <= 0) :return
	PutLog "【ソート一覧画像】"
	// 普通のバージョン(練度をベタッと並べていく)と特殊バージョン(艦種別・練度順で並べていく)で処理が違う
	if(sort_width_index < 5){
		// 出力用バッファを準備
		LX = (sort_width_index + 1)
		LY = sort_list_size / (sort_width_index + 1)
		if(sort_list_size \ (sort_width_index + 1) != 0) :LY++
		ListSizeX = LX * kSortWX
		ListSizeY = LY * kSortWY
		buffer kTempBufferID, ListSizeX, ListSizeY
		// どんどん書き込んでいく
		for k, 0, sort_list_size
			if(direction_flg == 0){
				x = k / LY
				y = k \ LY
			}else{
				x = k \ LX
				y = k / LX
			}
			pos x * kSortWX, y * kSortWY
			gcopy kSortListBufferID, k * kSortWX, 0, kSortWX, kSortWY
		next
	}else{
		// リストを一通り読み込む
		dim list_type, kSortListHeight * sort_list_size
		dim list_level, kSortListHeight * sort_list_size
		sdim list_pos, 64, kSortListHeight * sort_list_size
		kammusues = 0
		sdim temp, kSortStrLength
		for i, 0, sort_list_size
			for j, 0, kSortListHeight
				gsel kSortListBufferID
				// 画像からデータを読み込む
				temp = ""
				for k, 0, kSortStrLength
					pget i * kSortWX + k + 2, kSortWY2 * j + 12
					if(ginfo_r < 128){
						temp += "1"
					}else{
						temp += "0"
					}
				next
				// 艦種を判別する(一番近い艦種を求める)
				min_diff = kSortStrLength + 1
				best_type = -1
				for k, 0, kSortType
					diff = 0
					for m, 0, kSortStrLength
						if(strmid(temp, m, 1) != strmid(sort_type_str(k), m, 1)) :diff++
					next
					if(diff < min_diff){
						min_diff = diff
						best_type = k
					}
				next
				if(sort_type_name(best_type) == "なし") :_continue
				list_pos(kammusues) = "" + i + "," + j
				list_type(kammusues) = best_type
				// レベルを読み取る
				//ケッコンしているかを判定(指輪ではなく純粋に100の位を見ている)
				pget i * kSortWX + 158, kSortWY2 * j + 12
				if(ginfo_r < 150){
					list_level(kammusues) = 100
				}else{
					list_level(kammusues) = 0
				}
				//数字部分は文字認識で判定
				sort_pos_x_.0 = i * kSortWX + sort_pos_x(0), i * kSortWX + sort_pos_x(1)
				dim number, 2
				ReadNumber number, 2, sort_pos_x_, kSortWY2 * j + 8, 8, 12, 190, FALSE
				NormalizeLevel number
				list_level(kammusues) += number(0) * 10 + number(1)
				kammusues++
			next
		next
		// 読み込んだ結果を艦種・レベル毎にソートする
		for i, 0, kammusues - 1
			for j, i + 1, kammusues
				flg = 0
				if(list_type(i) > list_type(j)){
					flg = 1
				}else{
					if(list_type(i) == list_type(j)){
						if(list_level(i) < list_level(j)){
							flg == 1
						}
					}
				}
				if(flg){
					temp = list_type(i)  :list_type(i)  = list_type(j)  :list_type(j)  = temp
					temp = list_level(i) :list_level(i) = list_level(j) :list_level(j) = temp
					temp = list_pos(i)   :list_pos(i)   = list_pos(j)   :list_pos(j)   = temp
				}
			next
		next
		// ソート結果から、出力ファイルを生成する
		LX = int(sqrt(kammusues) / 3)
		LY = kammusues / LX
		if(kammusues \ LX != 0) :LY++
		ListSizeX = LX * kSortWX
		ListSizeY = LY * kSortWY3
		buffer kTempBufferID, ListSizeX, ListSizeY
		// どんどん書き込んでいく
		for k, 0, kammusues
			x = k / LY
			y = k \ LY
			pos x * kSortWX, y * kSortWY3
			split list_pos(k), ",", temp
			px = int(temp(0))
			py = int(temp(1))
			gcopy kSortListBufferID, px * kSortWX, sort_pos_y(py), kSortWX, kSortWY3
		next
	}
	file_name = NowTime() + ".png"
	PicSave file_name
	PutLog "ファイル名：" + file_name
return

//*ソート一覧で選択項目を上げる
*upper_sort_list
	if((sort_index >= 1) && (sort_index < sort_list_size)){
		;バッファの入れ替え
		buffer kTempBufferID, kSortWX, kSortWY
			gcopy kSortListBufferID, sort_index * kSortWX, 0, kSortWX, kSortWY
		gsel kSortListBufferID
			pos sort_index * kSortWX, 0
				gcopy kSortListBufferID, (sort_index - 1) * kSortWX, 0, kSortWX, kSortWY
			pos (sort_index - 1) * kSortWX, 0
				gcopy kTempBufferID, 0, 0, kSortWX, kSortWY
		;リストの入れ替え
		notesel sort_list
		noteget text_buffer,  sort_index - 1
		noteget text_buffer2, sort_index
		noteadd text_buffer2, sort_index - 1, 1
		noteadd text_buffer,  sort_index,     1
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
	}
return

//*ソート一覧で選択項目を下げる
*lower_sort_list
	if((sort_index >= 0) && (sort_index < sort_list_size - 1)){
		;バッファの入れ替え
		buffer kTempBufferID, kSortWX, kSortWY
			gcopy kSortListBufferID, sort_index * kSortWX, 0, kSortWX, kSortWY
		gsel kSortListBufferID
			pos sort_index * kSortWX, 0
				gcopy kSortListBufferID, (sort_index + 1) * kSortWX, 0, kSortWX, kSortWY
			pos (sort_index + 1) * kSortWX, 0
				gcopy kTempBufferID, 0, 0, kSortWX, kSortWY
		;リストの入れ替え
		notesel sort_list
		noteget text_buffer,  sort_index + 1
		noteget text_buffer2, sort_index
		noteadd text_buffer2, sort_index + 1, 1
		noteadd text_buffer,  sort_index,     1
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
	}
return

//*ソート一覧で選択項目を削除する
*del_sort_list
	if((sort_index >= 0) && (sort_index < sort_list_size)){
		;バッファの削除
		gsel kSortListBufferID
		for k, sort_index, sort_list_size - 1
			pos k * kSortWX
			gcopy kSortListBufferID, (k + 1) * kSortWX, 0, kSortWX, kSortWY
		next
		;リストの削除
		notesel sort_list
		notedel sort_index
		gsel kSortListWindowID
		objprm sort_index_id, sort_list
		sort_list_size--
		if(sort_list_size > 0){
			title "ソート一覧(" + sort_list_size + "枚)"
		}else{
			title "ソート一覧"
		}
	}
return

//*ソート一覧で項目を全削除する
*alldel_sort_list
	dialog "項目を全削除しますか？", 2, kSoftName
	if(stat == 6){
		gsel kSortListBufferID
		color 255, 255, 255 :boxf
		gsel kSortListWindowID
		sort_list = ""
		objprm sort_index_id, sort_list
		sort_list_size = 0
		title "ソート一覧"
	}
return

//*選択位置が変わった際に表示する画像を変更する
*redraw_sort_preview
	if((sort_index_ != sort_index) && (sort_index >= 0)){
		gsel kSortListWindowID
		POS_XY 2, 0
		gzoom2 SIZE_X(2), SIZE_Y(8), kSortListBufferID, sort_index * kSortWX, 0, kSortWX, kSortWY
		sort_index_ = sort_index
	}
return

/* 経験値計算機に関する処理 */
//*計算機の画面を表示する
*show_exp_calc
	gsel kExpCalcWindowID, 2
return

//*経験値を計算し、反映する
*exp_calc
	// 補完機能についての処理
	if((exp_ss_flg) && (scene_result(0) == "編成画面") && (strmid(scene_result(1), 0, 2) == "第")){
		// レベル補間
		if(exp_option_index != 1){
			// 画像から練度を読み取る
			gsel kMainBufferID
			x = exp_unit_index \ 2
			y = exp_unit_index / 2
			pget 342 * x + 256, 113 * y + 153
			if(ginfo_r >= 128){
				now_level_ = 100
			}else{
				now_level_ = 0
			}
			dim number, 2
			unit_pos_x_.0 = 342 * x + unit_pos_x(0), 342 * x + unit_pos_x(1)
			dim number, 2
			ReadNumber number, 2, unit_pos_x_, 113 * y + 149, 8, 12, 85, TRUE
			NormalizeLevel number
			now_level__ = number(0) * 10 + number(1)
			if(now_level_ + now_level__ > 0){
				now_level = now_level_ + now_level__ - 1	//-1するのはコンボボックスの都合
				// 読み取った練度を画面に反映する
				gsel kExpCalcWindowID
				objprm now_level_id, now_level
			}
		}
		// 経験値補間
		if(exp_option_index != 0){
			// 画像から経験値の割合を読み取る
			gsel kMainBufferID
			unit_exp_double = 1.0
			x = exp_unit_index \ 2
			y = exp_unit_index / 2
			for k, 0, 160
				if(NearColor(342 * x + 284 + k, 113 * y + 194, 165, 232, 208) == FALSE){
					unit_exp_double = 1.0 * k / 160
					_break
				}
			next
			// 練度の値から、経験値補正がどれほどあるかを算出する
			if(now_level + 1 != 150){
				now_exp_plus = int(unit_exp_double * (need_exp_table(now_level + 1) - need_exp_table(now_level)))
			}else{
				now_exp_plus = 0
			}
		}else{
			now_exp_plus = 0
		}
	}else{
		now_exp_plus = 0
	}
	// レベル補正についての処理
	if(now_level > goal_level){
		if(now_level != now_level_){
			goal_level = now_level
			gsel kExpCalcWindowID
			objprm goal_level_id, goal_level
		}
		if(goal_level != goal_level_){
			now_level = goal_level
			gsel kExpCalcWindowID
			objprm now_level_id, now_level
		}
	}
	// 経験値の計算処理
	//必要経験値を計算
	now_exp = need_exp_table(now_level) + now_exp_plus
	goal_exp = need_exp_table(goal_level)
	need_exp = goal_exp - now_exp
	//戦闘経験値を計算
	battle_exp = 1.0 * exp_data(area_index)
	if(reader_ship_flg) :battle_exp *= 1.5
	if(mvp_flg) :battle_exp *= 2.0
	switch result_index
		case 0	;完全S
			battle_exp *= 1.2
			swbreak
		case 1	;勝利S
			battle_exp *= 1.2
			swbreak
		case 2	;勝利A
			battle_exp *= 1.0
			swbreak
		case 3	;勝利B
			battle_exp *= 1.0
			swbreak
		case 4	;敗北C
			battle_exp *= 0.8
			swbreak
		case 5	;敗北D
			battle_exp *= 0.7
			swbreak
		case 6	;敗北E
			battle_exp *= 0.5
			if(mvp_flg) :battle_exp *= 0.5	;MVP無効
	swend
	battle_exp = int(battle_exp)
	//必要周回数を計算
	need_battles = need_exp / battle_exp
	if(need_exp \ battle_exp != 0) :need_battles++
	// 出力処理
	gsel kExpCalcWindowID
	objprm need_exp_id, need_exp
	objprm battle_exp_id, battle_exp
	objprm need_battles_id, need_battles
return

//*計算機の更新をチェックする
*check_exp_calc
	if(now_level_        != now_level)        :gosub *exp_calc :now_level_        = now_level
	if(goal_level_       != goal_level)       :gosub *exp_calc :goal_level_       = goal_level
	if(area_index_       != area_index)       :gosub *exp_calc :area_index_       = area_index
	if(result_index_     != result_index)     :gosub *exp_calc :result_index_     = result_index
	if(reader_ship_flg_  != reader_ship_flg)  :gosub *exp_calc :reader_ship_flg_  = reader_ship_flg
	if(mvp_flg_          != mvp_flg)          :gosub *exp_calc :mvp_flg_          = mvp_flg
	if(exp_ss_flg_       != exp_ss_flg)       :gosub *exp_calc :exp_ss_flg_       = exp_ss_flg
	if(exp_unit_index_   != exp_unit_index)   :gosub *exp_calc :exp_unit_index_   = exp_unit_index
	if(exp_option_index_ != exp_option_index) :gosub *exp_calc :exp_option_index_ = exp_option_index
return

/* ○号カウンタに関する処理 */
//*○号カウンタを表示する
*show_counter
	gsel kCounterWindowID, 2
return

//*○号カウンタを更新する
*redraw_counter
	if((count_num(0) >= 36) && (count_num(1) >= 24) && (count_num(2) >= 12) && (count_num(3) >= 6)){
		counter_output = "【あ号(達成)】\n"
	}else{
		counter_output = "【あ号(未達成)】\n"
	}
	counter_output += "海域出撃：" + count_num(0) + " / 36回"
	if(count_num(0) >= 36) :counter_output += "(OK)"
	counter_output += "\nボス到達：" + count_num(1) + " / 24回"
	if(count_num(1) >= 24) :counter_output += "(OK)"
	counter_output += "\nボス勝利" + count_num(2) + " / 12回"
	if(count_num(2) >= 12) :counter_output += "(OK)"
	counter_output += "\nS勝利判定" + count_num(3) + " / 6回"
	if(count_num(3) >= 6) :counter_output += "(OK)"

	if(count_num(4) >= 50){
		counter_output += "\n【ろ号(達成)】"
	}else{
		counter_output += "\n【ろ号(未達成)】"
	}
	counter_output += "\n補給船撃沈：" + count_num(4) + " / 50回\n"

	if(count_num(5) >= 20){
		counter_output += "【い号(達成)】\n"
	}else{
		counter_output += "【い号(未達成)】\n"
	}
	counter_output += "空母系撃沈：" + count_num(5) + " / 20回"
	gsel kCounterWindowID
	objprm 0, counter_output
return

//*ボタン操作
*counter_type_1 :count_num(0)++ :redraw_counter_flg = TRUE :return
*counter_type_2 :count_num(1)++ :redraw_counter_flg = TRUE :return
*counter_type_3 :count_num(2)++ :redraw_counter_flg = TRUE :return
*counter_type_4 :count_num(3)++ :redraw_counter_flg = TRUE :return
*counter_type_5 :count_num(4)++ :redraw_counter_flg = TRUE :return
*counter_type_6 :count_num(5)++ :redraw_counter_flg = TRUE :return

*counter_reset_1 :count_num(0) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_2 :count_num(1) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_3 :count_num(2) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_4 :count_num(3) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_5 :count_num(4) = 0 :redraw_counter_flg = TRUE :return
*counter_reset_6 :count_num(5) = 0 :redraw_counter_flg = TRUE :return

//*カウンターの自動更新処理
*counter_auto
	//海域出撃カウント
	if((pre_scene_type == "海域出撃") && (pre_scene_name == "艦隊選択") && (scene_result(1) == "出撃画面")){
		if(auto_count_flg(0) && (exercises_flg == FALSE)){
			count_num(0)++
			redraw_counter_flg = TRUE
		}
	}
	//ボス到達カウント
	if(pre_scene_name == "海域マップ"){
		// HSPはIF文の判定途中で処理を切り上げないので、
		// こうして処理を分けないとpre_scene_name != "海域マップ"でも
		// CheckBossOfAeraMap()が実行されてしまう
		if(CheckBossOfAeraMap()){
			if(auto_count_flg(1) && (exercises_flg == FALSE)){
				count_num(1)++
				redraw_counter_flg = TRUE
			}
			boss_battle_flg = TRUE
		}
	}
	if(scene_result(0) == "母港画面"){
		boss_battle_flg = FALSE
	}
	if(scene_result(1) == "戦果報告"){
		//ボス勝利カウント
		if((boss_battle_flg) && (battle_rank < kBattleRankLoss)){
			if(auto_count_flg(2) && (exercises_flg == FALSE)){
				count_num(2)++
				redraw_counter_flg = TRUE
			}
			boss_battle_flg = FALSE
		}
		//S勝利判定カウント
		if(battle_rank == kBattleRankS){
			if(auto_count_flg(3) && (exercises_flg == FALSE)){
				count_num(3)++
				redraw_counter_flg = TRUE
			}
		}
	}
	if(scene_result(1) == "交戦結果"){
		// 最後の戦闘が昼戦か夜戦かを、最終更新日時で判断する
		if(show_scene_list_time(battle_index(0)) > show_scene_list_time(battle_index(1))){
			gsel kSceneBufferID + battle_index(0)
		}else{
			gsel kSceneBufferID + battle_index(1)
		}
		//輸送船撃沈カウント
		for k, 0, kUnitNum
			if(NearColor(767,173 + 45 * k,77,166,223)){
				if(NearColor(669,178 + 45 * k,254,254,254)){
					if(NearColor(649,157 + 45 * k,133,133,133)){
						if(auto_count_flg(4) && (exercises_flg == FALSE)){
							count_num(4)++
							redraw_counter_flg = TRUE
						}
					}
				}
			}
		next
		//空母系撃沈カウント
		for k, 0, kUnitNum
			if(NearColor(767,173 + 45 * k,77,166,223)){
				;正規空母
				if(NearColor(670,176 + 45 * k,167,167,167)){
					if(NearColor(671,157 + 45 * k,215,215,215)){
						if(auto_count_flg(5) && (exercises_flg == FALSE)){
							count_num(5)++
							redraw_counter_flg = TRUE
						}
					}
				}
				;軽空母
				if(NearColor(667,177 + 45 * k,183,183,183)){
					if(NearColor(664,170 + 45 * k,252,252,252)){
						if(auto_count_flg(5) && (exercises_flg == FALSE)){
							count_num(5)++
							redraw_counter_flg = TRUE
						}
					}
				}
			}
		next
	}
return

/* cond値メータに関する処理 */
//*cond値メータを表示する
*show_cond_meter
	gsel kCondMeterWindowID, 2
return

//*cond値メータを更新する
*redraw_cond
	// cond値を正規化する
	for k, 0, kUnitNum
		cond(k) = limit(cond(k), 0, 100)
	next
	// 表示を修正する
	for k, 0, kUnitNum
		cond_msg(k) = "" + (k + 1) + "番艦・"
		if(cond(k) >= 50) :cond_msg(k) += "キラ" :_continue
		if(cond(k) >= 40) :cond_msg(k) += "通常" :_continue
		if(cond(k) >= 30) :cond_msg(k) += "間宮" :_continue
		if(cond(k) >= 20) :cond_msg(k) += "橙点灯" :_continue
		cond_msg(k) += "赤点灯"
	next
	// 結果を反映する
	if(auto_calc_flg){
		gsel kCondMeterWindowID
		for k, 0, kUnitNum
			objprm cond_id + k, cond(k)
			objprm cond_msg_id + k, cond_msg(k)
		next
	}
return

//*オブジェクトの状態を変更する
*cond_enable
	gsel kCondMeterWindowID
	switch cond_step
		case 0
			for k, 0, 3
				objenable battle_type_id + k, 1
			next
			for k, 0, 6
				objenable win_type_id + k, 0
			next
			for k, 0, kUnitNum
				objenable mvp_id + k, 0
			next
			for k, 0, kUnitNum
				objenable cond_reset_id + k,1 
			next
			objenable set_kira3_id, 1
			objenable return_home_id, 1
		swbreak
		case 1
			for k, 0, 3
				objenable battle_type_id + k, 0
			next
			for k, 0, 6
				objenable win_type_id + k, 1
			next
			for k, 0, kUnitNum
				objenable mvp_id + k, 0
			next
			for k, 0, kUnitNum
				objenable cond_reset_id + k, 0
			next
			objenable set_kira3_id, 0
			objenable return_home_id, 0
		swbreak
		case 2
			for k, 0, 3
				objenable battle_type_id + k, 0
			next
			for k, 0, 6
				objenable win_type_id + k, 0
			next
			for k, 0, kUnitNum
				objenable mvp_id + k, 1
			next
			for k, 0, kUnitNum
				objenable cond_reset_id + k, 0
			next
			objenable set_kira3_id, 0
			objenable return_home_id, 0
		swbreak
		case 3
			gosub *cond_calc
			cond_step = 0
			gosub *cond_enable
		swbreak
	swend
return

//*cond値を更新する
*cond_calc
	// 戦闘突入時の増減
	if(battle_type < 2){
		for k, 0, kUnitNum
			if(cond(k) >= 30){
				cond(k) -= 3
			}else{
				cond(k) -= 9
			}
		next
	}
	if(battle_type > 0){
		for k, 0, kUnitNum
			cond(k) -= 2
		next
	}
	for k, 0, kUnitNum
		if(cond(k) < 0) :cond(k) = 0
	next
	// MVP獲得による増加
	cond(mvp_num) += 10
	// 旗艦補正
	if(win_type != 5) :cond(0) += 3
	// 戦闘結果による増減
	for k, 0, kUnitNum
		switch win_type
			case 0	;完全S
				cond(k) += 4
			swbreak
			case 1	;勝利S
				cond(k) += 4
			swbreak
			case 2	;勝利A
				cond(k) += 3
			swbreak
			case 3	;勝利B
				cond(k) += 2
			swbreak
			case 4	;勝利C
				cond(k) += 1
			swbreak
		swend
	next
return

//*交戦形態
*battle_type_1 :battle_type = 0 :cond_step = 1 :return
*battle_type_2 :battle_type = 1 :cond_step = 1 :return
*battle_type_3 :battle_type = 2 :cond_step = 1 :return

//*戦闘結果
*win_type_ss :win_type = 0 :cond_step = 2 :return
*win_type_s  :win_type = 1 :cond_step = 2 :return
*win_type_a  :win_type = 2 :cond_step = 2 :return
*win_type_b  :win_type = 3 :cond_step = 2 :return
*win_type_c  :win_type = 4 :cond_step = 2 :return
*win_type_de :win_type = 5 :cond_step = 2 :return

//*MVP
*mvp_1 :mvp_num = 0 :cond_step = 3 :return
*mvp_2 :mvp_num = 1 :cond_step = 3 :return
*mvp_3 :mvp_num = 2 :cond_step = 3 :return
*mvp_4 :mvp_num = 3 :cond_step = 3 :return
*mvp_5 :mvp_num = 4 :cond_step = 3 :return
*mvp_6 :mvp_num = 5 :cond_step = 3 :return

//*リセット
*cond_reset_1 :cond(0) = 49 :return
*cond_reset_2 :cond(1) = 49 :return
*cond_reset_3 :cond(2) = 49 :return
*cond_reset_4 :cond(3) = 49 :return
*cond_reset_5 :cond(4) = 49 :return
*cond_reset_6 :cond(5) = 49 :return

//*その他
*set_kira3
	for k, 0, kUnitNum
		cond(k) = 85
	next
return
*auto_recover
	for k, 0, kUnitNum
		if(cond(k) < 49){
			cond(k) = 49
		}
	next
return
*return_home
	for k, 0, kUnitNum
		if(cond(k) > 30){
			cond(k) -= 15
		}else{
			cond(k) -= 30
		}
	next
return
*reset_all
	for k, 0, kUnitNum
		cond(k) = 49
	next
	cond_step = 0
	gosub *cond_enable
return

/* 資材ログに関する処理 */
//*資材ログに追記する
*put_supply_log
	if(flash_time - supply_last_time >= kPutSupplyLogInterval){
		if(CheckHomeFlg(kMainBufferID) == FALSE) :return
		supply_last_time = flash_time
		PutLog "【資材ログ】"
		GetSupply supply_list
		// バッファを再作成してコピーする
		sdim supply_log_, (supply_log_size + 1) * kSupplyLogBlockSize
		memcpy supply_log_, supply_log, supply_log_size * kSupplyLogBlockSize
		// 書き込む
		p = supply_log_size * kSupplyLogBlockSize
		//日時
		wpoke supply_log_, p, gettime(0) :p += 2
		poke  supply_log_, p, gettime(1) :p += 1
		poke  supply_log_, p, gettime(3) :p += 1
		poke  supply_log_, p, gettime(4) :p += 1
		poke  supply_log_, p, gettime(5) :p += 1
		poke  supply_log_, p, gettime(6) :p += 1
		//燃料・弾薬・鋼材・ボーキ
		lpoke supply_log_, p, supply_list(0) :p += 4
		lpoke supply_log_, p, supply_list(1) :p += 4
		lpoke supply_log_, p, supply_list(2) :p += 4
		lpoke supply_log_, p, supply_list(3) :p += 4
		//高速修復材・開発資材・司令部レベル
		wpoke supply_log_, p, supply_list(4) :p += 2
		wpoke supply_log_, p, supply_list(5) :p += 2
		poke supply_log_, p, supply_list(6)
		// 再コピーしてからファイルに保存する
		sdim supply_log, (supply_log_size + 1) * kSupplyLogBlockSize
		memcpy supply_log, supply_log_, (supply_log_size + 1) * kSupplyLogBlockSize
		bsave exe_path + "\\save\\supply.dat", supply_log, (supply_log_size + 1) * kSupplyLogBlockSize
		supply_log_size++
		PutLog "追記完了"
	}
return

//*資材グラフを表示する
*show_supply_graph
	//dialog "未実装です……。", 0, kSoftName
	PutLog "【資材グラフ】"
	sdim text_buffer, 64
	text_buffer += "日付,燃料,弾薬,鋼材,ボーキ,高速修復材,開発資材,司令部レベル\n"
	p = 0
	for k, 0, supply_log_size
		if(time != gettime(6)){
			PutLog "出力率：" + strf("%.1f", 100.0 * (k + 1) / supply_log_size) + "％"
			time = gettime(6)
		}
		// 日時
		text_buffer += strf("%04d-", wpeek(supply_log, p)) :p += 2
		text_buffer += strf("%02d-",  peek(supply_log, p)) :p += 1
		text_buffer += strf("%02d ",  peek(supply_log, p)) :p += 1
		text_buffer += strf("%02d:",  peek(supply_log, p)) :p += 1
		text_buffer += strf("%02d:",  peek(supply_log, p)) :p += 1
		text_buffer += strf("%02d,",  peek(supply_log, p)) :p += 1
		// 燃料・弾薬・鋼材・ボーキ
		text_buffer += "" + lpeek(supply_log, p) + "," :p += 4
		text_buffer += "" + lpeek(supply_log, p) + "," :p += 4
		text_buffer += "" + lpeek(supply_log, p) + "," :p += 4
		text_buffer += "" + lpeek(supply_log, p) + "," :p += 4
		// 高速修復材・開発資材・司令部レベル
		text_buffer += "" + wpeek(supply_log, p) + ","  :p += 2
		text_buffer += "" + wpeek(supply_log, p) + ","  :p += 2
		text_buffer += "" +  peek(supply_log, p) + "\n" :p += 1
	next
	notesel text_buffer
	notesave exe_path + "\\save\\supply.csv"
	PutLog "出力終了"
	exec exe_path + "\\save\\supply.csv", 16
return

/* BGM機能に関する処理 */
//*BGM機能の画面を出す
*show_bgm_window
	gsel kBgmWindowID, 2
return

*redraw_bgm_window
	gsel kBgmWindowID
	for k, 0, kBgmKinds
		objprm k, bgm_name_list(k)
	next
return

//*BGMを追加する
*browse_bgm_1 :bgm_set_type = kBgmTypeHome   :gosub *browse_bgm :return
*browse_bgm_2 :bgm_set_type = kBgmTypeMap    :gosub *browse_bgm :return
*browse_bgm_3 :bgm_set_type = kBgmTypeBattle :gosub *browse_bgm :return
*browse_bgm_4 :bgm_set_type = kBgmTypeBoss   :gosub *browse_bgm :return
*browse_bgm
	dialog "wav;*.mp3;*.wma", 16, "音楽ファイル"
	if(stat == 0) :return
	bgm_list(bgm_set_type) += refstr + "\n"
	bgm_name_list(bgm_set_type) += getpath(refstr, 1 + 8) + "\n"
	bgm_list_size(bgm_set_type)++
	gosub *redraw_bgm_window
return

//*BGMを削除する
*del_bgm_1 :bgm_del_type = kBgmTypeHome   :gosub *del_bgm :return
*del_bgm_2 :bgm_del_type = kBgmTypeMap    :gosub *del_bgm :return
*del_bgm_3 :bgm_del_type = kBgmTypeBattle :gosub *del_bgm :return
*del_bgm_4 :bgm_del_type = kBgmTypeBoss   :gosub *del_bgm :return
*del_bgm
	if(bgm_index(bgm_del_type) < 0) :return
	notesel bgm_list(bgm_del_type)
	notedel bgm_index(bgm_del_type)
	notesel bgm_name_list(bgm_del_type)
	notedel bgm_index(bgm_del_type)
	bgm_list_size(bgm_del_type)--
	gosub *redraw_bgm_window
return

//*BGMの強制開始
*start_bgm
	bgm_flg(bgm_type_now) = 1
	gsel kBgmWindowID
	objprm kBgmKinds + bgm_type_now, bgm_flg(bgm_type_now)
	gosub *change_bgm
return

//*BGMの強制停止
*stop_bgm
	mmstop
return

//*現在状況を把握(BGM用)
*check_bgm_type
	;PutLog "　" + scene_result(0) + "　" + scene_result(1)
	bgm_type_now = -1
	if(scene_result(1) == "海域マップ") :bgm_type_now = kBgmTypeMap :return
	if(scene_result(0) == "出撃経過"){
		if(instr(battle_bgm_text,,scene_result(1)) != -1){
			if(boss_battle_flg){
				bgm_type_now = kBgmTypeBoss
			}else{
				bgm_type_now = kBgmTypeBattle
			}
			return
		}else{
			if(scene_result(1) == "ドロップ"){
				bgm_type_now = -1	;建造でもドロップ画面が出るので
			}else{
				bgm_type_now = kBgmKinds
			}
			return
		}
	}
	if(instr(home_bgm_text1,,scene_result(0)) != -1) :bgm_type_now = kBgmTypeHome :return
	if(instr(home_bgm_text2,,scene_result(1)) != -1) :bgm_type_now = kBgmTypeHome :return
return

//*BGM切り替え
*change_bgm
	;PutLog "  " + bgm_type_now
	// 不明なシーンなら無視する
	if(bgm_type_now == -1) :return
	// 特定シーンではBGMを止める
	if(bgm_type_now >= kBgmKinds) :mmstop :return
	// フラグによってBGMを鳴らすかを判定する
	if(bgm_flg(bgm_type_now)){
		// BGMを鳴らす
		notesel bgm_list(bgm_type_now)
		noteget get, rnd(bgm_list_size(bgm_type_now))
		mmload get, 0, 1
		mmplay 0
	}else{
		// BGMを止める
		mmstop
	}
return
