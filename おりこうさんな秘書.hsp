/* おりこうさんな秘書 改四
 */

	#packopt name "おりこうさんな秘書改四"
	#include "hspcv.as"		;画像処理でOpenCVを使うためのライブラリ

// 通常の定数
	// 真偽
	#const global TRUE  1
	#const global FALSE 0
	// 画面ID
	#enum kMainWindowID = 0	;操作画面
	#enum kPutWindowID		;画像表示用画面
	#enum kPutTempWindowID	;kPutWindowID用バッファ
	#enum kSubWindowID		;手動指定用画面
	#enum kDeskBufferID		;スクショ用
	#enum kFlashBufferID	;検索用
	#enum kTempBufferID		;テンポラリ用
	#const kOffsetBufferID 10
	// OpenCV用ID
	#const kCVDeskBufferID  0
	#const kPutBufferID     1
	#const kCVTempBufferID  2
	// サイズ定義
	;デスクトップ全体のサイズ
	#define global kDispX ginfo_dispx
	#define global kDispY ginfo_dispy
	;Flash画面のサイズ
	#const  global kFlashWX 800
	#const  global kFlashWY 480
	;編成画面のサイズ
	#const kUnitWX 455
	#const kUnitWY 365
	;編成画面のオフセット座標
	#const kUnitPX 330
	#const kUnitPY 100
	;フォントサイズ
	#const kLargeFontSize 30
	;オブジェクト関係
	#const kObjX 80
	#const kObjY 20
	#const kObjSpace 10
	#const kObjSpaceX kObjSpace + kObjX
	#const kObjSpaceY kObjSpace + kObjY
	// キーボード・マウス操作
	#const kStickEscKey 128
	#const kStickMouse  256
	// パラメータ
	#const global kFleetNum 4	;艦隊数
	#const global kUnitNum 6	;艦隊毎の艦娘数
	// 画面状態(type_strと対応)
	#enum global  kTypeUnknown = 0
	#enum global  kTypeHome		;母港画面
	#enum global  kTypeInfo		;戦績表示
	#enum global  kTypeFactory	;工廠画面
	#enum global  kTypeMap		;マップ画面
	#enum global  kTypeBattle	;戦闘画面
	#enum global  kTypeResult1	;戦果報告(交戦結果)
	#enum global  kTypeResult2	;戦果報告(経験値・MVP表示)
	#enum global  kTypeFleet	;編成画面
	kTypeUnit = kTypeFleet + kFleetNum	;改装画面
	// アプリ機能(mode_strと対応)
	#enum global  kModeNow = 0
	#enum global  kModeHome		;母港画面
	#enum global  kModeInfo		;戦績表示
	#enum global  kModeFactory	;工廠画面
	#enum global  kModeMap		;マップ画面
	#enum global  kModeBattle	;戦闘画面
	#enum global  kModeResult1	;戦果報告(交戦結果)
	#enum global  kModeResult2	;戦果報告(経験値・MVP表示)
	#enum global  kModeFleet		;編成画面
	kModeUnit = kModeFleet + kFleetNum	;改装画面
	// その他フラグなど
	#define kSoftName "おりこうさんな秘書 改四"	;ソフト名
	#const kMainWX kObjX * 2 + kObjSpace * 3	;メイン画面のサイズ
	#const kMainWY kObjY * 14 + kObjSpace * 18
	sdim current_dir, 260		;カレントディレクトリ
		//current_dir = dir_cur	;デバッグ用
		current_dir = dir_exe	;実行用
	;コンボボックスの内容
	sdim fleets_list, 1024
		for k, 1, kFleetNum + 1
			fleets_list += "第" + k + "艦隊\n"
		next
	sdim units_list, 10240
		for i, 1, kFleetNum + 1
			for j, 1, kUnitNum + 1
				units_list += "第" + i + "-" + j + "番艦\n"
			next
		next
	sdim commands_list, 1024
		for k, 1, kFleetNum + 1
			commands_list += "第" + k + "艦隊\n"
		next
		commands_list += "連合艦隊\n"
		commands_list += "支援艦隊\n"
	sdim home_bgm_path, 260		;母港BGM
	sdim map_bgm_path, 260		;マップBGM
	sdim battle_bgm_path, 260	;戦闘BGM
	auto_getpos_flg = TRUE		;座標取得モード
	fleets_index = 0			;艦隊の番号
	units_index = 0				;艦娘の番号
	commands_index = 0			;保存したい艦隊の種類
	zooming_index = 0			;サブ画面の倍率
	home_bgm_flg = FALSE		;母港画面でのBGM
	map_bgm_flg = FALSE			;マップ画面でのBGM
	battle_bgm_flg = FALSE		;戦闘画面でのBGM
	name_disable_flg = FALSE	;名前を隠すか
	most_front_flg = FALSE		;最前面表示
	flash_px = 0 :flash_py = 0	;Flashの左上座標

// モジュール
	#module misc
		// API呼び出し
		#uselib "gdi32.dll"
		#cfunc CreateDC "CreateDCA" sptr,sptr,sptr,int
		#func DeleteDC  "DeleteDC"  int
		#func BitBlt    "BitBlt"    int,int,int,int,int,int,int,int,int
		// API用の定数
		#const NULL       0
		#const SRCCOPY    0x00CC0020
		#const CAPTUREBLT 0x40000000
		// 各種関数定義
		//サブ画面にコピー
		#deffunc PutWindowSet int window_id_, int buffer_id_
			gsel window_id_
			redraw 0
				switch zooming_index@
					case 0	;100％
						gcopy buffer_id_, 0, 0, kFlashWX, kFlashWY
						swbreak
					case 1	;75％
						gzoom 0.75 * kFlashWX, 0.75 * kFlashWY, buffer_id_, 0, 0, kFlashWX, kFlashWY, 1
						swbreak
					case 2	;50％
						gzoom 0.5 * kFlashWX, 0.5 * kFlashWY, buffer_id_, 0, 0, kFlashWX, kFlashWY, 1
						swbreak
				swend
			redraw 1
		return
		//デスクトップキャプチャ
		#deffunc GetDesktopWindow int window_id_
			buffer window_id_, kDispX, kDispY
			//デスクトップのデバイスコンテキストを作成する
			hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
			//デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kDispX, kDispY, hdc_screen, 0, 0, SRCCOPY | CAPTUREBLT
			//デバイスコンテキストを削除する
			DeleteDC hdc_screen
			redraw 1
		return
		//デスクトップの一部をキャプチャ
		#deffunc GetFlashWindow int buffer_id_, int flash_px_, int flash_py_
			buffer buffer_id_, kFlashWX, kFlashWY
			//デスクトップのデバイスコンテキストを作成する
			hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
			//デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kFlashWX, kFlashWY, hdc_screen, flash_px_, flash_py_, SRCCOPY | CAPTUREBLT
			//デバイスコンテキストを削除する
			DeleteDC hdc_screen
			redraw 1
		return
		//艦これ画面の自動認識
		#deffunc GetPosFlashSquare int window_id_, int output_buffer_id_, var px_, var py_
			;バッファ1：検索先画像
			gsel window_id_
			cvbuffer window_id_, ginfo_sx, ginfo_sy
			cvputimg window_id_
			//バッファ2:黒塗りの800x480の画像
			buffer output_buffer_id_, kFlashWX, kFlashWY
			boxf
			cvbuffer output_buffer_id_, kFlashWX, kFlashWY
			cvputimg output_buffer_id_
			//マッチング処理を行う
			cvmatch px_, py_, CV_TM_SQDIFF, output_buffer_id_, window_id_
		return
		//長方形枠を描画
		#deffunc DrawMouseSquare int mouse_x1_, int mouse_y1_, int mouse_x2_, int mouse_y2_
			if(mouse_x1_ < mouse_x2_){
				square_x1 = mouse_x1_
				square_x2 = mouse_x2_
			}else{
				square_x1 = mouse_x2_
				square_x2 = mouse_x1_
			}
			if(mouse_y1_ < mouse_y2_){
				square_y1 = mouse_y1_
				square_y2 = mouse_y2_
			}else{
				square_y1 = mouse_y2_
				square_y2 = mouse_y1_
			}
			color 0, 255, 255
			line square_x1, square_y1, square_x2, square_y1
			line square_x2, square_y1, square_x2, square_y2
			line square_x2, square_y2, square_x1, square_y2
			line square_x1, square_y2, square_x1, square_y1
		return
		//ファイル名を自動設定
		#defcfunc AutoFileName
			file_name = strf("%04d-%02d-%02d %02d-%02d-%02d.%03d", gettime(0), gettime(1), gettime(3), gettime(4), gettime(5), gettime(6), gettime(7))
			exist file_name + ".png"
			if(strsize == -1) :return file_name + ".png"
			number = 0
			repeat, 1
				exist file_name + "_" + cnt + ".png"
				if(strsize == -1){
					number = cnt
					break
				}
				wait 5
			loop
		return file_name + "_" + number + ".png"
		//タイトルバーの文字列を設定
		#deffunc SetTitle
			mode_str.0 = "現在状況", "母港画面", "戦績表示", "工廠画面", "マップ画面", "戦闘画面", "交戦結果", "戦果報告", "編成画面", "改装画面"
			type_str.0 = "不明",     "母港画面", "戦績表示", "工廠画面", "マップ画面", "戦闘画面", "交戦結果", "戦果報告", "編成画面", "改装画面"
			sdim title_str, 1024
			title_str = kSoftName@ + " - "
			//表示モード
			if(application_mode@ < kTypeFleet){
				//通常
				title_str += mode_str(application_mode@)
			}else{
				if(application_mode@ < kTypeUnit@){
					//編成画面
					title_str += mode_str(kTypeFleet)
				}else{
					//改装画面
					title_str += mode_str(kTypeFleet + 1)
				}
			}
			//艦これ画面の座標
			title_str += " - (" + flash_px@ + ","  +flash_py@ + ") - "
			//判定結果
			if(screen_shot_type@ < kModeFleet){
				//通常
				title_str += type_str(screen_shot_type@)
			}else{
				if(screen_shot_type@ < kModeUnit@){
					//編成画面
					title_str += type_str(kModeFleet)
				}else{
					//改装画面
					title_str += type_str(kModeFleet + 1)
				}
			}
			gsel kPutWindowID@
			title title_str
			gsel kMainWindowID@
		return
		//色判定
		#defcfunc NearColor int px_, int py_, int clr_r_, int clr_g_, int clr_b_
			pget px_, py_
			diff_r = ginfo_r - clr_r_
			diff_g = ginfo_g - clr_g_
			diff_b = ginfo_b - clr_b_
			diff = diff_r * diff_r + diff_g * diff_g + diff_b * diff_b
			if(diff < 500) :return TRUE
		return FALSE
		//状況を判別する
		#defcfunc JudgeSituation int flash_id_
			gsel flash_id_
			//母港画面
			;中央下の履歴ボタン
			if(NearColor(379, 464, 74, 202, 205)){	;通常
				if(NearColor(175, 270, 255, 226, 120)){
					return kTypeHome
				}
			}
			if(NearColor(379, 464, 66, 182, 184)){	;帰投時
				if(NearColor(175, 270, 230, 203, 108)){
					return kTypeHome
				}
			}
			//戦績表示
			;勝率表示部分の真ん中の縦棒
			if(NearColor(306, 276, 84, 84, 84)){
				if(NearColor(251, 203, 35, 158, 159)){
					if(NearColor(272, 479, 159, 155, 61)){
						return kTypeInfo
					}
				}
			}
			//工廠画面
			;建造ボタンと開発ボタン(通常時と数値設定時とで二種類存在することに注意)
			if(NearColor(150, 175, 254, 203, 93)){
				if(NearColor(150, 350, 70, 128, 75)){
					return kTypeFactory
				}
			}
			if(NearColor(150, 175, 203, 162, 74)){
				if(NearColor(150, 350, 56, 102, 60)){
					return kTypeFactory
				}
			}
			//戦闘画面(夜戦込み)
			if(NearColor(388, 4, 89, 201, 212)) :return kTypeBattle	;昼戦
			if(NearColor(388, 4, 89, 177, 220)) :return kTypeBattle	;夜戦
			//マップ画面
			if(NearColor(221, 448, 21, 69, 93)){
				if(NearColor(64, 301, 147, 122, 40)){
					return kTypeMap
				}
			}
			//戦果報告交戦結果
			;提督・艦隊名の左に出ている白縦棒
			if(NearColor(87, 77, 255, 246, 242)){
				;中央の白縦棒(上下)
				if(NearColor(409, 77, 255, 246, 242)){
					return kTypeResult1
				}
			}
			//戦果報告
			;提督・艦隊名の左に出ている白縦棒
			if(NearColor(51, 77, 255, 246, 242)){
				;中央の白縦棒(上中)
				if(NearColor(395, 77, 255, 246, 242)){
					if(NearColor(395, 289, 255, 246, 242)){
						;左下(ガシャン対策)
						if(NearColor(37, 461, 33, 36, 38)){
							return kTypeResult2
						}
					}
				}
			}
			//編成画面
			;随伴艦一括解除ボタン
			if(NearColor(420, 118, 195, 180, 169)){
				;左上の旗
				for k, 0, kFleetNum
					if(NearColor(123 + 30 * k, 126, 33, 150, 151)) :return kTypeFleet + k
				next
			}
			//改装画面
			;枠の柱
			if(NearColor(300, 172, 241, 191, 119)){
				;左上の旗
				offset = -1
				for k, 0, kFleetNum
					if(NearColor(136 + 30 * k, 122, 33, 150, 151)){
						offset = k * kUnitNum
						_break
					}
				next
				if(offset < 0) :return kTypeUnknown
				;枠
				for k, 0, kUnitNum
					if(NearColor(294, 145 + 54 * k, 255, 102, 29)) :return kTypeUnit@ + offset + k
				next
			}
		return kTypeUnknown
		//「母港画面」かどうかを判定する(BGM・名前隠し用)
		#defcfunc CheckHomeFlg int flash_id_
			;通常時
			if(NearColor(665, 42, 83, 159, 73)){		;バケツアイコン
				if(NearColor(736, 61, 172, 128, 95)){	;ボーキアイコン
					return TRUE
				}
			}
			;帰投時
			if(NearColor(669, 61, 150, 139, 98)){	;弾薬アイコン
				if(NearColor(737, 62, 83, 64, 49)){	;ボーキアイコン
					return TRUE
				}
			}
		return FALSE
	#global

	onexit gosub *exit

// ウィンドウ周りを初期設定
	//保存用バッファ
	buffer kFlashBufferID,  kFlashWX, kFlashWY
	for k, kTypeHome, kTypeUnit + kFleetNum * kUnitNum + 1
		buffer kOffsetBufferID + k, kFlashWX, kFlashWY
	next
	buffer kPutTempWindowID, kFlashWX, kFlashWY
	//メインウィンドウ
	screen kPutWindowID, kFlashWX, kFlashWY, 4
	title kSoftName
	screen kMainWindowID, kMainWX, kMainWY
	title kSoftName
	gsel kMainWindowID, 2
	color
		line 0, kObjSpace     + kObjSpaceY    , kMainWX, kObjSpace     + kObjSpaceY
		line 0, kObjSpace * 2 + kObjSpaceY * 6, kMainWX, kObjSpace * 2 + kObjSpaceY * 6
		line 0, kObjSpace * 3 + kObjSpaceY * 9, kMainWX, kObjSpace * 3 + kObjSpaceY * 9
	objsize kObjX, kObjY
		pos kObjSpace             , kObjSpace
			combox auto_getpos_flg,,"手動設定\n自動設定"
		pos kObjSpace + kObjSpaceX, kObjSpace
			button gosub "座標取得", *get_pos

		pos kObjSpace             , kObjSpace * 2 + kObjSpaceY
			button gosub "現在状況", *mode_now
		pos kObjSpace + kObjSpaceX, kObjSpace * 2 + kObjSpaceY
			button gosub "母港画面", *mode_home
		pos kObjSpace             , kObjSpace * 2 + kObjSpaceY * 2
			button gosub "戦績表示", *mode_info
		pos kObjSpace + kObjSpaceX, kObjSpace * 2 + kObjSpaceY * 2
			button gosub "工廠画面", *mode_factory
		pos kObjSpace             , kObjSpace * 2 + kObjSpaceY * 3
			button gosub "マップ画面", *mode_map
		pos kObjSpace + kObjSpaceX, kObjSpace * 2 + kObjSpaceY * 3
			button gosub "戦闘画面", *mode_battle
		pos kObjSpace             , kObjSpace * 2 + kObjSpaceY * 4
			button gosub "交戦結果", *mode_result1
		pos kObjSpace + kObjSpaceX, kObjSpace * 2 + kObjSpaceY * 4
			button gosub "戦果報告", *mode_result2
		pos kObjSpace + kObjSpaceX, kObjSpace * 2 + kObjSpaceY * 5
			button gosub "【画像保存】", *save_picture

		pos kObjSpace             , kObjSpace * 3 + kObjSpaceY * 6
			combox fleets_index,,fleets_list
		pos kObjSpace + kObjSpaceX, kObjSpace * 3 + kObjSpaceY * 6
			button gosub "編成画面", *mode_fleet
		pos kObjSpace             , kObjSpace * 3 + kObjSpaceY * 7
			combox units_index,,units_list
		pos kObjSpace + kObjSpaceX, kObjSpace * 3 + kObjSpaceY * 7
			button gosub "改装画面", *mode_unit
		pos kObjSpace             , kObjSpace * 3 + kObjSpaceY * 8
			combox commands_index,,commands_list
		pos kObjSpace + kObjSpaceX, kObjSpace * 3 + kObjSpaceY * 8
			button gosub "【○○艦隊】", *save_fleets

		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 9
			chkbox "名前隠し", name_disable_flg
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 9
			combox zooming_index,,"倍率100％\n倍率75％\n倍率50％"
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 10
			chkbox "母港BGM", home_bgm_flg
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 10
			button gosub "参照...", *browse_home_bgm
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 11
			chkbox "マップBGM", map_bgm_flg
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 11
			button gosub "参照...", *browse_map_bgm
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 12
			chkbox "戦闘BGM", battle_bgm_flg
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 12
			button gosub "参照...", *browse_battle_bgm
		pos kObjSpace             , kObjSpace * 4 + kObjSpaceY * 13
			button gosub "BGM停止", *stop_bgm
		pos kObjSpace + kObjSpaceX, kObjSpace * 4 + kObjSpaceY * 13
			button gosub "情報...", *about

// 自動更新を行う
	zooming_index_ = zooming_index
	most_front_flg_ = most_front_flg
	home_bgm_flg_   = FALSE
	map_bgm_flg_    = FALSE
	battle_bgm_flg_ = FALSE
	repeat
		SetTitle
		// Flash画面を自動取得
		GetFlashWindow kFlashBufferID, flash_px, flash_py
		// 結果を判定し、自動で格納する
		screen_shot_type = JudgeSituation(kFlashBufferID)
		if(screen_shot_type != kTypeUnknown){
			gsel kOffsetBufferID + screen_shot_type
			gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
		}
		// アプリの状態に合わせ表示を変更する
		// (どうでもいいけどなんでHSPには「else if」って記法がないんだよ！)
		//サブ画面のサイズを変更する
		if(zooming_index_ != zooming_index){
			switch zooming_index
				case 0	;100％
					screen kPutWindowID, kFlashWX, kFlashWY, 4
					swbreak
				case 1	;75％
					screen kPutWindowID, 0.75 * kFlashWX, 0.75 * kFlashWY, 4
					swbreak
				case 2	;50％
					screen kPutWindowID, 0.5 * kFlashWX, 0.5 * kFlashWY, 4
					swbreak
			swend
			zooming_index_ = zooming_index
		}
		//サブ画面用のバッファに画像を転送する
		gsel kPutTempWindowID
		if(application_mode == kModeNow){
			//現在状況
			gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
		}else{
			//それ以外
			if(application_mode == kModeFleet){
				gcopy kOffsetBufferID + application_mode + fleets_index, 0, 0, kFlashWX, kFlashWY
			}else{if(application_mode == kModeUnit){
				gcopy kOffsetBufferID + application_mode + units_index, 0, 0, kFlashWX, kFlashWY
			}else{
				gcopy kOffsetBufferID + application_mode, 0, 0, kFlashWX, kFlashWY
			}}
		}
		//サブ画面のバッファに名前隠し処理を行う
		if(name_disable_flg){
			if(CheckHomeFlg(kPutTempWindowID)){	;要するに左上の歯車のすぐ右
				color :boxf 111, 0, 273, 25
			}
			if(JudgeSituation(kPutTempWindowID) == kTypeInfo){	;戦績表示ではでっかく提督名が載る
				color :boxf 201, 123, 496, 153
			}
			if(JudgeSituation(kPutTempWindowID) == kTypeResult1){	;交戦結果
				color :boxf 92, 82, 264, 106
			}
			if(JudgeSituation(kPutTempWindowID) == kTypeResult2){	;戦果報告
				color :boxf 56, 82, 228, 106
			}
		}
		PutWindowSet kPutWindowID, kPutTempWindowID
		//BGMフラグに合わせ演奏する
		;母港BGM
		if(CheckHomeFlg(kFlashBufferID)){
			if(home_bgm_flg){
				if(home_bgm_flg_ == FALSE){
					if(application_mode == kModeNow){
						mmplay 0
						home_bgm_flg_ = TRUE
					}
				}
			}else{
				mmstop
				home_bgm_flg_ = FALSE
			}
		}else{
			;マップBGM
			if(screen_shot_type == kTypeMap){
				home_bgm_flg_ = FALSE
				if(map_bgm_flg){
					if(map_bgm_flg_ == FALSE){
						mmplay 1
						map_bgm_flg_ = TRUE
					}
				}
			}else{
				if(screen_shot_type != kTypeUnknown){
					map_bgm_flg_ = FALSE
					if(screen_shot_type == kTypeBattle){
						map_bgm_flg_ = FALSE
						if(battle_bgm_flg){
							if(battle_bgm_flg_ == FALSE){
								mmplay 2
								battle_bgm_flg_ = TRUE
							}
						}
					}else{
						battle_bgm_flg_ = FALSE
						mmstop
					}
				}
			}
		}
		await 1000 / 30
	loop

//各状況のボタンを押した際の処理
*mode_now     :application_mode = kModeNow     :return
*mode_home    :application_mode = kModeHome    :return
*mode_info    :application_mode = kModeInfo    :return
*mode_factory :application_mode = kModeFactory :return
*mode_map     :application_mode = kModeMap     :return
*mode_battle  :application_mode = kModeBattle  :return
*mode_result1 :application_mode = kModeResult1 :return
*mode_result2 :application_mode = kModeResult2 :return
*mode_fleet   :application_mode = kModeFleet   :return
*mode_unit    :application_mode = kModeUnit    :return
*browse_home_bgm
	dialog "wav;*.mp3;*.wma", 16, "音楽ファイル"
	if(stat){
		home_bgm_path = refstr
		mmload home_bgm_path, 0, 1
	}
return
*browse_map_bgm
	dialog "wav;*.mp3;*.wma", 16, "音楽ファイル"
	if(stat){
		map_bgm_path = refstr
		mmload map_bgm_path, 1, 1
	}
return
*browse_battle_bgm
	dialog "wav;*.mp3;*.wma", 16, "音楽ファイル"
	if(stat){
		battle_bgm_path = refstr
		mmload battle_bgm_path, 2, 1
	}
return
*stop_bgm
	home_bgm_flg_ = FALSE
	map_bgm_flg_ = FALSE
	battle_bgm_flg_ = FALSE
	mmstop
return
*about
	dialog "ソフト名：" + kSoftName + "\n作成者：とりうみさん講座の人\n最終更新日：2015/02/15",,kSoftName
return

//座標取得
*get_pos
	if(auto_getpos_flg){
		// 座標を自動で取得する
		//デスクトップを撮影する
		GetDesktopWindow kDeskBufferID
		//撮影した画像から座標を検索する
		GetPosFlashSquare kDeskBufferID, kFlashBufferID, flash_px, flash_py
		SetTitle
	}else{
		// 座標を手動で取得する
		//デスクトップを撮影する
		GetDesktopWindow kDeskBufferID
		//手動で枠を選択させる
		;初期設定
		bgscr kSubWindowID, kDispX, kDispY, , 0, 0
		gsel kSubWindowID, 2
		font msgothic, kLargeFontSize
		;画面表示
		gcopy kDeskBufferID, 0, 0, kDispX, kDispY
		color :mes "枠を選択して下さい。(Escで終了)"
		;選択操作
		is_mouse_button = FALSE
		is_mouse_select = FALSE
		mouse_pos_x1 = 0 :mouse_pos_y1 = 0
		repeat
			stick key, kStickMouse
			if(key & kStickEscKey) :break
			if(key & kStickMouse){
				if(is_mouse_button){
					// 選択中
					redraw 0
						pos 0, 0
						gcopy kDeskBufferID, 0, 0, kDispX, kDispY
						color :mes "枠を選択して下さい。(Escで終了)"
						DrawMouseSquare mousex, mousey, mouse_pos_x1, mouse_pos_y1
					redraw 1
				}else{
					// 選択開始
					mouse_pos_x1 = mousex
					mouse_pos_y1 = mousey
					is_mouse_button = TRUE
				}
			}else{
				if(is_mouse_button){
					// 選択終了
					mouse_pos_x2 = mousex
					mouse_pos_y2 = mousey
					if(mouse_pos_x1 < mouse_pos_x2){
						square_x = mouse_pos_x1
						square_xsize = mouse_pos_x2 - mouse_pos_x1 + 1
					}else{
						square_x = mouse_pos_x2
						square_xsize = mouse_pos_x1 - mouse_pos_x2 + 1
					}
					if(mouse_pos_y1 < mouse_pos_y2){
						square_y = mouse_pos_y1
						square_ysize = mouse_pos_y2 - mouse_pos_y1 + 1
					}else{
						square_y = mouse_pos_y2
						square_ysize = mouse_pos_y1 - mouse_pos_y2 + 1
					}
					is_mouse_button = FALSE
					is_mouse_select = TRUE
					break
				}else{
					// 何もしていない
				}
			}
			wait 5
		loop
		;選択結果から検索を行う
		gsel kSubWindowID, -1
		if(is_mouse_select){
			buffer kTempBufferID, square_xsize, square_ysize
			gcopy kDeskBufferID, square_x, square_y, square_xsize, square_ysize
			if((square_xsize < kFlashWX) || (square_ysize < kFlashWY)){
			}else{
				GetPosFlashSquare kTempBufferID, kFlashBufferID, flash_px, flash_py
				flash_px += square_x :flash_py += square_y
				SetTitle
			}
		}
	}
return

//画像保存
*save_picture
	gsel kPutWindowID
	cvbuffer kPutBufferID, ginfo_sx, ginfo_sy
	cvputimg kPutBufferID
	cvsave current_dir + "\\" + AutoFileName(), kPutBufferID
	gsel kMainWindowID
return

//艦隊画像保存
*save_fleets
	if(commands_index < kFleetNum){
		// 第1〜第4艦隊
		buffer kTempBufferID, kUnitWX * 3, kUnitWY * 2
		for y, 0, 2
			for x, 0, 3
				pos x * kUnitWX, y * kUnitWY
				gcopy kOffsetBufferID + kTypeUnit + commands_index * kUnitNum + (y * 3 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
			next
		next
		cvbuffer kCVTempBufferID, kUnitWX * 3, kUnitWY * 2
		cvputimg kCVTempBufferID
		cvsave AutoFileName(), kCVTempBufferID
	}else{
		// 連合・支援艦隊
		buffer kTempBufferID, kUnitWX * 4, kUnitWY * 3
		for z, 0, 2
			for y, 0, 3
				for x, 0, 2
					pos (z * 2 + x) * kUnitWX, y * kUnitWY
					gcopy kOffsetBufferID + kTypeUnit + (commands_index - kFleetNum) * (kUnitNum * 2) + (z * 6 + y * 2 + x), kUnitPX, kUnitPY, kUnitWX, kUnitWY
				next
			next
		next
		cvbuffer kCVTempBufferID, kUnitWX * 4, kUnitWY * 3
		cvputimg kCVTempBufferID
		cvsave AutoFileName(), kCVTempBufferID
		gsel kMainWindowID
	}
return

//終了確認
*exit
	dialog "終了しますか？", 2, kSoftName
	if(stat == 6) :end
return
