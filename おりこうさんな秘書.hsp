/* おりこうさんな秘書改
 * 参考：sakura氏のhttp://hspnext.com/hspkura/hspkura02.htm
 */

	#packopt name "おりこうさんな秘書"
	#include "hspcv.as"		;画像処理でOpenCVを使うためのライブラリ

// 通常の定数
	// 真偽
	#const global TRUE  1
	#const global FALSE 0
	// 画面ID
	#const kMainWindowID  0	;操作画面
	#const kSubWindowID   1	;手動指定用画面
	#const kDeskBufferID  2	;スクショ用
	#const kFlashBufferID 3	;検索用
	#const kTempBufferID  4	;テンポラリ用
	// OpenCV用ID
	#const kCVDeskBufferID  0
	#const kCVFlashBufferID 1
	// サイズ定義
	#define global kDispX   ginfo_dispx
	#define global kDispY   ginfo_dispy
	#const  global kFlashWX 800
	#const  global kFlashWY 480
	#const kMainWX 800
	#const kMainWY 600
	#const kFontSize 30
	#const kObjX 80
	#const kObjY 20
	#const kObjSpace 10
	#const kObjSpaceX kObjSpace + kObjX
	#const kObjSpaceY kObjSpace + kObjY
	// キーボード・マウス操作
	#const kStickEscKey 128
	#const kStickMouse  256
	// 画面状態(tye_strと対応)
	#const global kTypeUnknown 0
	#const global kTypeResult  1
	#const global kTypeHome    2
	#const global kTypeInfo    3
	#const global kTypeTeam1   4
	#const global kTypeTeam2   5
	#const global kTypeTeam3   6
	#const global kTypeTeam4   7
	// アプリ機能(mode_strと対応)
	#const kModeNow    0
	#const kModeReslut 1
	#const kModeHome   2
	#const kModeInfo   3
	#const kModeTeam1  4
	#const kModeTeam2  5
	#const kModeTeam3  6
	#const kModeTeam4  7
	// タスクトレイ機能
	#define WM_LBUTTONDOWN  $00000201
	#define NOTIFY_TRAYICON $00001400
	// その他フラグなど
	#define kSoftName "おりこうさんな秘書(仮)"
	#const kOffsetY kMainWY - kFlashWY
	type_str.0 = "不明",     "戦果報告", "母港画面", "戦績表示", "編成画面(第1)", "編成画面(第2)", "編成画面(第3)", "編成画面(第4)"
	mode_str.0 = "現在状況", "戦果報告", "母港画面", "戦績表示", "編成画面(第1)", "編成画面(第2)", "編成画面(第3)", "編成画面(第4)"
	auto_getpos_flg  = TRUE
	auto_capture_flg = FALSE
	name_disable_flg = FALSE
	tasktray_flg = FALSE
	screen_shot_type = kTypeUnknown
	application_mode = kModeNow

	#uselib "user32.dll"
		#func IsIconic "IsIconic" sptr

// モジュール
	#module tasktray
		// API呼び出し
		#uselib "kernel32.dll"
			#func GetModuleFileName "GetModuleFileNameA" int,var,int
		#uselib "shell32.DLL"
			#func ExtractIconEx "ExtractIconExA" var,int,var,var,int
			#func Shell_NotifyIcon "Shell_NotifyIcon" int,var
		// API用の定数
		#const NIM_ADD     $00000000
		#const NIM_DELETE  $00000002
		#const NIM_MODIFY  $00000001
		#const NIF_ICON    $00000002
		#const NIF_MESSAGE $00000001
		#const NIF_TIP     $00000004
		// タスクトレイにアイコン格納
		#defcfunc taskicoput str tooltip_text_
			// ツールチップに表示するテキストを取得
			tooltip_text = tooltip_text_
			if(strlen(tooltip_text) == 0) :tooltip_text = ""
			// 自分自身のファイル名を取得
			sdim lpFileName, 260
			GetModuleFileName hModule, lpFileName, 260
			SelfName = lpFileName
			icobig = 0
			ExtractIconEx SelfName, 0, icobig, icosmall, 1
			hIcon = icosmall
			// NOTIFYICONDATA 構造体
			dim IcoData, 22
			IcoData(0) = 88
			IcoData(1) = hwnd
			IcoData(2) = 1
			IcoData(3) = NIF_MESSAGE | NIF_ICON | NIF_TIP
			IcoData(4) = $00001400	//なんでglobalな#constじゃダメなんだよクソが！
			IcoData(5) = hIcon
			poke IcoData, 24, tooltip_text
			// タスクトレイにアイコンを追加
			Shell_NotifyIcon NIM_ADD, IcoData
		return hIcon
		// タスクトレイアイコンを削除
		#deffunc taskicoclr
			// NOTIFYICONDATA 構造体
			dim IcoData, 22
			IcoData(0) = 88
			IcoData(1) = hwnd
			IcoData(2) = 1
			IcoData(3) = NIF_ICON
			// タスクトレイのアイコンを削除
			Shell_NotifyIcon NIM_DELETE, IcoData
		return 0
	#global
	#module misc
		// API呼び出し
		#uselib "gdi32.dll"
		#cfunc CreateDC "CreateDCA" sptr,sptr,sptr,int
		#func DeleteDC  "DeleteDC"  int
		#func BitBlt    "BitBlt"    int,int,int,int,int,int,int,int,int
		// API用の定数
		#const NULL       0
		#const SRCCOPY    0x00CC0020
		#const CAPTUREBLT 0x40000000
		// 各種関数定義
		//デスクトップキャプチャ
		#deffunc GetDesktopWindow int window_id_
			now_id = ginfo_sel
			gsel now_id, -1	//メイン画面を非表示にする
			buffer window_id_, kDispX, kDispY
			//デスクトップのデバイスコンテキストを作成する
			hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
			//デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kDispX, kDispY, hdc_screen, 0, 0, SRCCOPY | CAPTUREBLT
			//デバイスコンテキストを削除する
			DeleteDC hdc_screen
			redraw 1
			gsel now_id, 1	//画面を再表示する
		return
		//デスクトップの一部をキャプチャ
		#deffunc GetFlashWindow int buffer_id_, int flash_px_, int flash_py_
			buffer buffer_id_, kFlashWX, kFlashWY
			//デスクトップのデバイスコンテキストを作成する
			hdc_screen = CreateDC ("DISPLAY", NULL, NULL, NULL)
			//デスクトップの画像をコピーする
			BitBlt hdc, 0, 0, kFlashWX, kFlashWY, hdc_screen, flash_px_, flash_py_, SRCCOPY | CAPTUREBLT
			//デバイスコンテキストを削除する
			DeleteDC hdc_screen
			redraw 1
		return
		//艦これ画面の自動認識
		#deffunc GetPosFlashSquare int window_id_, int output_buffer_id_, var px_, var py_
			;バッファ1：検索先画像
			gsel window_id_
			cvbuffer window_id_, ginfo_sx, ginfo_sy
			cvputimg window_id_
			//バッファ2:黒塗りの800x480の画像
			buffer output_buffer_id_, kFlashWX, kFlashWY
			boxf
			cvbuffer output_buffer_id_, kFlashWX, kFlashWY
			cvputimg output_buffer_id_
			//マッチング処理を行う
			cvmatch px_, py_, CV_TM_SQDIFF, output_buffer_id_, window_id_
		return
		//長方形枠を描画
		#deffunc DrawMouseSquare int mouse_x1_, int mouse_y1_, int mouse_x2_, int mouse_y2_
			if(mouse_x1_ < mouse_x2_){
				square_x1 = mouse_x1_
				square_x2 = mouse_x2_
			}else{
				square_x1 = mouse_x2_
				square_x2 = mouse_x1_
			}
			if(mouse_y1_ < mouse_y2_){
				square_y1 = mouse_y1_
				square_y2 = mouse_y2_
			}else{
				square_y1 = mouse_y2_
				square_y2 = mouse_y1_
			}
			color 0, 255, 255
			line square_x1, square_y1, square_x2, square_y1
			line square_x2, square_y1, square_x2, square_y2
			line square_x2, square_y2, square_x1, square_y2
			line square_x1, square_y2, square_x1, square_y1
		return
		//ファイル名を自動設定
		#defcfunc AutoFileName
			file_name = strf("%04d_%02d_%02d %02d_%02d_%02d", gettime(0), gettime(1), gettime(3), gettime(4), gettime(5), gettime(6))
			number = 0
			repeat
				exist file_name + "_" + (cnt + 1) + ".png"
				if(strsize == -1){
					number = cnt + 1
					break
				}
				wait 5
			loop
		return file_name + "_" + number + ".png"
		//タイトルバーの文字列を設定
		#deffunc SetTitle
			title kSoftName@ + " - " + mode_str@(application_mode@) + " - (" + flash_px@ + ","  +flash_py@ + ") - " + type_str@(screen_shot_type@)
		return
		//色判定
		#defcfunc NearColor int px_, int py_, int clr_r_, int clr_g_, int clr_b_
			pget px_, py_
			diff_r = ginfo_r - clr_r_
			diff_g = ginfo_g - clr_g_
			diff_b = ginfo_b - clr_b_
			diff = diff_r * diff_r + diff_g * diff_g + diff_b * diff_b
			if(diff < 500) :return TRUE
		return FALSE
		//状況を判別する
		#defcfunc JudgeSituation int flash_id_
			gsel flash_id_
			//戦果報告
			;提督・艦隊名の左に出ている白縦棒
			if(NearColor(51, 77, 255, 246, 242)){
				;中央の白縦棒(上下)
				if(NearColor(395, 77, 255, 246, 242)){
					if(NearColor(37, 461, 33, 36, 38)){
						return kTypeResult
					}
				}
			}
			//母港画面
			;中央下の履歴ボタン
			if(NearColor(379, 464, 74, 202, 205)) :return kTypeHome	;通常
			if(NearColor(379, 464, 66, 182, 184)) :return kTypeHome	;帰投時
			//戦績表示
			;勝率表示部分の真ん中の縦棒
			if(NearColor(306, 276, 84, 84, 84)){
				if(NearColor(251, 203, 35, 158, 159)){
					return kTypeInfo
				}
			}
			//編成画面
			;随伴艦一括解除ボタン
			if(NearColor(420, 118, 195, 180, 169)){
				if(NearColor(123, 126, 33, 150, 151)) :return kTypeTeam1
				if(NearColor(153, 126, 33, 150, 151)) :return kTypeTeam2
				if(NearColor(183, 126, 33, 150, 151)) :return kTypeTeam3
				if(NearColor(213, 126, 33, 150, 151)) :return kTypeTeam4
			}
		return kTypeUnknown
	#global

// ウィンドウ周りを初期設定
	//保存用バッファ
	buffer kFlashBufferID,  kFlashWX, kFlashWY
	buffer 5 + kTypeResult, kFlashWX, kFlashWY
	buffer 5 + kTypeHome,   kFlashWX, kFlashWY
	buffer 5 + kTypeInfo,   kFlashWX, kFlashWY
	buffer 5 + kTypeTeam1,  kFlashWX, kFlashWY
	buffer 5 + kTypeTeam2,  kFlashWX, kFlashWY
	buffer 5 + kTypeTeam3,  kFlashWX, kFlashWY
	buffer 5 + kTypeTeam4,  kFlashWX, kFlashWY
	//メインウィンドウ
	screen kMainWindowID, kMainWX, kMainWY
	oncmd gosub *OnMotificmd, NOTIFY_TRAYICON
	objsize kObjX, kObjY
		pos kObjSpace, kObjSpace
			combox auto_getpos_flg,,"手動設定\n自動設定"
		pos kObjSpace + kObjSpaceX, kObjSpace
			button gosub "座標取得", *get_pos
		pos kObjSpace + kObjSpaceX * 2, kObjSpace
			button gosub "画像保存", *save_picture
		pos kObjSpace + kObjSpaceX * 3, kObjSpace
			chkbox "自動更新", auto_capture_flg
		pos kObjSpace + kObjSpaceX * 4, kObjSpace
			chkbox "名前隠し", name_disable_flg
		pos kObjSpace + kObjSpaceX * 5, kObjSpace
			chkbox "タスクトレイ", tasktray_flg
		pos kObjSpace, kObjSpace + kObjSpaceY
			button gosub "現在状況", *mode_now
		pos kObjSpace + kObjSpaceX, kObjSpace + kObjSpaceY
			button gosub "戦果報告", *mode_result
		pos kObjSpace + kObjSpaceX * 2, kObjSpace + kObjSpaceY
			button gosub "母港画面", *mode_home
		pos kObjSpace + kObjSpaceX * 3, kObjSpace + kObjSpaceY
			button gosub "戦績表示", *mode_info
		pos kObjSpace + kObjSpaceX * 4, kObjSpace + kObjSpaceY
			button gosub "編成画面1", *mode_team1
		pos kObjSpace + kObjSpaceX * 5, kObjSpace + kObjSpaceY
			button gosub "編成画面2", *mode_team2
		pos kObjSpace + kObjSpaceX * 6, kObjSpace + kObjSpaceY
			button gosub "編成画面3", *mode_team3
		pos kObjSpace + kObjSpaceX * 7, kObjSpace + kObjSpaceY
			button gosub "編成画面4", *mode_team4
	SetTitle

// 自動更新を行う
	repeat
		// 自動更新を行う
		if(auto_capture_flg){
			redraw 0
				SetTitle
				GetFlashWindow kFlashBufferID, flash_px, flash_py
				gsel kMainWindowID
			redraw 1
		}else{
			SetTitle
		}
		// 現在の状況を自動判定する
		screen_shot_type = JudgeSituation(kFlashBufferID)
		if(screen_shot_type != kTypeUnknown){
			gsel 5 + screen_shot_type
			gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
		}
		gsel kMainWindowID
		// アプリの状態に合わせ表示を変更する
		redraw 0
			switch application_mode
				case kModeNow
					if(auto_capture_flg){
						pos 0, kOffsetY
						gcopy kFlashBufferID, 0, 0, kFlashWX, kFlashWY
					}
				swbreak
				case kModeReslut
					pos 0, kOffsetY
					gcopy 5 + kTypeResult, 0, 0, kFlashWX, kFlashWY
					if(name_disable_flg){
						color :boxf 56, 82 + kOffsetY, 228, 106 + kOffsetY
					}
				swbreak
				case kModeHome
					pos 0, kOffsetY
					gcopy 5 + kTypeHome, 0, 0, kFlashWX, kFlashWY
					if(name_disable_flg){
						color :boxf 111, 0 + kOffsetY, 273, 25 + kOffsetY
					}
				swbreak
				case kModeInfo
					pos 0, kOffsetY
					gcopy 5 + kTypeInfo, 0, 0, kFlashWX, kFlashWY
					if(name_disable_flg){
						;二箇所消す必要が有ることに注意
						color :boxf 111, 0 + kOffsetY, 273, 25 + kOffsetY
						color :boxf 201, 123 + kOffsetY, 496, 153 + kOffsetY
					}
				swbreak
				case kModeTeam1
					pos 0, kOffsetY
					gcopy 5 + kTypeTeam1, 0, 0, kFlashWX, kFlashWY
					if(name_disable_flg){
						color :boxf 111, 0 + kOffsetY, 273, 25 + kOffsetY
					}
				swbreak
				case kModeTeam2
					pos 0, kOffsetY
					gcopy 5 + kTypeTeam2, 0, 0, kFlashWX, kFlashWY
					if(name_disable_flg){
						color :boxf 111, 0 + kOffsetY, 273, 25 + kOffsetY
					}
				swbreak
				case kModeTeam3
					pos 0, kOffsetY
					gcopy 5 + kTypeTeam3, 0, 0, kFlashWX, kFlashWY
					if(name_disable_flg){
						color :boxf 111, 0 + kOffsetY, 273, 25 + kOffsetY
					}
				swbreak
				case kModeTeam4
					pos 0, kOffsetY
					gcopy 5 + kTypeTeam4, 0, 0, kFlashWX, kFlashWY
					if(name_disable_flg){
						color :boxf 111, 0 + kOffsetY, 273, 25 + kOffsetY
					}
				swbreak
			swend
		redraw 1
		// 最小化を検知して、タスクトレイに格納するかを決める
		IsIconic hwnd
		if(stat == 1){
			// 最小化しているのでタスクトレイに格納可能
			if(tasktray_flg){
				gsel kMainWindowID, -1
				tooltext = kSoftName
				hIcon = taskicoput(tooltext)
				repeat
					IsIconic hwnd
					if(stat == 0) :break
					wait 10
				loop
			}
		}
		wait 10
	loop

//各状況のボタンを押した際の処理
*mode_now
	application_mode = kModeNow
return
*mode_result
	application_mode = kModeReslut
return
*mode_home
	application_mode = kModeHome
return
*mode_info
	application_mode = kModeInfo
return
*mode_team1
	application_mode = kModeTeam1
return
*mode_team2
	application_mode = kModeTeam2
return
*mode_team3
	application_mode = kModeTeam3
return
*mode_team4
	application_mode = kModeTeam4
return

//座標取得
*get_pos
	if(auto_getpos_flg){
		// 座標を自動で取得する
		//デスクトップを撮影する
		GetDesktopWindow kDeskBufferID
		//撮影した画像から座標を検索する
		GetPosFlashSquare kDeskBufferID, kFlashBufferID, flash_px, flash_py
		gsel kMainWindowID
		SetTitle
	}else{
		// 座標を手動で取得する
		//デスクトップを撮影する
		GetDesktopWindow kDeskBufferID
		//手動で枠を選択させる
		;初期設定
		bgscr kSubWindowID, kDispX, kDispY, , 0, 0
		gsel kSubWindowID, 2
		font msgothic, kFontSize
		;画面表示
		gcopy kDeskBufferID, 0, 0, kDispX, kDispY
		color :mes "枠を選択して下さい。(Escで終了)"
		;選択操作
		is_mouse_button = FALSE
		mouse_pos_x1 = 0 :mouse_pos_y1 = 0
		repeat
			stick key, kStickMouse
			if(key & kStickEscKey) :end
			if(key & kStickMouse){
				if(is_mouse_button){
					// 選択中
					redraw 0
						pos 0, 0
						gcopy kBufferID1, 0, 0, kDispX, kDispY
						color :mes "枠を選択して下さい。(Escで終了)"
						DrawMouseSquare mousex, mousey, mouse_pos_x1, mouse_pos_y1
					redraw 1
				}else{
					// 選択開始
					mouse_pos_x1 = mousex
					mouse_pos_y1 = mousey
					is_mouse_button = TRUE
				}
			}else{
				if(is_mouse_button){
					// 選択終了
					mouse_pos_x2 = mousex
					mouse_pos_y2 = mousey
					if(mouse_pos_x1 < mouse_pos_x2){
						square_x = mouse_pos_x1
						square_xsize = mouse_pos_x2 - mouse_pos_x1 + 1
					}else{
						square_x = mouse_pos_x2
						square_xsize = mouse_pos_x1 - mouse_pos_x2 + 1
					}
					if(mouse_pos_y1 < mouse_pos_y2){
						square_y = mouse_pos_y1
						square_ysize = mouse_pos_y2 - mouse_pos_y1 + 1
					}else{
						square_y = mouse_pos_y2
						square_ysize = mouse_pos_y1 - mouse_pos_y2 + 1
					}
					is_mouse_button = FALSE
					break
				}else{
					// 何もしていない
				}
			}
			wait 5
		loop
		;選択結果から検索を行う
		gsel kSubWindowID, -1
		buffer kTempBufferID, square_xsize, square_ysize
		gcopy kDeskBufferID, square_x, square_y, square_xsize, square_ysize
		if((square_xsize < kFlashWX) || (square_ysize < kFlashWY)){
			gsel kMainWindowID
		}else{
			GetPosFlashSquare kTempBufferID, kFlashBufferID, flash_px, flash_py
			flash_px += square_x :flash_py += square_y
			gsel kMainWindowID
			SetTitle
		}
	}
return

//画像保存
*save_picture
	buffer kFlashBufferID, kFlashWX, kFlashWY
	gcopy kMainWindowID, 0, kMainWY - kFlashWY, kFlashWX, kFlashWY
	cvbuffer kCVFlashBufferID, kFlashWX, kFlashWY
	cvputimg kCVFlashBufferID
	cvsave AutoFileName(), kCVFlashBufferID
	gsel kMainWindowID
return

// NOTIFY_TRAYICONを処理する
*OnMotificmd
	itemID = lparam
	switch itemID
		case WM_LBUTTONDOWN
			gsel kMainWindowID, 2
			gsel kMainWindowID, 1
			taskicoclr
			swbreak
	swend
return
